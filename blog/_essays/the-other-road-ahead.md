---
layout: essay
title: "The Other Road Ahead"
category: Mindset
difficulty: 중급
year: 
url_original: "https://paulgraham.com/road.html"
---

## 요약 (Summary)

🎯 다른 길은 무엇일까요?

✨ 핵심 내용 요약

2001년 Paul Graham이 예측: **소프트웨어가 서비스가 될 것입니다**. 당시에는 혁명적 아이디어였습니다.

당시 소프트웨어는 "제품"이었습니다: CD로 사서 컴퓨터에 설치합니다. Microsoft Office, Adobe Photoshop - 모두 이 방식이었죠. Graham은 다른 길을 봤습니다: 웹 브라우저로 쓰는 소프트웨어. 설치 불필요, 자동 업데이트, 어디서나 접근. 이게 바로 SaaS(Software as a Service)입니다. 2025년: Graham이 완전히 옳았습니다. Google Docs, Notion, Figma - 모두 웹 기반입니다. 교훈: **대세에 반대하되, 확신을 가지세요**. 모두가 틀렸을 수 있습니다.

**핵심 포인트**
• 소프트웨어가 제품에서 서비스로 변했습니다
• 웹 기반이 미래였습니다(그리고 지금은 현재)
• 대세에 반대할 용기를 가지세요

🚀 오늘 바로 실천해볼 한 가지
"모두가 이렇게 한다"는 것에 의문을 가지세요. 다른 방법은 없을까요?

---

## 한국어 번역 (Korean Translation)

2001년 9월(이 기사에서는 차세대 소프트웨어의 대부분이 서버 기반일 수 있는 이유, 이것이 프로그래머에게 의미하는 바, 이 새로운 종류의 소프트웨어가 스타트업에 좋은 기회인 이유를 설명합니다. 이 내용은 BBN Labs에서의 대화에서 파생되었습니다.) 1995년 여름, 내 친구 Robert Morris와 나는 스타트업을 시작하기로 결정했습니다.당시 Netscape의 IPO를 앞둔 홍보 캠페인은 한창 진행 중이었으며 언론에서는 온라인 상거래에 대한 이야기가 많이 나왔습니다.당시 웹상에는 실제 매장이 30개 정도 있었으며 모두 손으로 만들어졌습니다.온라인 상점이 많아지면 그것을 만들기 위한 소프트웨어가 필요할 것이기 때문에 우리는 몇 가지를 작성하기로 결정했습니다. 첫 주 정도 동안 우리는 이것을 일반적인 데스크톱 응용 프로그램으로 만들려고 했습니다.그러던 어느 날 우리는 브라우저를 인터페이스로 사용하여 웹 서버에서 소프트웨어를 실행하는 아이디어를 얻었습니다.우리는 웹에서 작동하도록 소프트웨어를 다시 작성해 보았고 이것이 갈 길임이 분명했습니다.서버에서 실행되도록 소프트웨어를 작성한다면 사용자와 우리 모두에게 훨씬 쉬울 것입니다. 이는 좋은 계획으로 판명되었습니다.이제 Yahoo Store로서 이 소프트웨어는 약 14,000명의 사용자를 보유한 가장 인기 있는 온라인 상점 빌더입니다. 우리가 Viaweb을 시작했을 때 소프트웨어가 서버에서 실행된다고 말한 것이 무슨 뜻인지 이해하는 사람이 거의 없었습니다.사람들이 Hotmail을 받기 시작한 것은 1년 후 Hotmail이 출시된 이후였습니다.이제 이것이 유효한 접근 방식이라는 것을 모두가 알고 있습니다.이제 우리는 응용 프로그램 서비스 공급자(ASP)라는 이름을 갖게 되었습니다. 많은 차세대 소프트웨어가 이 모델을 기반으로 작성될 것이라고 생각합니다.잃을 것이 가장 많은 마이크로소프트조차도 데스크톱에서 일부 항목을 옮기는 것이 불가피하다고 생각하는 것 같습니다.소프트웨어가 데스크톱에서 서버로 이동한다면 이는 개발자에게 매우 다른 세상을 의미할 것입니다.이 기사에서는 이 새로운 세계를 처음 방문한 사람들로서 우리가 본 놀라운 일들을 설명합니다.소프트웨어가 서버로 옮겨가는 만큼, 제가 여기서 설명하는 것은 미래입니다. 다음은? 데스크탑 소프트웨어 시대를 되돌아보면 초기 자동차 소유자들이 지금까지 참았던 불편함과 마찬가지로 사람들이 참았던 불편함에도 경탄하게 될 것입니다.처음 20년, 30년 동안은 자동차를 소유하려면 자동차 전문가가 되어야 했습니다.그러나 자동차는 너무나 큰 성공을 거두었기 때문에 자동차 전문가가 아닌 많은 사람들도 자동차를 갖고 싶어했습니다. 컴퓨터는 현재 이 단계에 있습니다.데스크톱 컴퓨터를 소유하게 되면 그 컴퓨터 내부에서 일어나는 일에 대해 알고 싶었던 것보다 훨씬 더 많은 것을 배우게 됩니다.그러나 미국 가구의 절반 이상이 집을 소유하고 있습니다.우리 어머니는 이메일과 계정 보관을 위해 컴퓨터를 사용하고 계십니다.약 1년 전 그녀는 Apple로부터 새 버전의 운영 체제에 대한 할인을 제안하는 편지를 받고 깜짝 놀랐습니다.이메일과 계정을 위해 컴퓨터를 사용하려는 65세 여성이 새로운 운영 체제 설치에 대해 생각해야 한다면 뭔가 잘못된 것입니다.일반 사용자는 "운영 체제"라는 단어는커녕 "장치 드라이버"나 "패치"라는 단어도 몰라야 합니다. 이제 사용자가 시스템 관리자가 되지 않도록 소프트웨어를 제공하는 또 다른 방법이 있습니다.웹 기반 응용 프로그램은 웹 서버에서 실행되고 웹 페이지를 사용자 인터페이스로 사용하는 프로그램입니다.일반 사용자의 경우 이 새로운 종류의 소프트웨어는 데스크톱 소프트웨어보다 더 쉽고, 저렴하고, 더 이동성이 뛰어나고, 더 안정적이며, 종종 더 강력할 것입니다. 웹 기반 소프트웨어를 사용하면 대부분의 사용자는 자신이 사용하는 응용 프로그램 외에는 아무것도 생각할 필요가 없습니다.지저분하고 변화하는 모든 것들은 서버 어딘가에 있을 것이고, 그런 일에 능숙한 사람들이 관리할 것입니다.따라서 일반적으로 소프트웨어를 사용하기 위해 컴퓨터 자체가 필요하지 않습니다.키보드, 화면, 웹 브라우저만 있으면 됩니다.어쩌면 무선 인터넷 접속이 가능할 수도 있습니다.어쩌면 그것은 당신의 휴대폰일 수도 있습니다.그것이 무엇이든 그것은 소비자 가전이 될 것입니다. 가격은 약 200달러이고 사람들이 선택하는 것입니다.

주로 케이스가 어떻게 보이는지에 따라 결정됩니다.지금 전화와 마찬가지로 하드웨어 비용보다 인터넷 서비스 비용을 더 많이 지불하게 됩니다.[1]클릭 한 번으로 서버에 접속했다가 돌아오는 데 약 10분의 1초가 걸리므로 Photoshop과 같은 대화형 소프트웨어 사용자는 여전히 데스크탑에서 계산이 진행되기를 원할 것입니다.그러나 대부분의 사람들이 컴퓨터를 사용하는 용도를 살펴보면 10분의 1초의 지연 시간은 문제가 되지 않습니다.우리 엄마는 데스크톱 컴퓨터가 꼭 필요하지도 않고, 그런 사람이 많아요. 사용자를 위한 승리 우리 집 근처에 '불편하기 전에 죽음을'이라고 적힌 범퍼 스티커가 붙어 있는 자동차가 있습니다.대부분의 사람들은 최소한의 노력이 필요한 선택이라면 무엇이든 선택합니다.웹 기반 소프트웨어가 승리한다면 그것은 더 편리하기 때문일 것입니다.그리고 이는 사용자와 개발자 모두에게 그렇게 될 것으로 보입니다. 순수 웹 기반 애플리케이션을 사용하려면 인터넷에 연결된 브라우저만 있으면 됩니다.따라서 어디서나 웹 기반 애플리케이션을 사용할 수 있습니다.데스크톱 컴퓨터에 소프트웨어를 설치하면 해당 컴퓨터에서만 사용할 수 있습니다.더 나쁜 것은 파일이 해당 컴퓨터에 갇혀 있다는 것입니다.이 모델의 불편함은 사람들이 네트워크에 익숙해질수록 점점 더 분명해집니다. 여기서 가장 얇은 부분은 웹 기반 이메일이었습니다.이제 수백만 명의 사람들이 어디에 있든 이메일 메시지에 액세스할 수 있어야 한다는 사실을 깨닫고 있습니다.이메일을 볼 수 있다면 캘린더는 어떨까요?동료들과 문서에 대해 토론할 수 있는데 편집할 수 없는 이유는 무엇입니까?왜 당신의 데이터가 멀리 떨어진 책상에 앉아 있는 컴퓨터에 갇혀 있어야 합니까? "당신의 컴퓨터"라는 개념은 사라지고 "당신의 데이터"로 대체되고 있습니다.어떤 컴퓨터에서든 데이터를 얻을 수 있어야 합니다.또는 오히려 모든 클라이언트와 클라이언트가 컴퓨터일 필요는 없습니다. 클라이언트는 데이터를 저장해서는 안 됩니다.전화기와 같아야합니다.실제로 전화기가 될 수도 있고 그 반대가 될 수도 있습니다.그리고 클라이언트가 작아질수록 데이터를 보관하지 말아야 할 또 다른 이유가 있습니다. 가지고 다니는 물건이 분실되거나 도난당할 수 있기 때문입니다.PDA를 택시에 놔두는 것은 데이터가 증발하는 대신 다른 사람에게 전달된다는 점을 제외하면 디스크 충돌과 같습니다. 순수 웹 기반 소프트웨어를 사용하면 데이터나 응용 프로그램이 클라이언트에 보관되지 않습니다.따라서 사용하기 위해 아무것도 설치할 필요가 없습니다.그리고 설치가 없을 때 설치가 잘못될까봐 걱정할 필요가 없습니다.소프트웨어가 운영 체제에서 실행되지 않기 때문에 응용 프로그램과 운영 체제 간에 비호환성이 있을 수 없습니다. 설치가 필요 없기 때문에 웹 기반 소프트웨어를 "구매"하기 전에 사용해 보는 것이 쉽고 일반적입니다.제공되는 사이트에 방문하기만 하면 모든 웹 기반 응용 프로그램을 무료로 시험해 볼 수 있을 것으로 기대해야 합니다.Viaweb에서 우리 사이트 전체는 사용자에게 테스트 드라이브를 가리키는 큰 화살표와 같았습니다. 데모를 시도한 후 서비스에 가입하려면 간단한 양식을 작성하는 것 외에는 아무것도 필요하지 않습니다(간단할수록 좋습니다).그리고 그것이 사용자가 해야 할 마지막 작업이어야 합니다.웹 기반 소프트웨어를 사용하면 추가 비용을 지불하거나 작업을 수행하지 않고도 새 릴리스를 얻을 수 있으며 심지어 그것에 대해 알지도 못합니다. 업그레이드는 지금처럼 큰 충격은 아닐 것입니다.시간이 지남에 따라 애플리케이션은 조용히 더욱 강력해질 것입니다.이를 위해서는 개발자의 노력이 필요합니다.사용자에게 혼란을 주지 않고 업데이트할 수 있도록 소프트웨어를 설계해야 합니다.이는 새로운 문제이지만 이를 해결할 수 있는 방법이 있습니다. 웹 기반 애플리케이션을 사용하면 모든 사람이 동일한 버전을 사용하므로 버그가 발견되는 즉시 수정할 수 있습니다.따라서 웹 기반 소프트웨어는 데스크톱 소프트웨어보다 버그가 훨씬 적습니다.Viaweb에서는 한 번에 10개의 알려진 버그가 있었던 적이 있는지 의심스럽습니다.이는 데스크톱 소프트웨어보다 훨씬 더 좋습니다. 웹 기반 응용 프로그램은 여러 사람이 동시에 사용할 수 있습니다.이는 공동 작업 응용 프로그램에서는 확실한 승리이지만 사용자는 대부분의 응용 프로그램에서 이것을 원하게 될 것입니다.

그들이 그것이 가능하다는 것을 깨닫고 나면.예를 들어, 두 사람이 동일한 문서를 편집하게 하면 종종 유용할 것입니다.Viaweb을 사용하면 여러 사용자가 동시에 사이트를 편집할 수 있습니다. 이는 사용자가 원할 것이라고 예상한 것보다 소프트웨어를 작성하는 올바른 방법이었기 때문입니다. 그러나 많은 사용자가 그렇게 한 것으로 나타났습니다. 웹 기반 응용 프로그램을 사용하면 데이터가 더 안전해집니다.디스크 충돌은 과거의 일이 아니지만 사용자는 더 이상 이에 대해 듣지 못할 것입니다.이는 서버 팜 내에서 발생합니다.그리고 웹 기반 응용 프로그램을 제공하는 회사는 실제로 백업을 수행합니다. 실제 시스템 관리자가 이러한 문제에 대해 걱정할 뿐만 아니라 사람들의 데이터를 손실하는 ASP가 크고 큰 문제에 처하게 될 것이기 때문입니다.사람들이 디스크 충돌로 인해 자신의 데이터를 잃어버렸을 때 그렇게 화를 낼 수는 없습니다. 화를 내야 할 대상은 자기 자신뿐이기 때문입니다.회사가 데이터를 잃으면 훨씬 더 화를 낼 것입니다. 마지막으로 웹 기반 소프트웨어는 바이러스에 덜 취약해야 합니다.클라이언트가 브라우저 외에는 아무 것도 실행하지 않으면 바이러스가 실행될 가능성이 줄어들고 로컬에서 손상될 데이터도 없습니다.그리고 서버 자체를 공격하는 프로그램은 서버가 매우 잘 방어된다는 것을 알게 될 것입니다.[2]사용자에게는 웹 기반 소프트웨어가 스트레스를 덜 줍니다.제 생각에는 일반 Windows 사용자의 내부를 살펴보면 이러한 설명을 충족하는 소프트웨어에 대한 거대하고 거의 아직 개발되지 않은 욕구를 발견할 수 있을 것입니다.해방되면 강력한 힘이 될 수 있습니다. 코드의 도시 개발자에게 있어 웹 기반 소프트웨어와 데스크톱 소프트웨어 사이의 가장 눈에 띄는 차이점은 웹 기반 애플리케이션이 단일 코드 조각이 아니라는 것입니다.이는 하나의 큰 바이너리가 아닌 다양한 유형의 프로그램 모음이 될 것입니다.따라서 웹 기반 소프트웨어를 설계하는 것은 건물보다는 도시를 디자인하는 것과 같습니다. 건물뿐만 아니라 도로, 거리 표지판, 유틸리티, 경찰 및 소방서, 성장과 다양한 종류의 재난에 대한 계획이 모두 필요합니다. Viaweb의 소프트웨어에는 사용자가 직접 대화하는 상당히 큰 애플리케이션, 해당 프로그램이 사용하는 프로그램, 문제를 찾기 위해 백그라운드에서 지속적으로 실행되는 프로그램, 문제가 발생한 경우 다시 시작하려고 시도하는 프로그램, 통계를 컴파일하거나 검색용 색인을 작성하기 위해 가끔 실행되는 프로그램, 명시적으로 실행하는 프로그램이 포함되었습니다.리소스를 가비지 수집하거나 데이터를 이동하거나 복원하기 위한 프로그램, 사용자인 것처럼 가장하는 프로그램(성능 측정 또는 버그 노출), 네트워크 문제 진단 프로그램, 백업 수행을 위한 프로그램, 외부 서비스에 대한 인터페이스, 실시간 서버 통계를 표시하는 인상적인 다이얼 모음을 구동하는 소프트웨어(방문자에게 인기가 있지만 우리에게도 필수 불가결함), 오픈 소스 소프트웨어에 대한 수정(버그 수정 포함), 수많은 구성 파일 및 설정.Trevor Blackwell은 우리가 Yahoo에 인수된 후 매장을 폐쇄하지 않고 전국의 새로운 서버로 이전하기 위한 훌륭한 프로그램을 작성했습니다.프로그램은 우리를 호출하고, 사용자에게 팩스와 이메일을 보내고, 신용 카드 프로세서와 거래를 수행하고, 소켓, 파이프, http 요청, ssh, udp 패킷, 공유 메모리 및 파일을 통해 서로 통신했습니다.Viaweb 중 일부는 심지어 프로그램이 없는 것으로 구성되기도 했습니다. 왜냐하면 Unix 보안의 핵심 중 하나는 사람들이 서버에 침입하기 위해 사용할 수 있는 불필요한 유틸리티를 실행하지 않는 것이기 때문입니다. 그것은 소프트웨어로 끝나지 않았습니다.우리는 서버 구성에 대해 생각하는 데 많은 시간을 보냈습니다.우리는 부분적으로는 비용을 절약하고 부분적으로는 우리가 원하는 것을 정확히 얻기 ​​위해 구성 요소를 사용하여 서버를 직접 구축했습니다.우리는 업스트림 ISP가 모든 백본에 대해 충분히 빠른 연결을 갖고 있는지 생각해야 했습니다.우리는 RAID 공급업체와 연속적으로 데이트를 했습니다. 그러나 하드웨어만 걱정할 것은 아닙니다.이를 제어하면 사용자를 위해 더 많은 일을 할 수 있습니다.데스크톱 응용 프로그램을 사용하면 특정 최소 하드웨어를 지정할 수 있지만 더 추가할 수는 없습니다.서버를 관리하는 경우 모든 사용자가 사람을 호출하거나, 팩스를 보내거나, 전화로 명령을 보내거나, 신용 카드 처리 등을 한 번에 수행할 수 있습니다.

먼저 관련 하드웨어를 설치합니다.우리는 항상 하드웨어에 기능을 추가하는 새로운 방법을 모색했습니다. 사용자를 만족시키기 위해서일 뿐만 아니라 하드웨어를 직접 제어할 수 없는(데스크탑 소프트웨어를 판매했거나 ISP를 통해 웹 기반 응용 프로그램을 재판매했기 때문에) 경쟁업체와 우리를 구별하기 위한 방법이었습니다. 웹 기반 응용 프로그램의 소프트웨어는 단일 바이너리가 아닌 프로그램 모음이기 때문에 다양한 언어로 작성될 수 있습니다.데스크톱 소프트웨어를 작성할 때 실제로는 기본 운영 체제와 동일한 언어, 즉 C 및 C++로 애플리케이션을 작성해야 합니다.그래서 이러한 언어(특히 관리자나 VC와 같은 비기술적인 사람들 사이에서)는 "진지한" 소프트웨어 개발을 위한 언어로 간주되었습니다.그러나 그것은 데스크톱 소프트웨어가 제공되어야 하는 방식의 인공물일 뿐이었습니다.서버 기반 소프트웨어의 경우 원하는 언어를 사용할 수 있습니다.[3] 오늘날 최고의 해커 중 다수는 C 및 C++와는 거리가 먼 Perl, Python, Lisp 등의 언어를 사용하고 있습니다. 서버 기반 소프트웨어에서는 하드웨어에 이르기까지 전체 시스템을 제어하기 때문에 어느 누구도 어떤 언어를 사용해야 할지 알 수 없습니다.다양한 언어는 다양한 작업에 적합합니다.각각에 가장 적합한 것을 사용할 수 있습니다.경쟁업체가 있는 경우 "할 수 있다"는 것은 "해야 한다"는 의미입니다(나중에 이에 대해 다시 설명하겠습니다). 왜냐하면 이 가능성을 활용하지 않으면 경쟁업체가 그렇게 할 것이기 때문입니다. 대부분의 경쟁업체는 C와 C++를 사용했는데 이로 인해 그들의 소프트웨어가 눈에 띄게 열등해졌습니다. 왜냐하면 (무엇보다도) CGI 스크립트의 상태 비성을 피할 수 있는 방법이 없었기 때문입니다.무언가를 변경하려면 하단에 업데이트 버튼이 있는 한 페이지에서 모든 변경 사항이 이루어져야 했습니다.내가 다른 곳에서 쓴 것처럼, 많은 사람들이 여전히 연구 언어로 간주하는 Lisp를 사용함으로써 우리는 Viaweb 편집기를 데스크톱 소프트웨어처럼 작동하도록 만들 수 있습니다. 릴리스 이 새로운 세계에서 가장 중요한 변화 중 하나는 릴리스를 수행하는 방식입니다.데스크톱 소프트웨어 사업에서 릴리스를 한다는 것은 회사 전체가 하나의 거대한 코드 조각을 밀어내기 위해 땀을 흘리고 애쓰는 큰 트라우마입니다.프로세스와 결과 제품 모두에 대한 분명한 비교가 필요합니다. 서버 기반 소프트웨어를 사용하면 직접 작성한 프로그램에서와 마찬가지로 변경 작업을 수행할 수 있습니다.가끔 큰 폭으로 폭발하는 대신 일련의 점진적인 변경으로 소프트웨어를 출시합니다.일반적인 데스크톱 소프트웨어 회사는 1년에 한두 번 릴리스를 수행합니다.Viaweb에서는 하루에 3~5개의 릴리스를 자주 수행했습니다. 이 새로운 모델로 전환하면 소프트웨어 개발이 릴리스 방식에 의해 얼마나 많은 영향을 받는지 깨닫게 됩니다.데스크톱 소프트웨어 비즈니스에서 볼 수 있는 가장 심각한 문제 중 상당수는 릴리스의 재앙적인 성격으로 인해 발생합니다. 1년에 단 하나의 새 버전만 릴리스하면 버그를 대거 처리하는 경향이 있습니다.출시 날짜가 있기 얼마 전에 코드의 절반이 제거되고 교체되어 수많은 버그가 발생하는 새 버전을 조립합니다.그런 다음 QA 팀이 개입하여 개수를 세기 시작하고 프로그래머는 목록을 작성하여 수정합니다.그들은 일반적으로 목록의 끝에 도달하지 않으며 실제로 끝이 어디인지 확신하는 사람은 아무도 없습니다.그것은 연못에서 나오는 낚시 잔해와 같습니다.소프트웨어 내부에서 무슨 일이 일어나고 있는지 전혀 알 수 없습니다.기껏해야 통계적인 정확성으로 끝날 것입니다. 서버 기반 소프트웨어를 사용하면 대부분의 변경 사항은 작고 점진적입니다.그 자체로는 버그가 발생할 가능성이 적습니다.이는 또한 소프트웨어를 출시할 때 가장 신중하게 테스트해야 할 사항, 즉 마지막으로 변경한 사항을 알고 있음을 의미합니다.코드를 훨씬 더 확실하게 잡을 수 있게 됩니다.일반적으로 내부에서 무슨 일이 일어나고 있는지 알고 있습니다.물론 소스 코드를 기억할 수는 없지만 소스를 읽을 때 미스터리를 풀려는 형사가 아니라 계기판을 스캔하는 조종사처럼 수행합니다. 데스크탑 소프트웨어는 버그에 대해 특정한 운명론을 낳습니다.

버그가 많은 제품을 출시하고 있다는 사실을 알고 있으며 이를 보상하기 위한 메커니즘(예: 패치 릴리스)도 설정했습니다.그렇다면 왜 몇 가지를 더 걱정합니까?곧 고장난 것으로 알고 있는 모든 기능을 출시할 예정입니다.애플은 올해 초 이런 일을 했다.그들은 출시 날짜가 이미 4번이나 늦어졌지만 일부 소프트웨어(CD 및 DVD 지원)가 준비되지 않은 새로운 OS를 출시해야 한다는 압박감을 느꼈습니다.해결책?미완성된 부분 없이 OS를 출시했고 사용자는 나중에 설치해야 합니다. 웹 기반 소프트웨어를 사용하면 작동하기 전에 소프트웨어를 출시할 필요가 없으며 작동하자마자 출시할 수 있습니다. 업계 베테랑은 소프트웨어가 작동하기 전에 출시할 필요가 없다고 말하는 것이 좋은 생각이라고 생각할 수도 있지만 특정 날짜까지 소프트웨어의 새 버전을 제공하겠다고 약속하면 어떻게 될까요?웹 기반 소프트웨어에는 버전이 없기 때문에 그러한 약속을 할 수 없습니다.소프트웨어는 점진적이고 지속적으로 변경됩니다.일부 변경 사항은 다른 변경 사항보다 클 수 있지만 버전 개념은 웹 기반 소프트웨어에 자연스럽게 맞지 않습니다. Viaweb을 기억하는 사람이 있다면 이상하게 들릴 수도 있습니다. 왜냐하면 우리는 항상 새 버전을 발표했기 때문입니다.이는 전적으로 홍보 목적으로 수행되었습니다.우리가 배운 무역 언론은 버전 번호로 생각합니다.이는 버전 번호의 새로운 첫 번째 숫자를 의미하는 주요 릴리스에 대한 주요 정보를 제공하며, 일반적으로 포인트 릴리스의 경우 최대 한 단락(소수점 이하의 새로운 숫자를 의미)을 제공합니다. 경쟁사 중 일부는 데스크톱 소프트웨어를 제공하고 실제로 버전 번호가 있었습니다.그리고 이러한 릴리스의 경우, 그 단순한 사실만으로도 그들의 후진성을 입증하는 것처럼 보였으며 모든 종류의 홍보를 받게 될 것입니다.우리는 놓치고 싶지 않았기 때문에 소프트웨어에도 버전 번호를 부여하기 시작했습니다.우리는 홍보를 원할 때 마지막 "릴리스" 이후 추가한 모든 기능의 목록을 작성하고 소프트웨어에 새 버전 번호를 붙인 다음 새 버전을 즉시 사용할 수 있다는 보도 자료를 발행했습니다.놀랍게도 아무도 우리에게 전화를 하지 않았습니다. 우리가 인수될 때까지 이 작업을 세 번 수행했기 때문에 버전 4를 사용하고 있었습니다. 제 기억이 맞다면 버전 4.1이었습니다.Viaweb이 Yahoo Store가 된 후에는 더 이상 홍보에 대한 절박한 필요성이 없었기 때문에 소프트웨어가 계속 발전했지만 버전 번호에 대한 전체 아이디어는 조용히 사라졌습니다. 버그웹 기반 소프트웨어의 또 다른 주요 기술적 이점은 대부분의 버그를 재현할 수 있다는 것입니다.디스크에 바로 사용자 데이터가 있습니다.누군가가 귀하의 소프트웨어를 망가뜨린 경우 데스크톱 소프트웨어에서처럼 무슨 일이 일어나고 있는지 추측할 필요가 없습니다. 상대방이 귀하와 통화하는 동안 오류를 재현할 수 있어야 합니다.응용 프로그램에 오류를 감지하는 코드가 내장되어 있다면 이미 알고 있을 수도 있습니다. 웹 기반 소프트웨어는 24시간 내내 사용되므로 수행하는 모든 작업은 즉시 처리됩니다.버그는 빠르게 나타납니다. 소프트웨어 회사는 때때로 사용자가 소프트웨어를 디버깅하도록 허용한다는 비난을 받습니다.그리고 그것이 바로 제가 옹호하는 것입니다.웹 기반 소프트웨어의 경우 버그가 적고 일시적이기 때문에 이는 실제로 좋은 계획입니다.소프트웨어를 점진적으로 출시하면 처음부터 버그가 훨씬 줄어듭니다.그리고 오류를 재현하고 변경 사항을 즉시 릴리스할 수 있으면 대부분의 버그가 나타나는 즉시 찾아서 수정할 수 있습니다.공식적인 버그 추적 시스템을 귀찮게 할 만큼 버그가 한 번도 충분하지 않았습니다. 물론 변경 사항을 릴리스하기 전에 테스트해야 하므로 주요 버그가 릴리스되어서는 안 됩니다.필연적으로 빠져나가는 소수의 경우 경계선 사례가 포함되며 누군가가 불만을 제기하기 전에 해당 문제를 만나는 소수의 사용자에게만 영향을 미칩니다.버그를 즉시 수정하는 한 일반 사용자의 최종 효과는 버그 수를 훨씬 줄여줍니다.일반 Viaweb 사용자가 버그를 본 적이 있는지 의심스럽습니다. 새로운 버그를 수정하는 것이 오래된 버그를 수정하는 것보다 쉽습니다.방금 작성한 코드에서 버그를 찾는 것은 일반적으로 상당히 빠릅니다.

썼다.그것이 밝혀지면 소스를 보기도 전에 무엇이 잘못되었는지 아는 경우가 많습니다. 왜냐하면 이미 무의식적으로 그것에 대해 걱정하고 있었기 때문입니다.6개월 전에 작성한 버그를 수정하려면(1년에 한 번 릴리스하는 경우 평균 사례) 훨씬 더 많은 작업이 필요합니다.그리고 코드도 이해하지 못하기 때문에 보기 흉한 방식으로 수정하거나 심지어 더 많은 버그가 발생할 가능성이 더 높습니다.[4]버그를 조기에 발견하면 복합 버그도 줄어듭니다.복합 벌레는 상호 작용하는 두 가지 별도의 벌레입니다. 아래층으로 내려가다가 난간에 손을 뻗으면 손에서 떨어집니다.소프트웨어에서 이런 종류의 버그는 찾기가 가장 어렵고 최악의 결과를 초래하는 경향이 있습니다.[5] 전통적인 "모든 것을 깨뜨린 다음 버그를 걸러내는" 접근 방식은 본질적으로 많은 복합 버그를 생성합니다.그리고 일련의 작은 변화를 통해 출시되는 소프트웨어는 본질적으로 그렇지 않은 경향이 있습니다.바닥은 나중에 뭔가에 걸릴 수 있는 느슨한 물체를 지속적으로 청소합니다. 함수형 프로그래밍이라는 기술을 사용하면 도움이 됩니다.함수형 프로그래밍은 부작용을 피하는 것을 의미합니다.이는 상업용 소프트웨어보다 연구 논문에서 더 많이 볼 수 있는 것이지만 웹 기반 애플리케이션의 경우에는 정말 유용한 것으로 나타났습니다.전체 프로그램을 순전히 기능적인 코드로 작성하는 것은 어렵지만 이 방법으로 상당한 부분을 작성할 수 있습니다.소프트웨어의 해당 부분에는 상태가 없기 때문에 테스트하기가 더 쉽고, 지속적으로 작은 수정을 하고 테스트하는 상황에서 매우 편리합니다.저는 Viaweb의 편집기 대부분을 이 스타일로 작성했으며 순전히 함수형 언어인 RTML 스크립팅 언어를 만들었습니다. 데스크톱 소프트웨어 비즈니스에 종사하는 사람들은 이를 인정하기 어려울 것이지만 Viaweb에서는 버그가 거의 게임이 되었습니다.대부분의 릴리스된 버그는 경계선 사례와 관련되어 있으므로 이를 접한 사용자는 한계를 뛰어넘는 고급 사용자일 가능성이 높습니다.고급 사용자는 버그에 대해 더 관대합니다. 특히 그들이 요청한 일부 기능을 추가하는 과정에서 버그를 도입했을 가능성이 높기 때문입니다.실제로 버그는 드물었고 이를 보려면 복잡한 작업을 수행해야 했기 때문에 고급 사용자는 버그를 발견한 것을 자랑스러워하는 경우가 많았습니다.그들은 마치 우리에게서 점수를 얻은 것처럼 분노보다는 승리의 정신으로 지원을 요청할 것입니다.지원오류를 재현할 수 있으면 고객 지원에 대한 접근 방식이 달라집니다.대부분의 소프트웨어 회사에서는 고객의 기분을 좋게 하기 위한 방법으로 지원을 제공합니다.그들은 알려진 버그에 대해 전화를 걸거나 뭔가 잘못하고 있는 것이므로 무엇을 알아내야 하는지 알아내야 합니다.두 경우 모두 그들로부터 배울 수 있는 것이 많지 않습니다.따라서 지원 요청을 가능한 한 개발자로부터 격리하고 싶은 골치 아픈 고통으로 보는 경향이 있습니다. 이는 Viaweb에서 일하는 방식이 아니었습니다.Viaweb에서는 고객의 의견을 듣고 싶었기 때문에 지원이 무료였습니다.누군가 문제가 발생하면 오류를 재현하고 수정 사항을 릴리스할 수 있도록 즉시 이에 대해 알고 싶었습니다. 그래서 Viaweb에서 개발자는 항상 지원팀과 긴밀한 접촉을 유지했습니다.고객 지원 담당자는 프로그래머로부터 약 30피트 떨어져 있었고 진짜 버그를 보고하면 언제든지 무엇이든 중단할 수 있다는 것을 알고 있었습니다.심각한 버그를 수정하려면 이사회를 떠나야 했습니다. 지원에 대한 우리의 접근 방식은 모두를 더 행복하게 만들었습니다.고객은 기뻐했습니다.지원 라인에 전화를 걸어 중요한 소식을 전하는 사람으로 대우받는 기분이 어떨지 상상해 보세요.고객 지원 담당자는 사용자에게 스크립트를 읽어주는 대신 사용자를 도울 수 있다는 의미로 이를 좋아했습니다.그리고 프로그래머들은 막연한 간접 보고를 듣는 대신 버그를 재현할 수 있다는 점을 좋아했습니다. 즉시 버그를 수정하는 우리의 정책은 고객 지원 담당자와 해커 간의 관계를 변화시켰습니다.대부분의 소프트웨어 회사에서 지원 담당자는 적은 보수를 받는 인간 방패이며, 해커는 세상의 창조주이신 아버지 하나님의 작은 복사본입니다.어떤 과정을 거쳐도

버그를 보고하는 것은 단방향일 가능성이 높습니다. 버그에 대해 들은 사람들이 어떤 양식을 작성하도록 지원하면 결국 (QA를 통해) 프로그래머에게 전달되고 프로그래머는 이를 작업 목록에 추가합니다.Viaweb에서는 매우 달랐습니다.고객으로부터 버그에 대한 소식을 듣고 1분 이내에 지원 담당자가 프로그래머 옆에 서서 "젠장, 네 말이 맞아, 버그야"라고 말하는 것을 들을 수 있습니다.해커들로부터 "당신 ​​말이 맞아요"라는 말을 듣고 지원팀 사람들은 기뻐했습니다.그들은 고양이가 방금 죽인 쥐를 데려오는 것과 같은 기대감으로 우리에게 벌레를 가져오곤 했습니다.또한 이제 그들의 명예가 위태로워지기 때문에 버그의 심각성을 판단하는 데 더욱 주의를 기울이게 되었습니다. 우리가 Yahoo에 인수된 후 고객 지원 담당자는 프로그래머로부터 멀어졌습니다.그때서야 우리는 그들이 효과적인 QA이자 어느 정도 마케팅이라는 것을 깨달았습니다.버그를 잡는 것 외에도 사용자를 혼란스럽게 하는 기능과 같은 모호하고 버그와 유사한 것에 대한 지식을 유지하는 역할도 했습니다.[6] 그들은 또한 일종의 대리 포커스 그룹이었습니다.두 가지 새로운 기능 중 사용자가 더 원하는 것이 무엇인지 물어볼 수 있었고 그들은 항상 옳았습니다. 사기소프트웨어를 즉시 출시할 수 있다는 것은 큰 동기 부여입니다.종종 직장으로 걸어가면서 소프트웨어에 적용하고 싶은 변경 사항이 생각나서 그날 변경했습니다.이는 더 큰 기능에도 적용되었습니다.뭔가를 작성하는 데 2주가 걸리더라도(몇몇 프로젝트는 더 오래 걸렸습니다), 작업이 완료되자마자 소프트웨어에서 효과를 볼 수 있다는 것을 알았습니다. 다음 릴리스까지 1년을 기다려야 했다면 적어도 잠시 동안은 이러한 아이디어의 대부분을 보류했을 것입니다.하지만 아이디어에 관한 문제는 더 많은 아이디어로 이어진다는 것입니다.당신이 뭔가를 쓰기 위해 자리에 앉았을 때, 그 안에 떠오르는 아이디어의 절반이 글을 쓰는 동안 생각한 아이디어라는 것을 알아차린 적이 있습니까?소프트웨어에서도 마찬가지입니다.하나의 아이디어를 구현하기 위해 노력하면 더 많은 아이디어를 얻을 수 있습니다.따라서 아이디어를 보류하면 구현이 지연될 뿐만 아니라 구현으로 인해 발생했던 모든 아이디어도 손실됩니다.사실, 아이디어를 보류하면 새로운 아이디어가 저해될 수도 있습니다. 새로운 기능을 생각하기 시작하면 선반이 눈에 띄고 "하지만 이미 다음 릴리스에 대해 하고 싶은 새로운 일이 많이 있습니다."라고 생각합니다. 대기업이 하는 일은 기능을 구현하는 대신 계획을 세우는 것입니다.Viaweb에서는 때때로 이 계정에 문제가 발생했습니다.투자자와 분석가들은 우리가 미래에 대해 무엇을 계획했는지 묻곤 했습니다.솔직한 대답은 '우리는 아무런 계획도 없었다'였습니다.우리는 개선하고 싶은 사항에 대한 일반적인 아이디어를 갖고 있었지만, 우리가 어떻게 개선했는지 알았다면 이미 이를 수행했을 것입니다.앞으로 6개월 동안 우리는 무엇을 할 예정이었나요?무엇이든 가장 큰 승리처럼 보였습니다.제가 감히 이런 대답을 할 수 있었는지는 모르겠지만, 그것은 진실이었습니다.계획은 선반 위에 있는 아이디어의 또 다른 말일 뿐입니다.좋은 아이디어가 생각나면 이를 구현했습니다. 많은 소프트웨어 회사와 마찬가지로 Viaweb에서도 대부분의 코드에는 확실한 소유자가 한 명 있었습니다.그러나 당신이 무언가를 소유했다면 그것은 실제로 그것을 소유한 것입니다. 소프트웨어 소유자 외에는 누구도 릴리스를 승인할 필요가 없었습니다(또는 심지어 그것에 대해 알 필요도 없었습니다).동료들에게 바보처럼 보일 것이라는 두려움 외에는 파손에 대한 보호 장치가 없었으며 그것만으로도 충분했습니다.나는 우리가 단지 코드 작성을 경솔하게 진행했다는 인상을 주었을 수도 있습니다.우리는 빠르게 진행했지만 해당 서버에 소프트웨어를 출시하기 전에 매우 신중하게 생각했습니다.그리고 천천히 움직이는 것보다 주의를 기울이는 것이 신뢰성에 더 중요합니다.그가 세심한 주의를 기울이기 때문에 해군 조종사는 밤에 일반 십대보다 더 안전하게 피칭 캐리어 갑판에 시속 140마일의 속도로 40,000파운드의 항공기를 착륙시킬 수 있습니다. 이러한 소프트웨어 작성 방법은 물론 양날의 검입니다.나쁜 아이디어를 가진 사람이 아닌 위원회에서 잡아내는 평범한 회사로 구성된 큰 회사보다 훌륭하고 신뢰할 수 있는 프로그래머로 구성된 소규모 팀에서 훨씬 더 잘 작동합니다.Brooks i

n Reverse다행히도 웹 기반 소프트웨어에는 더 적은 수의 프로그래머가 필요합니다.나는 한때 엔지니어링 분야에 종사하는 직원이 100명이 넘는 중간 규모의 데스크톱 소프트웨어 회사에서 근무한 적이 있습니다.이 중 제품 개발에 참여한 것은 13개에 불과했습니다.나머지는 모두 릴리스, 포트 등의 작업을 하고 있었습니다.웹 기반 소프트웨어의 경우 릴리스나 포트 등이 없기 때문에 최대 13명만 필요합니다. Viaweb은 단 3명이 작성했습니다.[7] 나는 항상 더 많은 사람을 고용해야 한다는 압박감을 느꼈습니다. 왜냐하면 우리는 인수를 원했기 때문이며, 프로그래머가 3명밖에 없는 회사의 경우 구매자가 높은 가격을 지불하는 데 어려움을 겪을 것이라는 것을 알고 있었습니다.(해결책: 우리는 더 많이 고용했지만 그들을 위해 새로운 프로젝트를 만들었습니다.) 더 적은 수의 프로그래머로 소프트웨어를 작성할 수 있으면 비용보다 더 많은 것을 절약할 수 있습니다.Fred Brooks가 The Mythical Man-Month에서 지적했듯이 프로젝트에 사람을 추가하면 속도가 느려지는 경향이 있습니다.개발자들 사이에 가능한 연결 수는 그룹 규모에 따라 기하급수적으로 증가합니다.그룹이 클수록 소프트웨어가 어떻게 함께 작동할지 협상하는 회의에 더 많은 시간을 할애하고 예상치 못한 상호 작용으로 인해 더 많은 버그를 얻게 됩니다.다행히도 이 프로세스는 역으로도 작동합니다. 즉, 그룹이 작아질수록 소프트웨어 개발은 ​​기하급수적으로 더 효율적이 됩니다.저는 Viaweb의 프로그래머들이 실제 회의를 가졌던 기억이 없습니다.우리는 점심 먹으러 걸어가는 동안 말할 수 있는 것보다 더 많은 말을 한 적이 결코 없었습니다. 여기에 단점이 있다면 모든 프로그래머는 어느 정도 시스템 관리자이기도 해야 한다는 것입니다.소프트웨어를 호스팅할 때 누군가는 서버를 감시해야 하며 실제로 이를 제대로 수행할 수 있는 유일한 사람은 소프트웨어를 작성한 사람입니다.Viaweb의 시스템에는 구성 요소가 너무 많고 자주 변경되어 소프트웨어와 인프라 사이에 명확한 경계가 없었습니다.그러한 경계를 임의로 선언하면 우리의 디자인 선택이 제한될 것입니다.그래서 우리는 언젠가("몇 달 안에") 모든 것이 안정되어 서버 걱정만 하는 사람을 고용할 수 있을 것이라고 끊임없이 바랐지만, 그런 일은 결코 일어나지 않았습니다. 여전히 적극적으로 제품을 개발하고 있는 한 다른 방법은 있을 수 없다고 생각합니다.웹 기반 소프트웨어는 결코 작성하고 체크인하고 집에 가져갈 수 있는 것이 아닙니다.현재 귀하의 서버에서 실행되는 실제적인 것입니다.나쁜 버그는 한 사용자의 프로세스를 중단시킬 수도 없습니다.그것은 그들 모두를 충돌시킬 수 있습니다.코드의 버그로 인해 디스크의 일부 데이터가 손상되면 이를 수정해야 합니다.등.우리는 서버를 매분마다(첫해 정도 이후) 감시할 필요는 없지만 최근에 변경한 사항을 계속 주시하고 싶어한다는 것을 알았습니다.늦은 밤에 코드를 릴리스한 후 집에 돌아가지 않습니다. 사용자 관찰 서버 기반 소프트웨어를 사용하면 코드와 더욱 긴밀하게 접촉할 수 있습니다.사용자와 더욱 긴밀하게 소통할 수도 있습니다.Intuit는 소매점에서 고객에게 자신을 소개하고 집까지 따라오라고 요청하는 것으로 유명합니다.누군가가 귀하의 소프트웨어를 처음으로 사용하는 것을 본 적이 있다면 그 사람이 어떤 놀라움을 느꼈을지 알 것입니다. 소프트웨어는 사용자가 생각하는 대로 작동해야 합니다.하지만 사용자가 직접 보기 전까지는 사용자가 어떤 생각을 할지 알 수 없습니다.그리고 서버 기반 소프트웨어는 이들의 행동에 대해 전례 없는 정보를 제공합니다.소규모의 인공 포커스 그룹에만 국한되지 않습니다.모든 사용자의 모든 클릭을 볼 수 있습니다.사용자의 개인 정보를 침해하고 싶지 않기 때문에 무엇을 볼 것인지 신중하게 고려해야 하지만 가장 일반적인 통계 샘플링도 매우 유용할 수 있습니다. 예를 들어 서버에 사용자가 있는 경우 벤치마크에 의존할 필요가 없습니다.벤치마크는 시뮬레이션된 사용자입니다.서버 기반 소프트웨어를 사용하면 실제 사용자를 관찰할 수 있습니다.무엇을 최적화할지 결정하려면 서버에 로그인하여 모든 CPU를 소비하는 것이 무엇인지 확인하세요.그리고 언제 최적화를 중단해야 하는지도 알고 있습니다. 결국 우리는 Viaweb 편집기를 메모리 바인딩 지점까지 갖게 되었습니다.

CPU에 국한되는 것이 아니라 사용자 데이터의 크기를 줄이기 위해 할 수 있는 일이 아무것도 없었기 때문에(물론 쉽지는 않지만) 거기서 멈추는 편이 낫다는 것을 알았습니다. 하드웨어에 대한 비용을 지불해야 하기 때문에 서버 기반 소프트웨어에서는 효율성이 중요합니다.서버당 지원할 수 있는 사용자 수는 자본 비용의 제수입니다. 따라서 소프트웨어를 매우 효율적으로 만들 수 있다면 경쟁사보다 낮은 가격에 판매하면서도 여전히 이익을 얻을 수 있습니다.Viaweb에서는 사용자당 자본 비용을 약 5달러로 줄였습니다.지금은 아마도 첫 달 청구서를 보내는 비용보다 적을 것입니다.소프트웨어가 합리적으로 효율적이라면 하드웨어는 이제 무료입니다. 사용자를 관찰하면 디자인과 최적화에 대한 안내를 받을 수 있습니다.Viaweb에는 고급 사용자가 자신의 페이지 스타일을 정의할 수 있는 RTML이라는 스크립팅 언어가 있었습니다.우리는 RTML이 일종의 제안 상자가 되었다는 사실을 발견했습니다. 왜냐하면 사용자는 사전 정의된 페이지 스타일이 원하는 것을 수행할 수 없을 때만 RTML을 사용했기 때문입니다.예를 들어 원래 편집자는 페이지 전체에 버튼 막대를 배치했지만 많은 사용자가 RTML을 사용하여 버튼을 왼쪽에 배치한 후 사전 정의된 페이지 스타일에 해당 옵션(사실 기본값)을 만들었습니다. 마지막으로 사용자를 관찰하면 사용자가 문제에 처한 시기를 알 수 있는 경우가 많습니다.그리고 고객은 항상 옳기 때문에 이는 문제를 해결해야 한다는 신호입니다.Viaweb에서 사용자 확보의 핵심은 온라인 테스트 드라이브였습니다.그것은 마케팅 담당자들이 만든 일련의 슬라이드가 아니었습니다.테스트 드라이브에서 사용자는 실제로 소프트웨어를 사용했습니다.약 5분 정도 소요되었으며, 마지막에는 실제로 작동하는 매장을 구축했습니다.테스트 드라이브는 거의 모든 신규 사용자를 확보하는 방법이었습니다.대부분의 웹 기반 애플리케이션에서도 마찬가지일 것이라고 생각합니다.사용자가 테스트 드라이브를 성공적으로 마치면 제품이 마음에 들 것입니다.혼란스럽거나 지루해지면 그렇게 하지 않을 것입니다.따라서 더 많은 사람들이 테스트 드라이브를 하게 하기 위해 우리가 할 수 있는 모든 일은 성장률을 높일 것입니다. 나는 테스트 드라이브를 하는 사람들의 클릭 흔적을 연구한 결과 특정 단계에서 그들이 혼란스러워서 브라우저의 뒤로 버튼을 클릭한다는 것을 발견했습니다.(웹 기반 애플리케이션을 작성하려고 하면 뒤로 버튼이 가장 흥미로운 철학적 문제 중 하나가 된다는 것을 알게 될 것입니다.) 그래서 저는 그 지점에 사용자에게 거의 완료되었음을 알리고 뒤로 버튼을 클릭하지 말라고 상기시키는 메시지를 추가했습니다.웹 기반 소프트웨어의 또 다른 장점은 변경 사항에 대한 즉각적인 피드백을 받을 수 있다는 것입니다. 테스트 드라이브를 완료하는 사람의 수가 즉시 60%에서 90%로 증가했습니다.그리고 신규 사용자 수가 완료된 테스트 드라이브 수에 비례했기 때문에 이러한 변화만으로도 매출 성장이 50% 증가했습니다. 돈 1990년대 초에 저는 소프트웨어가 구독 사업이라고 말하는 누군가의 기사를 읽었습니다.처음에는 이 말이 매우 냉소적인 말처럼 보였습니다.그러나 나중에 나는 그것이 현실을 반영한다는 것을 깨달았습니다. 소프트웨어 개발은 ​​지속적인 과정입니다.사람들이 계속해서 비용을 지불하도록 새 버전을 구입하고 설치하도록 강요하는 것보다 공개적으로 구독료를 청구하는 것이 더 깨끗하다고 ​​생각합니다.다행스럽게도 구독은 웹 기반 응용 프로그램에 대한 비용을 청구하는 자연스러운 방법입니다. 호스팅 응용 프로그램은 기업이 프리웨어로 채워질 가능성이 없는 역할을 수행하게 되는 영역입니다.호스팅 애플리케이션은 스트레스가 많고 실제 비용도 많이 듭니다.누구도 무료로 하고 싶어하지 않을 것입니다. 기업에게 웹 기반 애플리케이션은 이상적인 수익원입니다.각 분기를 빈 상태로 시작하는 대신 반복되는 수익 흐름을 갖게 됩니다.소프트웨어가 점진적으로 발전하기 때문에 새 모델이 실패할 것이라고 걱정할 필요가 없습니다.그 자체로는 새로운 모델이 필요하지 않으며, 사용자가 싫어하는 소프트웨어에 뭔가를 하면 즉시 알게 될 것입니다.회수할 수 없는 청구서로 인해 문제가 발생하지 않습니다.누군가 돈을 지불하지 않으면 서비스를 끄면 됩니다.그리고 불법 복제의 가능성은 없습니다. 마지막 "이점"이 문제가 될 수 있습니다.어느 정도의 불법 복제는 소프트웨어에 유리합니다.

기업.어떤 사용자가 정말로 당신의 소프트웨어를 어떤 가격에도 구매하지 않았을 경우, 그가 불법 복제품을 사용해도 당신은 아무 것도 잃지 않을 것입니다.실제로 그는 귀하의 소프트웨어를 표준으로 만드는 데 도움을 주는 또 다른 사용자이거나 나중에 고등학교를 졸업할 때 사본을 구입할 수 있는 사용자이기 때문에 귀하는 이득을 얻습니다. 가능하다면 기업은 가격 차별이라는 일을 하고 싶어합니다. 이는 각 고객에게 감당할 수 있는 만큼 비용을 청구하는 것을 의미합니다.[8] 소프트웨어는 한계 비용이 0에 가깝기 때문에 가격 차별에 특히 적합합니다.이것이 일부 소프트웨어를 Intel 제품보다 Sun에서 실행하는 데 더 많은 비용이 드는 이유입니다. Sun을 사용하는 회사는 비용 절감에 관심이 없으며 더 많은 비용을 안전하게 청구할 수 있습니다.불법 복제는 사실상 가격 차별의 가장 낮은 수준입니다.나는 소프트웨어 회사들이 이것을 이해하고 일부 불법 복제에 대해 의도적으로 눈을 감는다고 생각합니다.[9] 서버 기반 소프트웨어를 사용하려면 다른 솔루션을 생각해 내야 합니다. 웹 기반 소프트웨어는 구입하기 쉽기 때문에 특히 데스크톱 소프트웨어에 비해 잘 팔립니다.사람들이 무언가를 구매하기로 결정한 다음 두 단계로 구매한다고 생각할 수도 있습니다.제가 비아웹 이전에도 그런 생각을 했고, 그 질문에 대해 전혀 생각을 안 했을 정도였습니다.실제로 두 번째 단계는 첫 번째 단계로 다시 전파될 수 있습니다. 구매하기 어려운 물건이 있으면 사람들은 그것을 원하는지에 대한 마음을 바꿀 것입니다.그리고 그 반대도 마찬가지입니다. 구매하기 쉬운 물건을 더 많이 팔게 됩니다.아마존이 존재하기 때문에 책을 더 많이 구입합니다.웹 기반 소프트웨어는 세상에서 가장 구입하기 쉬운 제품입니다. 특히 온라인 데모를 방금 마친 경우에는 더욱 그렇습니다.사용자는 신용카드 번호를 입력하는 것 이상의 작업을 수행할 필요가 없습니다.(위험을 무릅쓰고 더 많은 일을 하도록 하십시오.) 때때로 웹 기반 소프트웨어는 리셀러 역할을 하는 ISP를 통해 제공됩니다.이것은 나쁜 생각입니다.하드웨어와 소프트웨어 모두 지속적으로 개선해야 하기 때문에 서버를 관리해야 합니다.서버에 대한 직접적인 제어를 포기하면 웹 기반 응용 프로그램 개발의 장점 대부분을 포기하게 됩니다. 우리 경쟁사 중 몇몇은 이런 식으로 스스로를 공격했습니다. 제 생각에는 대개 이 엄청난 잠재 채널에 대해 열광하고 그것이 자신들이 판매하고자 하는 제품을 망치게 될 것이라는 사실을 깨닫지 못한 양복에 휩싸였기 때문인 것 같습니다.ISP를 통해 웹 기반 소프트웨어를 판매하는 것은 자동판매기를 통해 초밥을 판매하는 것과 같습니다. 고객고객은 누구일까요?Viaweb에서는 처음에는 개인과 소규모 회사였으며 이것이 웹 기반 애플리케이션의 규칙이 될 것이라고 생각합니다.이들은 새로운 것을 시도할 준비가 되어 있는 사용자입니다. 부분적으로는 더 유연하고 부분적으로는 새로운 기술의 저렴한 비용을 원하기 때문입니다. 웹 기반 응용 프로그램은 종종 대기업에게도 가장 좋은 방법이 될 것입니다(그러나 깨닫는 데는 시간이 걸릴 수 있습니다).최고의 인트라넷은 인터넷이다.회사가 진정한 웹 기반 애플리케이션을 사용한다면 소프트웨어는 더 잘 작동하고, 서버는 더 잘 관리될 것이며, 직원들은 어디에서나 시스템에 액세스할 수 있을 것입니다. 이 접근 방식에 대한 반대 주장은 일반적으로 보안에 달려 있습니다. 직원의 액세스가 더 쉽다면 악당도 마찬가지일 것입니다.일부 대형 판매자는 고객의 신용 카드 정보가 자체 서버에 있는 것이 더 안전할 것이라고 생각했기 때문에 Viaweb 사용을 꺼렸습니다.이 점을 외교적으로 표현하는 것은 쉽지 않았지만 사실 데이터는 그들 손보다 우리 손에 있는 것이 거의 확실히 더 안전했습니다.보안을 관리하기 위해 더 나은 인력을 고용할 수 있는 사람, 전체 비즈니스가 서버를 운영하는 기술 스타트업, 아니면 의류 소매업체일 수 있습니까?보안에 대해 걱정하는 더 나은 사람들이 있었을 뿐만 아니라 우리는 보안에 대해 더 많은 걱정을 했습니다.누군가 의류 소매업체의 서버에 침입하면 최대 한 명의 상인에게 영향을 미칠 수 있고, 침묵을 지킬 수도 있으며, 최악의 경우 한 사람이 해고될 수도 있습니다.누군가가 우리 회사에 침입하면 수천 명의 판매자에게 영향을 미칠 수 있고 결국 CNet에 뉴스가 되어 우리 회사가 폐업할 수도 있습니다. 돈을 안전하게 지키고 싶다면

, 집에 있는 매트리스 밑에 보관하시나요, 아니면 은행에 넣어두시나요?이 주장은 보안뿐만 아니라 가동 시간, 대역폭, 로드 관리, 백업 등 서버 관리의 모든 측면에 적용됩니다. 우리의 존재는 이러한 일을 올바르게 수행하는 데 달려 있습니다.위험한 장난감은 장난감 제조업체에 해당하고, 살모넬라균은 식품 가공업체에 발생하는 것처럼 서버 문제는 우리에게 큰 문제가 아니었습니다. 웹 기반 애플리케이션을 사용하는 대기업은 그만큼 IT를 아웃소싱하는 것입니다.극단적으로 들리겠지만, 나는 이것이 일반적으로 좋은 생각이라고 생각합니다.회사는 사내 시스템 관리자보다 이러한 방식으로 더 나은 서비스를 받을 가능성이 높습니다.시스템 관리자는 경쟁 압력에 직접적으로 노출되지 않기 때문에 까다롭고 반응이 없을 수 있습니다. 영업 사원은 고객을 상대해야 하고 개발자는 경쟁사의 소프트웨어를 처리해야 하지만 시스템 관리자는 노총각과 마찬가지로 그를 따라잡을 외부 힘이 거의 없습니다.[10] Viaweb에서는 우리를 계속해서 유지할 수 있는 외부 세력이 많았습니다.우리에게 전화한 사람들은 단순한 동료가 아니라 고객이었습니다.서버가 막히면 우리는 뛰어내렸습니다.그것에 대해 생각하는 것만으로도 몇 년이 지나면 아드레날린이 치솟을 것입니다. 따라서 웹 기반 애플리케이션은 일반적으로 대기업에게도 올바른 대답이 될 것입니다.그러나 그들은 데스크탑 컴퓨터에서와 마찬가지로 그것을 가장 늦게 깨닫게 될 것입니다.그리고 부분적으로는 같은 이유에서입니다. 대기업에게 더 비싼 제품이 필요하다고 설득하는 것은 많은 돈의 가치가 있을 것입니다. 부유한 고객은 값싼 솔루션이 더 나을 때에도 항상 값비싼 솔루션을 구입하는 경향이 있습니다. 왜냐하면 값비싼 솔루션을 제공하는 사람들은 이를 판매하기 위해 더 많은 비용을 지출할 수 있기 때문입니다.Viaweb에서 우리는 항상 이에 반대했습니다.우리는 자체 서버에 있는 맞춤형 온라인 상점을 위해 50만 달러를 지불하는 것이 더 나을 것이라고 확신하는 웹 컨설팅 회사에 몇몇 고급 판매자를 잃었습니다.일반적으로 그들은 크리스마스 쇼핑 시즌이 다가오고 서버의 부하가 증가했을 때 한 명 이상이 발견한 것처럼 더 나아지지 않았습니다.Viaweb은 대부분의 상인들이 갖고 있는 것보다 훨씬 더 정교했지만 우리는 그들에게 말할 여유가 없었습니다.한 달에 300달러를 지불하면 옷을 잘 차려입고 권위 있어 보이는 사람들로 구성된 팀을 고객에게 프레젠테이션을 제공할 여유가 없습니다. 대기업이 추가로 지불하는 비용의 상당 부분은 값비싼 제품을 판매하는 데 드는 비용입니다.(국방부가 변기 시트에 1,000달러를 지불한다면 부분적으로는 1,000달러에 변기 시트를 판매하는 데 많은 비용이 들기 때문입니다.) 이것이 비록 나쁜 생각일지라도 인트라넷 소프트웨어가 계속해서 번창할 수 있는 이유 중 하나입니다.단순히 더 비쌉니다.이 난제에 대해 귀하가 할 수 있는 일은 없으므로 가장 좋은 계획은 소규모 고객을 먼저 찾는 것입니다.나머지는 제 시간에 나올 것입니다. Server의 아들서버에서 소프트웨어를 실행하는 것은 새로운 것이 아닙니다.사실 이는 이전 모델입니다. 메인프레임 애플리케이션은 모두 서버 기반입니다.서버 기반 소프트웨어가 이렇게 좋은 아이디어라면 지난번에는 왜 졌을까요?데스크탑 컴퓨터가 메인프레임을 능가한 이유는 무엇입니까? 처음에는 데스크탑 컴퓨터가 그다지 위협적인 것처럼 보이지 않았습니다.최초의 사용자는 모두 해커, 즉 당시에는 취미 생활자로 불렸던 사람들이었습니다.그들은 마이크로컴퓨터가 싸기 때문에 좋아했습니다.처음으로 자신만의 컴퓨터를 가질 수 있게 되었습니다."개인용 컴퓨터"라는 문구는 현재 언어의 일부이지만 처음 사용되었을 때는 오늘날의 "개인용 위성"이라는 문구처럼 의도적으로 대담한 소리를 냈습니다. 데스크탑 컴퓨터가 왜 그 자리를 차지했을까요?더 나은 소프트웨어가 있었기 때문이라고 생각합니다.그리고 마이크로컴퓨터 소프트웨어가 더 좋은 이유는 소규모 회사에서도 작성할 수 있기 때문이라고 생각합니다. 초기 단계의 스타트업이 얼마나 취약하고 잠정적인지 깨닫는 사람은 많지 않은 것 같습니다.많은 스타트업은 거의 우연히 시작됩니다. 직장에서든 학교에서든 두 사람이 유망해 보이면 회사로 변할 수 있는 프로토타입을 작성하면서 시작됩니다.이 애벌레 단계에서는 심각한 장애물이 있으면 작업이 중지됩니다.

스타트업이 궤도에 진입하지 못했습니다.메인프레임 소프트웨어를 작성하려면 사전에 너무 많은 노력이 필요했습니다.개발 기계는 가격이 비쌌고, 고객이 대기업이었기 때문에 이를 판매하려면 인상적인 영업 인력이 필요했습니다.메인프레임 소프트웨어를 작성하기 위해 스타트업을 시작하는 것은 저녁에 Apple II에서 무언가를 함께 해킹하는 것보다 훨씬 더 진지한 일이 될 것입니다.그래서 메인프레임 애플리케이션을 작성하는 스타트업이 많지 않았습니다. 데스크탑 컴퓨터의 등장은 많은 새로운 소프트웨어에 영감을 주었습니다. 데스크탑 컴퓨터를 위한 애플리케이션을 작성하는 것이 초기 스타트업에게는 달성 가능한 목표처럼 보였기 때문입니다.개발 비용은 저렴했으며 고객은 컴퓨터 매장이나 우편 주문을 통해 접근할 수 있는 개인이었습니다. 데스크톱 컴퓨터를 주류로 끌어올린 응용 프로그램은 최초의 스프레드시트인 VisiCalc였습니다.이 책은 다락방에서 일하는 두 사람에 의해 작성되었지만 어떤 메인프레임 소프트웨어도 할 수 없는 일을 수행했습니다.[11] VisiCalc는 당시 사람들이 단지 실행하기 위해 Apple II를 구입할 정도로 발전했습니다.그리고 이것이 추세의 시작이었습니다. 데스크톱 컴퓨터는 스타트업이 소프트웨어를 작성했기 때문에 승리했습니다. 이번에는 서버 기반 소프트웨어가 좋을 것 같습니다. 스타트업이 작성할 것이기 때문입니다.이제 컴퓨터 가격이 너무 저렴해져서 우리처럼 데스크톱 컴퓨터를 서버로 사용해 시작할 수 있습니다.저렴한 프로세서가 워크스테이션 시장을 잠식했고(지금은 거의 들어본 적도 없음) 서버 시장을 거의 장악하고 있습니다.인터넷에서 가장 높은 로드를 처리하는 Yahoo의 서버는 모두 데스크톱 시스템에 있는 것과 동일한 저렴한 Intel 프로세서를 갖추고 있습니다.일단 소프트웨어를 작성하고 나면 이를 판매하기 위해 필요한 것은 웹 사이트뿐입니다.거의 모든 사용자가 입소문과 언론의 참고 자료를 통해 우리 사이트를 직접 방문했습니다.Viaweb은 전형적인 애벌레 스타트업이었습니다.우리는 회사를 시작하는 것이 두려웠고, 처음 몇 달 동안은 모든 일을 언제든지 취소할 수 있는 실험으로 여기며 스스로를 위로했습니다.다행스럽게도 기술적인 문제를 제외하고는 장애물이 거의 없었습니다.우리가 소프트웨어를 작성하는 동안 웹 서버는 개발에 사용한 것과 동일한 데스크톱 시스템이었으며 전화 접속 회선을 통해 외부 세계와 연결되었습니다.그 단계에서 우리가 지출한 유일한 비용은 식비와 집세뿐이었습니다. 이제 스타트업이 웹 기반 소프트웨어를 작성해야 할 이유가 더욱 많아졌습니다. 데스크탑 소프트웨어를 작성하는 것이 훨씬 덜 재미있어졌기 때문입니다.지금 데스크톱 소프트웨어를 작성하려면 Microsoft의 조건에 따라 API를 호출하고 버그가 있는 OS를 해결해야 합니다.그리고 성공할 수 있는 글을 작성했다면 마이크로소프트에 대한 시장 조사만 했다는 사실을 알게 될 것입니다. 회사가 스타트업이 구축할 플랫폼을 만들고 싶다면 해커 스스로가 사용하고 싶어할 만한 것으로 만들어야 합니다.즉, 가격이 저렴하고 디자인이 좋아야 합니다.Mac은 처음 출시되었을 때 해커들에게 인기가 있었고 많은 사람들이 Mac용 소프트웨어를 작성했습니다.[13] Windows에서는 해커가 사용하지 않기 때문에 이 내용이 덜 표시됩니다.소프트웨어 작성에 능숙한 사람들은 현재 Linux나 FreeBSD를 사용하는 경향이 있습니다. 데스크톱 소프트웨어를 작성하기 위해 스타트업을 시작하지는 않았을 것입니다. 왜냐하면 데스크톱 소프트웨어는 Windows에서 실행되어야 하고 Windows용 소프트웨어를 작성하려면 먼저 이를 사용해야 하기 때문입니다.웹을 사용하면 Windows를 최종적으로 실행하고 Unix에서 실행되는 소프트웨어를 브라우저를 통해 사용자에게 직접 전달할 수 있습니다.이는 25년 전 PC가 등장한 것과 매우 흡사한 해방적인 전망입니다. 마이크로소프트데스크톱 컴퓨터가 등장했을 때 IBM은 모두가 두려워하는 거대 기업이었습니다.지금은 상상하기 어렵지만 그 느낌을 아주 잘 기억합니다.이제 무서운 거대 기업은 Microsoft입니다. 저는 그들이 IBM처럼 자신들이 직면한 위협에 대해 무지하다고 생각하지 않습니다.결국 Microsoft는 IBM의 사각지대에서 의도적으로 비즈니스를 구축했습니다. 앞서 어머니에게 데스크톱 컴퓨터가 실제로 필요하지 않다고 언급했습니다.대부분의 사용자는 그렇지 않을 것입니다.저것

이는 Microsoft의 문제이며 그들은 그것을 알고 있습니다.응용 프로그램이 원격 서버에서 실행되는 경우에는 Windows가 필요하지 않습니다.마이크로소프트는 무엇을 할 것인가?이 새로운 세대의 소프트웨어를 방지하거나 제한하기 위해 데스크톱 제어권을 사용할 수 있을까요? 제 생각에는 Microsoft가 운영 체제가 자신이 제어하는 ​​서버와 함께 작동하는 일종의 서버/데스크톱 하이브리드를 개발할 것 같습니다.최소한 이를 원하는 사용자는 파일을 중앙에서 사용할 수 있습니다.나는 Microsoft가 가능한 한 클라이언트용 브라우저만 사용하여 서버에서 계산을 수행하는 극단적인 방법을 사용하지 않을 것이라고 기대합니다.클라이언트용 브라우저만 필요한 경우 클라이언트에 Microsoft가 필요하지 않으며 Microsoft가 클라이언트를 제어하지 않으면 사용자를 서버 기반 응용 프로그램으로 유도할 수 없습니다. Microsoft는 요정을 병 속에 가두는 데 어려움을 겪을 것이라고 생각합니다.클라이언트가 모두 제어하기에는 클라이언트 유형이 너무 많습니다.그리고 Microsoft의 응용 프로그램이 일부 클라이언트에서만 작동한다면 경쟁업체는 모든 클라이언트에서 작동하는 응용 프로그램을 제공함으로써 이를 능가할 수 있을 것입니다.[14] 웹 기반 응용 프로그램의 세계에서는 Microsoft가 자동으로 자리를 잡을 수 없습니다.그들은 스스로 자리를 잡는 데 성공할 수 있지만 데스크톱 응용 프로그램의 세계처럼 이 새로운 세계를 지배할 것이라고는 생각하지 않습니다.웹 기반 소프트웨어의 등장으로 그들은 기술적인 문제뿐만 아니라 그들 자신의 희망적인 생각에도 직면하게 될 것입니다.그들이 해야 할 일은 기존 사업을 잠식하는 것인데, 나는 그들이 그런 일에 직면하는 것을 볼 수 없습니다.그들을 지금까지 이끈 동일한 외심이 이제 그들에게 불리하게 작용할 것입니다.IBM도 똑같은 상황에 처해 있었고 이를 극복할 수 없었습니다.IBM은 자신들의 캐시카우인 메인프레임 컴퓨팅을 위협하는 것에 대해 양면적인 입장을 갖고 있었기 때문에 뒤늦게 마이크로컴퓨터 사업에 진출했습니다.마찬가지로 Microsoft도 데스크톱을 보호하려고 함으로써 방해를 받을 것입니다.캐시카우(cash cow)는 당신의 등에 업혀 있는 빌어먹을 무거운 원숭이일 수 있습니다. 누구도 서버 기반 애플리케이션을 지배하지 않을 것이라는 말은 아닙니다.누군가는 결국 그렇게 될 것입니다.그러나 나는 마이크로컴퓨터의 초창기에 그랬던 것처럼 꽤 오랜 기간 동안 즐거운 혼돈이 있을 것이라고 생각합니다.스타트업에게는 좋은 시기였습니다.많은 소규모 회사가 번성했고 멋진 것을 만들어 이를 실현했습니다. 스타트업이지만 더 그렇습니다. 고전적인 스타트업은 빠르고 비공식적이며 소수의 인력과 적은 돈으로 이루어집니다.그 소수의 사람들은 매우 열심히 일하고, 기술은 그들이 내리는 결정의 효과를 확대합니다.그들이 이기면 큰 승리를 거둘 것입니다. 웹 기반 애플리케이션을 작성하는 스타트업에서는 스타트업과 관련된 모든 것이 극단으로 치닫습니다.더 적은 인원과 더 적은 비용으로 제품을 작성하고 출시할 수 있습니다.훨씬 더 빨라야 하고, 좀 더 비공식적으로도 벗어날 수 있습니다.말 그대로 아파트 거실에 앉아 있는 세 사람과 ISP에 배치된 서버로 제품을 출시할 수 있습니다.시간이 지나면서 팀은 더 작아지고, 빨라지고, 비공식화되었습니다.1960년에 소프트웨어 개발이란 뿔테 안경을 쓰고 검은색 좁은 넥타이를 매고 IBM 코딩 양식에 하루에 10줄의 코드를 부지런히 작성하는 방 안의 남자들을 의미했습니다.1980년에는 청바지를 입고 사무실에 vt100s를 입력하는 8~10명의 사람들로 구성된 팀이었습니다.이제 두 명의 남자가 노트북을 들고 거실에 앉아 있습니다.(그리고 청바지는 비공식적인 표현의 최종 단어가 아닌 것으로 밝혀졌습니다.) 스타트업은 스트레스를 많이 받으며, 불행하게도 웹 기반 애플리케이션의 경우에도 이러한 현상이 극에 달합니다.Many software companies, especially at the beginning, have periods where the developers slept under their desks and so on.웹 기반 소프트웨어의 놀라운 점은 이것이 기본값이 되는 것을 막을 방법이 없다는 것입니다.책상 밑에서 잠을 자는 이야기는 대개 끝나죠. 마침내 우리는 책상을 배송하고 집에 가서 일주일 동안 잠을 잤습니다.웹 기반 소프트웨어는 결코 배송되지 않습니다.16시간 일할 수 있어요

원하는 만큼 며칠 동안.그리고 당신도 할 수 있고, 당신의 경쟁자도 할 수 있기 때문에 당신도 그렇게 하도록 강요받는 경향이 있습니다.할 수 있으므로 반드시 해야 합니다.역으로 진행되는 파킨슨의 법칙입니다. 가장 나쁜 것은 시간이 아니라 책임입니다.프로그래머와 시스템 관리자는 전통적으로 각기 다른 고민을 갖고 있습니다.프로그래머는 버그에 대해 걱정해야 하고, 시스템 관리자는 인프라에 대해 걱정해야 합니다.프로그래머는 팔꿈치까지 닿을 정도로 긴 하루를 소스 코드에서 보낼 수 있지만 어느 시점에 집에 돌아가면 잊어버리게 됩니다.시스템 관리자는 결코 업무를 뒤로 미루지 않지만 오전 4시에 호출을 받으면 일반적으로 매우 복잡한 작업을 수행할 필요가 없습니다.웹 기반 애플리케이션에서는 이 두 종류의 스트레스가 결합됩니다.프로그래머는 시스템 관리자가 되지만 일반적으로 작업을 견딜 수 있도록 명확하게 정의된 제한은 없습니다. Viaweb에서 우리는 처음 6개월을 소프트웨어 작성에만 보냈습니다.우리는 초기 스타트업에서 흔히 볼 수 있는 오랜 시간 일했습니다.데스크톱 소프트웨어 회사라면 이 부분이 우리가 열심히 일하는 부분이었을 텐데, 사용자를 서버로 데려오는 다음 단계에 비하면 휴가처럼 느껴졌습니다.Viaweb을 Yahoo에 판매함으로써 얻을 수 있는 두 번째로 큰 이점(돈 다음으로)은 모든 것에 대한 궁극적인 책임을 대기업의 어깨에 맡길 수 있다는 것입니다. 데스크탑 소프트웨어는 사용자가 시스템 관리자가 되도록 강요합니다.웹 기반 소프트웨어는 프로그래머에게 그렇게 하도록 강요합니다.전체적으로 스트레스는 적지만 프로그래머에게는 더 많은 스트레스가 있습니다.반드시 나쁜 소식은 아닙니다.대기업과 경쟁하는 스타트업이라면 좋은 소식입니다.[15] 웹 기반 애플리케이션은 경쟁사보다 앞서 나갈 수 있는 간단한 방법을 제공합니다.그 이상을 요구하는 스타트업은 없습니다. 충분합니다. 웹 기반 애플리케이션을 작성하는 것을 방해하는 한 가지 이유는 UI로서의 웹 페이지가 형편없다는 것입니다.그게 문제라는 걸 나도 인정한다.우리가 HTML과 HTTP에 정말로 추가하고 싶었던 몇 가지 사항이 있었습니다.그러나 중요한 것은 웹 페이지가 충분하다는 것입니다. 여기에는 최초의 마이크로컴퓨터와 유사점이 있습니다.해당 머신의 프로세서는 실제로 컴퓨터의 CPU로 사용되도록 의도된 것이 아닙니다.신호등과 같은 곳에 사용하도록 설계되었습니다.그러나 알테어를 디자인한 에드 로버츠(Ed Roberts) 같은 사람들은 그것만으로도 충분하다는 것을 깨달았습니다.이러한 칩 중 하나를 일부 메모리(첫 번째 Altair의 경우 256바이트) 및 전면 패널 스위치와 결합하면 작동하는 컴퓨터를 갖게 됩니다.자신의 컴퓨터를 가질 수 있다는 것은 너무나 흥미로웠기 때문에 그것을 사고 싶어하는 사람들이 많았지만 제한적이었습니다. 웹 페이지는 응용 프로그램의 UI로 설계되지 않았지만 그것만으로도 충분합니다.그리고 상당수의 사용자에게는 모든 브라우저에서 사용할 수 있는 소프트웨어가 UI의 어색함을 능가할 만큼 그 자체로 충분한 이점이 될 것입니다.HTML을 사용하여 가장 멋진 스프레드시트를 작성할 수는 없지만 특별한 클라이언트 소프트웨어 없이 여러 사람이 서로 다른 위치에서 동시에 사용할 수 있거나 실시간 데이터 피드를 통합할 수 있거나 특정 조건이 트리거될 때 페이지를 호출할 수 있는 스프레드시트를 작성할 수 있습니다.더 중요한 것은 아직 이름조차 없는 새로운 종류의 애플리케이션을 작성할 수 있다는 것입니다.VisiCalc는 결국 메인프레임 응용 프로그램의 단순한 마이크로컴퓨터 버전이 아니라 새로운 유형의 응용 프로그램이었습니다. 물론 서버 기반 응용 프로그램이 웹 기반일 필요는 없습니다.다른 종류의 클라이언트가 있을 수도 있습니다.하지만 나는 그것이 나쁜 생각이라고 확신합니다.모든 사람이 클라이언트를 설치할 것이라고 가정할 수 있다면 매우 편리할 것입니다. 너무 편리해서 모두가 그렇게 할 것이라고 쉽게 확신할 수 있습니다. 그러나 그렇지 않으면 곤란합니다.웹 기반 소프트웨어는 클라이언트에 대해 아무 것도 가정하지 않기 때문에 웹이 작동하는 모든 곳에서 작동합니다.이는 이미 큰 이점이며 새로운 웹 장치가 확산됨에 따라 이점도 더욱 커질 것입니다.귀하의 소프트웨어가 제대로 작동하기 때문에 사용자는 귀하를 좋아할 것이며, EV용으로 조정할 필요가 없기 때문에 귀하의 삶이 더 편해질 것입니다.

새로운 클라이언트입니다.[16]나는 웹의 진화를 누구보다도 면밀히 지켜본 것 같지만 클라이언트에게 무슨 일이 일어날지 예측할 수 없습니다.아마도 융합이 다가오고 있을 것입니다. 하지만 어디일까요?승자를 선택할 수 없습니다.내가 예상할 수 있는 것 중 하나는 AOL과 Microsoft 간의 갈등입니다.Microsoft의 .NET이 무엇이든 간에 데스크톱을 서버에 연결하는 작업이 포함될 것입니다.AOL이 반격하지 않으면 AOL은 밀려나거나 Microsoft 클라이언트와 서버 소프트웨어 사이의 파이프로 바뀔 것입니다.Microsoft와 AOL이 클라이언트 전쟁에 돌입한다면 둘 다 확실히 작동하는 유일한 방법은 웹 검색뿐일 것입니다. 즉, 웹 기반 응용 프로그램이 어디에서나 작동하는 유일한 종류가 될 것입니다. 이 모든 것이 어떻게 전개될까요?모르겠습니다.그리고 웹 기반 애플리케이션에 투자하는지 여부를 알 필요가 없습니다.브라우징을 중단하지 않고는 누구도 그것을 깨뜨릴 수 없습니다.웹이 소프트웨어를 전달하는 유일한 방법은 아닐 수도 있지만, 웹은 현재 작동하고 있으며 앞으로도 오랫동안 작동할 것입니다.웹 기반 애플리케이션은 개발 비용이 저렴하고 소규모 스타트업도 쉽게 제공할 수 있습니다.그것은 많은 일이고 특히 스트레스가 많은 일이지만 그것은 스타트업에게 더 나은 가능성을 가져다 줄 뿐입니다. 왜 안 될까요?E.B. White는 농부 친구로부터 많은 전기 울타리에는 전류가 흐르지 않는다는 사실을 듣고 흥미를 느꼈습니다.소들은 분명히 그들로부터 멀리 떨어져 있는 법을 배우고 그 후에는 전류가 필요하지 않습니다."일어나라, 소들아!"그는 "독재자들이 코를 고는 동안 자유를 가져라!"라고 썼습니다. 언젠가 스타트업을 시작할 생각을 가진 해커라면, 아마도 스타트업을 시작하는 것을 방해하는 두 가지 요인이 있을 것입니다.하나는 당신이 사업에 대해 아무것도 모른다는 것입니다.다른 하나는 경쟁을 두려워한다는 것입니다.이 울타리 중 어느 것에도 전류가 없습니다. 비즈니스에 대해 알아야 할 것은 두 가지뿐입니다. 사용자가 좋아하는 것을 만들고 지출보다 더 많이 버는 것입니다.이 두 가지를 올바르게 수행한다면 대부분의 스타트업보다 앞서게 될 것입니다.나머지는 진행하면서 알아낼 수 있습니다. 처음에는 지출한 것보다 더 많이 벌지 못할 수도 있지만 격차가 충분히 빨리 줄어들면 괜찮을 것입니다.자금이 부족한 상태에서 시작한다면 최소한 절약하는 습관을 갖게 될 것입니다.지출이 적을수록 지출보다 더 많은 돈을 벌기가 더 쉽습니다.다행스럽게도 웹 기반 애플리케이션을 실행하는 것은 매우 저렴할 수 있습니다.우리는 $10,000 미만으로 출시했는데 지금은 훨씬 더 저렴해질 것입니다.우리는 서버에 수천 달러를 투자해야 했고, SSL을 얻기 위해 수천 달러를 더 투자해야 했습니다.(당시 SSL 소프트웨어를 판매하는 유일한 회사는 Netscape였습니다.) 이제 SSL이 포함된 훨씬 더 강력한 서버를 대역폭만 지불한 것보다 저렴한 가격으로 임대할 수 있습니다.이제 멋진 사무실 의자를 구입하는 비용보다 적은 비용으로 웹 기반 애플리케이션을 시작할 수 있습니다. 사용자가 좋아하는 것을 구축하는 것과 관련하여 다음은 몇 가지 일반적인 팁입니다.스스로 사용하고 싶은 깨끗하고 간단한 것을 만드는 것부터 시작하세요.버전 1.0을 빨리 출시한 다음 소프트웨어를 계속 개선하면서 사용자의 의견에 귀를 기울이십시오.고객은 항상 옳지만, 고객마다 다른 점에 있어서는 옳습니다.가장 숙련된 사용자는 단순화하고 명확하게 해야 할 사항을 보여주고, 가장 숙련된 사용자는 추가해야 할 기능을 알려줍니다.소프트웨어가 할 수 있는 가장 좋은 일은 쉽다는 것입니다. 그러나 이를 수행하는 방법은 사용자의 선택을 제한하는 것이 아니라 기본값을 올바르게 설정하는 것입니다.경쟁사의 소프트웨어가 형편없다고 해서 안주하지 마십시오.귀하의 소프트웨어를 비교하는 표준은 현재 경쟁업체가 보유하고 있는 것이 아니라 소프트웨어가 될 수 있는 것입니다.항상 소프트웨어를 직접 사용하십시오.Viaweb은 온라인 상점 빌더로 되어 있었지만 우리는 이를 사용하여 자체 사이트도 만들었습니다.단지 직위 때문에 마케팅 담당자나 디자이너, 제품 관리자의 말을 듣지 마십시오.좋은 아이디어가 있으면 활용하세요. 하지만 결정은 여러분의 몫입니다.소프트웨어는 소프트웨어에 대해 조금 아는 디자이너가 아니라 디자인을 이해하는 해커가 디자인해야 합니다.소프트웨어를 설계하고 구현할 수 없다면 스타트업을 시작하지 마세요. 이제 경쟁에 대해 이야기해 보겠습니다.당신이 두려워하는 것

아마도 당신과 같은 해커 그룹이 아니라 실제 회사에 사무실과 사업 계획, 영업 사원 등이 있는 것 아닌가요?글쎄요, 그들은 당신보다 당신을 더 두려워합니다. 그리고 그들이 옳습니다.어떤 규모의 회사가 소프트웨어를 작성하는 것보다 두 명의 해커가 사무실 공간을 임대하거나 영업 사원을 고용하는 방법을 알아내는 것이 훨씬 쉽습니다.나는 양쪽에 모두 가봤고 알고 있습니다.Viaweb이 Yahoo에 인수되었을 때 저는 갑자기 대기업에 근무하게 되었는데, 마치 허리까지 차는 물을 헤쳐나가는 것과 같았습니다. Yahoo를 폄하하려는 것은 아닙니다.그 회사에는 좋은 해커가 몇 명 있었고, 최고 경영진은 정말 엉터리였습니다.대기업으로서는 예외적이었습니다.하지만 여전히 소규모 스타트업의 생산성은 10분의 1 수준에 불과했습니다.어떤 대기업도 이보다 더 잘할 수는 없습니다.Microsoft의 무서운 점은 이렇게 큰 회사가 소프트웨어를 아예 개발할 수 있다는 것입니다.걸어갈 수 있는 산과 같습니다. 겁먹지 마세요.당신은 마이크로소프트가 할 수 없는 일을 당신이 할 수 없는 만큼 할 수 있습니다.그리고 누구도 당신을 막을 수 없습니다.웹 기반 애플리케이션을 개발하기 위해 누구에게도 허가를 요청할 필요가 없습니다.라이선스 거래를 할 필요도 없고, 소매점에서 선반 공간을 확보할 필요도 없고, OS와 함께 애플리케이션을 번들로 묶기 위해 애쓸 필요도 없습니다.소프트웨어를 브라우저에 직접 전달할 수 있으며 웹 탐색을 방해하지 않고는 누구도 귀하와 잠재적 사용자 사이에 끼어들 수 없습니다. 믿을 수 없을 수도 있지만 약속합니다. Microsoft는 귀하를 두려워합니다.안일한 중간 관리자는 그렇지 않을 수도 있지만 Bill은 그렇습니다. 1975년에 마지막으로 소프트웨어를 제공하는 새로운 방법이 나타났기 때문입니다. 참고[1] 많은 돈이 서비스에 있다는 것을 깨닫고 경량 클라이언트를 구축하는 회사는 일반적으로 하드웨어를 온라인 서비스와 결합하려고 시도했습니다.이 접근 방식은 잘 작동하지 않았습니다. 부분적으로는 가전 제품을 만들고 온라인 서비스를 운영하려면 서로 다른 두 종류의 회사가 필요하고 부분적으로는 사용자가 아이디어를 싫어하기 때문입니다.면도기를 기부하고 면도날로 돈을 버는 것이 질레트에게는 효과가 있을 수 있지만 면도기는 웹 터미널보다 훨씬 적은 노력입니다.휴대폰 제조사들도 서비스 수익을 노리지 않고 하드웨어 판매에 만족하고 있다.이는 아마도 인터넷 클라이언트에게도 모델이 될 것입니다.누군가 ISP를 통해 연결하는 데 사용할 수 있는 웹 브라우저가 포함된 멋진 작은 상자를 판매했다면 전국의 모든 기술 혐오자는 하나를 구입할 것입니다.[2]보안은 항상 설계 결정보다 문제를 일으키지 않는 것에 더 많이 좌우됩니다. 그러나 서버 기반 소프트웨어의 특성상 개발자는 문제를 일으키지 않는 데 더 많은 주의를 기울이게 됩니다.서버를 손상시키면 ASP(비즈니스를 유지하려는)가 보안에 주의할 만큼 피해가 발생할 수 있습니다.[3]1995년에 Viaweb을 시작했을 때 Java 애플릿은 모든 사람이 서버 기반 애플리케이션을 개발하는 데 사용할 기술로 여겨졌습니다.애플릿은 우리에게 구식 아이디어처럼 보였습니다.클라이언트에서 실행할 프로그램을 다운로드하시겠습니까?끝까지 가서 서버에서 프로그램을 실행하는 것이 더 간단합니다.우리는 애플릿에 거의 시간을 낭비하지 않았지만 수많은 다른 스타트업이 이 타르 구덩이에 빠져들었을 것입니다.살아남은 사람은 거의 없으며 Microsoft는 최신 버전의 Explorer에서 Java를 삭제하고도 벗어날 수 없었습니다.[4]이 점은 Trevor Blackwell이 덧붙인 것입니다. "소프트웨어 작성 비용은 크기에 따라 선형적으로 증가합니다. 아마도 이것은 주로 오래된 버그를 수정하기 때문이며 모든 버그를 빨리 발견하면 비용이 더 선형적일 수 있습니다."[5] 찾기 가장 어려운 종류의 버그는 하나의 버그가 다른 버그를 보완하기 위해 발생하는 복합 버그의 변형일 수 있습니다.하나의 버그를 수정하면 다른 버그도 표시됩니다.그러나 수정 사항이 마지막으로 변경한 것이므로 수정 사항에 결함이 있는 것처럼 보일 것입니다.[6]Viaweb 내에서 우리는 소프트웨어의 최악의 점을 설명하는 콘테스트를 한 번 가졌습니다.두 명의 고객 지원 담당자가 아직도 기억이 나지 않아 떨리는 항목으로 공동 1등상을 받았습니다.우리는 두 가지 문제를 즉시 해결했습니다.[7]로버트 M

오리스는 쇼핑객이 주문할 때 사용하는 주문 시스템을 만들었습니다.Trevor Blackwell은 판매자가 주문 검색, 통계 보기, 도메인 이름 구성 등에 사용하는 이미지 생성기와 관리자를 작성했습니다. 저는 판매자가 사이트를 구축하는 데 사용하는 편집기를 작성했습니다.주문 시스템과 이미지 생성기는 C와 C++로 작성되었으며 관리자는 대부분 Perl로, 편집기는 Lisp로 작성되었습니다.[8]가격 차별은 너무나 널리 퍼져 있습니다(구매력이 가격을 낮추는 것을 의미한다고 소매업자가 주장하는 것을 얼마나 자주 들었습니까?). 저는 이것이 1936년 로빈슨-패트먼 법에 의해 미국에서 불법화되었다는 사실에 놀랐습니다. 이 법은 강력하게 시행되지 않는 것 같습니다.[9]No Logo에서 Naomi Klein은 "도시 청소년"이 선호하는 의류 브랜드가 목표 시장에서는 좀도둑이 패션 리더이기도 하기 때문에 좀도둑을 방지하기 위해 너무 열심히 노력하지 않는다고 말합니다.[10]기업에서는 아웃소싱해야 할 것과 하지 말아야 할 것을 궁금해하는 경우가 많습니다.한 가지 가능한 대답은 경쟁 압력에 직접적으로 노출되지 않는 모든 작업을 아웃소싱하는 것입니다. 왜냐하면 아웃소싱하면 경쟁 압력에 노출되기 때문입니다.[11]두 사람은 Dan Bricklin과 Bob Frankston이었습니다.Dan은 며칠 만에 Basic으로 프로토타입을 작성한 후 다음 해에 걸쳐 (주로 밤에) 함께 작업하여 6502 기계 언어로 작성된 더욱 강력한 버전을 만들었습니다.Dan은 당시 Harvard Business School에 재학 중이었고 Bob은 명목상 소프트웨어 작성 일을 하고 있었습니다.Bob은 이렇게 썼습니다. "사업을 하는 데는 큰 위험이 없습니다. 실패하면 실패한 것입니다. 별거 아닙니다."[12] 내가 말하는 것만큼 쉽지는 않습니다.입소문이 퍼지기까지 고통스러울 정도로 오랜 시간이 걸렸고, 한 달에 16,000달러를 받고 PR 회사(물론 업계 최고)를 고용하기 전까지는 언론에 많이 보도되기 시작하지 않았습니다.그러나 유일하게 중요한 채널이 우리 웹사이트라는 것은 사실이었습니다.[13]맥이 그토록 훌륭했다면 왜 패했을까?다시 비용.마이크로소프트는 소프트웨어 사업에 집중했고, 애플 하드웨어에 값싼 부품 공급업체들을 쏟아냈다.중요한 시기에 슈트가 장악한 것도 도움이 되지 않았습니다.[14]웹 기반 응용 프로그램을 지원하고 차세대 소프트웨어가 Microsoft의 뒤를 잇는 것을 막는 데 도움이 되는 한 가지는 좋은 오픈 소스 브라우저입니다.Mozilla는 오픈 소스이지만 너무 오랫동안 기업 소프트웨어로 사용되면서 어려움을 겪어온 것 같습니다.적극적으로 유지 관리되는 작고 빠른 브라우저는 그 자체로 훌륭한 일이 될 것이며 아마도 기업이 작은 웹 기기를 구축하도록 장려할 것입니다. 무엇보다도 적절한 오픈 소스 브라우저는 HTTP와 HTML을 계속해서 발전시킬 것입니다(예: Perl이 그랬듯이).이는 웹 기반 애플리케이션이 링크 선택과 링크 따라가기를 구별하는 데 큰 도움이 될 것입니다.이를 수행하기 위해 필요한 것은 요청에 여러 URL을 허용하기 위해 HTTP를 약간 향상시키는 것뿐입니다.계단식 메뉴도 좋을 것 같아요. 세상을 바꾸고 싶다면 새로운 모자이크를 써보세요.너무 늦었다고 생각하시나요?1998년에는 많은 사람들이 새로운 검색 엔진을 출시하기에는 너무 늦었다고 생각했지만 Google은 그들이 틀렸다는 것을 증명했습니다.현재 옵션이 충분하지 않다면 항상 새로운 것을 위한 여지가 있습니다.먼저 모든 무료 OS에서 작동하는지 확인하세요. 새로운 것은 사용자로부터 시작됩니다.[15]개인적인 경험을 통해 이에 대해 누구보다 잘 알고 있는 Trevor Blackwell은 다음과 같이 썼습니다. "서버 기반 소프트웨어는 프로그래머에게 너무 어렵기 때문에 대기업에서 벗어나 근본적인 경제적 변화를 가져온다고 말하고 싶습니다. 이를 위해서는 프로그래머가 자신의 회사일 때에만 기꺼이 제공할 수 있는 강도와 헌신이 필요합니다. 소프트웨어 회사는 너무 까다롭지 않은 환경에서 일하기 위해 숙련된 사람을 고용할 수 있고 어려움을 견디기 위해 숙련되지 않은 사람을 고용할 수 있지만,더 이상 자본이 필요하지 않기 때문에 대기업은 가져올 것이 거의 없습니다."[16] 이 에세이의 원본 버전에서 나는 조언합니다.

sed는 Javascript를 피합니다.2001년에는 좋은 계획이었지만 지금은 Javascript가 작동합니다.이 문서의 초안을 읽어주신 Sarah Harlin, Trevor Blackwell, Robert Morris, Eric Raymond, Ken Anderson 및 Dan Giffin에게 감사드립니다.VisiCalc에 대한 정보는 Dan Bricklin과 Bob Frankston에게,BBN에서 강연하도록 초대해 주신 Ken Anderson에게 다시 한 번 감사드립니다.Hackers & Painters에서 이 에세이와 다른 14개의 에세이를 찾을 수 있습니다.일부 기술 세부 사항일본어 번역Microsoft는 마침내 Gates Email에 동의합니다.

---

## 원문 (Original Essay)

September 2001 (This article explains why much of the next generation of software may be server-based, what that will mean for programmers, and why this new kind of software is a great opportunity for startups. It's derived from a talk at BBN Labs.) In the summer of 1995, my friend Robert Morris and I decided to start a startup. The PR campaign leading up to Netscape's IPO was running full blast then, and there was a lot of talk in the press about online commerce. At the time there might have been thirty actual stores on the Web, all made by hand. If there were going to be a lot of online stores, there would need to be software for making them, so we decided to write some.For the first week or so we intended to make this an ordinary desktop application. Then one day we had the idea of making the software run on our Web server, using the browser as an interface. We tried rewriting the software to work over the Web, and it was clear that this was the way to go. If we wrote our software to run on the server, it would be a lot easier for the users and for us as well.This turned out to be a good plan. Now, as Yahoo Store, this software is the most popular online store builder, with about 14,000 users.When we started Viaweb, hardly anyone understood what we meant when we said that the software ran on the server. It was not until Hotmail was launched a year later that people started to get it. Now everyone knows that this is a valid approach. There is a name now for what we were: an Application Service Provider, or ASP.I think that a lot of the next generation of software will be written on this model. Even Microsoft, who have the most to lose, seem to see the inevitablity of moving some things off the desktop. If software moves off the desktop and onto servers, it will mean a very different world for developers. This article describes the surprising things we saw, as some of the first visitors to this new world. To the extent software does move onto servers, what I'm describing here is the future.The Next Thing?When we look back on the desktop software era, I think we'll marvel at the inconveniences people put up with, just as we marvel now at what early car owners put up with. For the first twenty or thirty years, you had to be a car expert to own a car. But cars were such a big win that lots of people who weren't car experts wanted to have them as well.Computers are in this phase now. When you own a desktop computer, you end up learning a lot more than you wanted to know about what's happening inside it. But more than half the households in the US own one. My mother has a computer that she uses for email and for keeping accounts. About a year ago she was alarmed to receive a letter from Apple, offering her a discount on a new version of the operating system. There's something wrong when a sixty-five year old woman who wants to use a computer for email and accounts has to think about installing new operating systems. Ordinary users shouldn't even know the words "operating system," much less "device driver" or "patch."There is now another way to deliver software that will save users from becoming system administrators. Web-based applications are programs that run on Web servers and use Web pages as the user interface. For the average user this new kind of software will be easier, cheaper, more mobile, more reliable, and often more powerful than desktop software.With Web-based software, most users won't have to think about anything except the applications they use. All the messy, changing stuff will be sitting on a server somewhere, maintained by the kind of people who are good at that kind of thing. And so you won't ordinarily need a computer, per se, to use software. All you'll need will be something with a keyboard, a screen, and a Web browser. Maybe it will have wireless Internet access. Maybe it will also be your cell phone. Whatever it is, it will be consumer electronics: something that costs about $200, and that people choose mostly based on how the case looks. You'll pay more for Internet services than you do for the hardware, just as you do now with telephones. [1]It will take about a tenth of a second for a click to get to the server and back, so users of heavily interactive software, like Photoshop, will still want to have the computations happening on the desktop. But if you look at the kind of things most people use computers for, a tenth of a second latency would not be a problem. My mother doesn't really need a desktop computer, and there are a lot of people like her.The Win for UsersNear my house there is a car with a bumper sticker that reads "death before inconvenience." Most people, most of the time, will take whatever choice requires least work. If Web-based software wins, it will be because it's more convenient. And it looks as if it will be, for users and developers both.To use a purely Web-based application, all you need is a browser connected to the Internet. So you can use a Web-based application anywhere. When you install software on your desktop computer, you can only use it on that computer. Worse still, your files are trapped on that computer. The inconvenience of this model becomes more and more evident as people get used to networks.The thin end of the wedge here was Web-based email. Millions of people now realize that you should have access to email messages no matter where you are. And if you can see your email, why not your calendar? If you can discuss a document with your colleagues, why can't you edit it? Why should any of your data be trapped on some computer sitting on a faraway desk?The whole idea of "your computer" is going away, and being replaced with "your data." You should be able to get at your data from any computer. Or rather, any client, and a client doesn't have to be a computer.Clients shouldn't store data; they should be like telephones. In fact they may become telephones, or vice versa. And as clients get smaller, you have another reason not to keep your data on them: something you carry around with you can be lost or stolen. Leaving your PDA in a taxi is like a disk crash, except that your data is handed to someone else instead of being vaporized.With purely Web-based software, neither your data nor the applications are kept on the client. So you don't have to install anything to use it. And when there's no installation, you don't have to worry about installation going wrong. There can't be incompatibilities between the application and your operating system, because the software doesn't run on your operating system.Because it needs no installation, it will be easy, and common, to try Web-based software before you "buy" it. You should expect to be able to test-drive any Web-based application for free, just by going to the site where it's offered. At Viaweb our whole site was like a big arrow pointing users to the test drive.After trying the demo, signing up for the service should require nothing more than filling out a brief form (the briefer the better). And that should be the last work the user has to do. With Web-based software, you should get new releases without paying extra, or doing any work, or possibly even knowing about it.Upgrades won't be the big shocks they are now. Over time applications will quietly grow more powerful. This will take some effort on the part of the developers. They will have to design software so that it can be updated without confusing the users. That's a new problem, but there are ways to solve it.With Web-based applications, everyone uses the same version, and bugs can be fixed as soon as they're discovered. So Web-based software should have far fewer bugs than desktop software. At Viaweb, I doubt we ever had ten known bugs at any one time. That's orders of magnitude better than desktop software.Web-based applications can be used by several people at the same time. This is an obvious win for collaborative applications, but I bet users will start to want this in most applications once they realize it's possible. It will often be useful to let two people edit the same document, for example. Viaweb let multiple users edit a site simultaneously, more because that was the right way to write the software than because we expected users to want to, but it turned out that many did.When you use a Web-based application, your data will be safer. Disk crashes won't be a thing of the past, but users won't hear about them anymore. They'll happen within server farms. And companies offering Web-based applications will actually do backups-- not only because they'll have real system administrators worrying about such things, but because an ASP that does lose people's data will be in big, big trouble. When people lose their own data in a disk crash, they can't get that mad, because they only have themselves to be mad at. When a company loses their data for them, they'll get a lot madder.Finally, Web-based software should be less vulnerable to viruses. If the client doesn't run anything except a browser, there's less chance of running viruses, and no data locally to damage. And a program that attacked the servers themselves should find them very well defended. [2]For users, Web-based software will be less stressful. I think if you looked inside the average Windows user you'd find a huge and pretty much untapped desire for software meeting that description. Unleashed, it could be a powerful force.City of CodeTo developers, the most conspicuous difference between Web-based and desktop software is that a Web-based application is not a single piece of code. It will be a collection of programs of different types rather than a single big binary. And so designing Web-based software is like desiging a city rather than a building: as well as buildings you need roads, street signs, utilities, police and fire departments, and plans for both growth and various kinds of disasters.At Viaweb, software included fairly big applications that users talked to directly, programs that those programs used, programs that ran constantly in the background looking for problems, programs that tried to restart things if they broke, programs that ran occasionally to compile statistics or build indexes for searches, programs we ran explicitly to garbage-collect resources or to move or restore data, programs that pretended to be users (to measure performance or expose bugs), programs for diagnosing network troubles, programs for doing backups, interfaces to outside services, software that drove an impressive collection of dials displaying real-time server statistics (a hit with visitors, but indispensable for us too), modifications (including bug fixes) to open-source software, and a great many configuration files and settings. Trevor Blackwell wrote a spectacular program for moving stores to new servers across the country, without shutting them down, after we were bought by Yahoo. Programs paged us, sent faxes and email to users, conducted transactions with credit card processors, and talked to one another through sockets, pipes, http requests, ssh, udp packets, shared memory, and files. Some of Viaweb even consisted of the absence of programs, since one of the keys to Unix security is not to run unnecessary utilities that people might use to break into your servers.It did not end with software. We spent a lot of time thinking about server configurations. We built the servers ourselves, from components-- partly to save money, and partly to get exactly what we wanted. We had to think about whether our upstream ISP had fast enough connections to all the backbones. We serially dated RAID suppliers.But hardware is not just something to worry about. When you control it you can do more for users. With a desktop application, you can specify certain minimum hardware, but you can't add more. If you administer the servers, you can in one step enable all your users to page people, or send faxes, or send commands by phone, or process credit cards, etc, just by installing the relevant hardware. We always looked for new ways to add features with hardware, not just because it pleased users, but also as a way to distinguish ourselves from competitors who (either because they sold desktop software, or resold Web-based applications through ISPs) didn't have direct control over the hardware.Because the software in a Web-based application will be a collection of programs rather than a single binary, it can be written in any number of different languages. When you're writing desktop software, you're practically forced to write the application in the same language as the underlying operating system-- meaning C and C++. And so these languages (especially among nontechnical people like managers and VCs) got to be considered as the languages for "serious" software development. But that was just an artifact of the way desktop software had to be delivered. For server-based software you can use any language you want. [3] Today a lot of the top hackers are using languages far removed from C and C++: Perl, Python, and even Lisp.With server-based software, no one can tell you what language to use, because you control the whole system, right down to the hardware. Different languages are good for different tasks. You can use whichever is best for each. And when you have competitors, "you can" means "you must" (we'll return to this later), because if you don't take advantage of this possibility, your competitors will.Most of our competitors used C and C++, and this made their software visibly inferior because (among other things), they had no way around the statelessness of CGI scripts. If you were going to change something, all the changes had to happen on one page, with an Update button at the bottom. As I've written elsewhere, by using Lisp, which many people still consider a research language, we could make the Viaweb editor behave more like desktop software.ReleasesOne of the most important changes in this new world is the way you do releases. In the desktop software business, doing a release is a huge trauma, in which the whole company sweats and strains to push out a single, giant piece of code. Obvious comparisons suggest themselves, both to the process and the resulting product.With server-based software, you can make changes almost as you would in a program you were writing for yourself. You release software as a series of incremental changes instead of an occasional big explosion. A typical desktop software company might do one or two releases a year. At Viaweb we often did three to five releases a day.When you switch to this new model, you realize how much software development is affected by the way it is released. Many of the nastiest problems you see in the desktop software business are due to catastrophic nature of releases.When you release only one new version a year, you tend to deal with bugs wholesale. Some time before the release date you assemble a new version in which half the code has been torn out and replaced, introducing countless bugs. Then a squad of QA people step in and start counting them, and the programmers work down the list, fixing them. They do not generally get to the end of the list, and indeed, no one is sure where the end is. It's like fishing rubble out of a pond. You never really know what's happening inside the software. At best you end up with a statistical sort of correctness.With server-based software, most of the change is small and incremental. That in itself is less likely to introduce bugs. It also means you know what to test most carefully when you're about to release software: the last thing you changed. You end up with a much firmer grip on the code. As a general rule, you do know what's happening inside it. You don't have the source code memorized, of course, but when you read the source you do it like a pilot scanning the instrument panel, not like a detective trying to unravel some mystery.Desktop software breeds a certain fatalism about bugs. You know that you're shipping something loaded with bugs, and you've even set up mechanisms to compensate for it (e.g. patch releases). So why worry about a few more? Soon you're releasing whole features you know are broken. Apple did this earlier this year. They felt under pressure to release their new OS, whose release date had already slipped four times, but some of the software (support for CDs and DVDs) wasn't ready. The solution? They released the OS without the unfinished parts, and users will have to install them later.With Web-based software, you never have to release software before it works, and you can release it as soon as it does work.The industry veteran may be thinking, it's a fine-sounding idea to say that you never have to release software before it works, but what happens when you've promised to deliver a new version of your software by a certain date? With Web-based software, you wouldn't make such a promise, because there are no versions. Your software changes gradually and continuously. Some changes might be bigger than others, but the idea of versions just doesn't naturally fit onto Web-based software.If anyone remembers Viaweb this might sound odd, because we were always announcing new versions. This was done entirely for PR purposes. The trade press, we learned, thinks in version numbers. They will give you major coverage for a major release, meaning a new first digit on the version number, and generally a paragraph at most for a point release, meaning a new digit after the decimal point.Some of our competitors were offering desktop software and actually had version numbers. And for these releases, the mere fact of which seemed to us evidence of their backwardness, they would get all kinds of publicity. We didn't want to miss out, so we started giving version numbers to our software too. When we wanted some publicity, we'd make a list of all the features we'd added since the last "release," stick a new version number on the software, and issue a press release saying that the new version was available immediately. Amazingly, no one ever called us on it.By the time we were bought, we had done this three times, so we were on Version 4. Version 4.1 if I remember correctly. After Viaweb became Yahoo Store, there was no longer such a desperate need for publicity, so although the software continued to evolve, the whole idea of version numbers was quietly dropped.BugsThe other major technical advantage of Web-based software is that you can reproduce most bugs. You have the users' data right there on your disk. If someone breaks your software, you don't have to try to guess what's going on, as you would with desktop software: you should be able to reproduce the error while they're on the phone with you. You might even know about it already, if you have code for noticing errors built into your application.Web-based software gets used round the clock, so everything you do is immediately put through the wringer. Bugs turn up quickly.Software companies are sometimes accused of letting the users debug their software. And that is just what I'm advocating. For Web-based software it's actually a good plan, because the bugs are fewer and transient. When you release software gradually you get far fewer bugs to start with. And when you can reproduce errors and release changes instantly, you can find and fix most bugs as soon as they appear. We never had enough bugs at any one time to bother with a formal bug-tracking system.You should test changes before you release them, of course, so no major bugs should get released. Those few that inevitably slip through will involve borderline cases and will only affect the few users that encounter them before someone calls in to complain. As long as you fix bugs right away, the net effect, for the average user, is far fewer bugs. I doubt the average Viaweb user ever saw a bug.Fixing fresh bugs is easier than fixing old ones. It's usually fairly quick to find a bug in code you just wrote. When it turns up you often know what's wrong before you even look at the source, because you were already worrying about it subconsciously. Fixing a bug in something you wrote six months ago (the average case if you release once a year) is a lot more work. And since you don't understand the code as well, you're more likely to fix it in an ugly way, or even introduce more bugs. [4]When you catch bugs early, you also get fewer compound bugs. Compound bugs are two separate bugs that interact: you trip going downstairs, and when you reach for the handrail it comes off in your hand. In software this kind of bug is the hardest to find, and also tends to have the worst consequences. [5] The traditional "break everything and then filter out the bugs" approach inherently yields a lot of compound bugs. And software that's released in a series of small changes inherently tends not to. The floors are constantly being swept clean of any loose objects that might later get stuck in something.It helps if you use a technique called functional programming. Functional programming means avoiding side-effects. It's something you're more likely to see in research papers than commercial software, but for Web-based applications it turns out to be really useful. It's hard to write entire programs as purely functional code, but you can write substantial chunks this way. It makes those parts of your software easier to test, because they have no state, and that is very convenient in a situation where you are constantly making and testing small modifications. I wrote much of Viaweb's editor in this style, and we made our scripting language, RTML, a purely functional language.People from the desktop software business will find this hard to credit, but at Viaweb bugs became almost a game. Since most released bugs involved borderline cases, the users who encountered them were likely to be advanced users, pushing the envelope. Advanced users are more forgiving about bugs, especially since you probably introduced them in the course of adding some feature they were asking for. In fact, because bugs were rare and you had to be doing sophisticated things to see them, advanced users were often proud to catch one. They would call support in a spirit more of triumph than anger, as if they had scored points off us.SupportWhen you can reproduce errors, it changes your approach to customer support. At most software companies, support is offered as a way to make customers feel better. They're either calling you about a known bug, or they're just doing something wrong and you have to figure out what. In either case there's not much you can learn from them. And so you tend to view support calls as a pain in the ass that you want to isolate from your developers as much as possible.This was not how things worked at Viaweb. At Viaweb, support was free, because we wanted to hear from customers. If someone had a problem, we wanted to know about it right away so that we could reproduce the error and release a fix.So at Viaweb the developers were always in close contact with support. The customer support people were about thirty feet away from the programmers, and knew that they could always interrupt anything with a report of a genuine bug. We would leave a board meeting to fix a serious bug.Our approach to support made everyone happier. The customers were delighted. Just imagine how it would feel to call a support line and be treated as someone bringing important news. The customer support people liked it because it meant they could help the users, instead of reading scripts to them. And the programmers liked it because they could reproduce bugs instead of just hearing vague second-hand reports about them.Our policy of fixing bugs on the fly changed the relationship between customer support people and hackers. At most software companies, support people are underpaid human shields, and hackers are little copies of God the Father, creators of the world. Whatever the procedure for reporting bugs, it is likely to be one-directional: support people who hear about bugs fill out some form that eventually gets passed on (possibly via QA) to programmers, who put it on their list of things to do. It was very different at Viaweb. Within a minute of hearing about a bug from a customer, the support people could be standing next to a programmer hearing him say "Shit, you're right, it's a bug." It delighted the support people to hear that "you're right" from the hackers. They used to bring us bugs with the same expectant air as a cat bringing you a mouse it has just killed. It also made them more careful in judging the seriousness of a bug, because now their honor was on the line.After we were bought by Yahoo, the customer support people were moved far away from the programmers. It was only then that we realized that they were effectively QA and to some extent marketing as well. In addition to catching bugs, they were the keepers of the knowledge of vaguer, buglike things, like features that confused users. [6] They were also a kind of proxy focus group; we could ask them which of two new features users wanted more, and they were always right.MoraleBeing able to release software immediately is a big motivator. Often as I was walking to work I would think of some change I wanted to make to the software, and do it that day. This worked for bigger features as well. Even if something was going to take two weeks to write (few projects took longer), I knew I could see the effect in the software as soon as it was done.If I'd had to wait a year for the next release, I would have shelved most of these ideas, for a while at least. The thing about ideas, though, is that they lead to more ideas. Have you ever noticed that when you sit down to write something, half the ideas that end up in it are ones you thought of while writing it? The same thing happens with software. Working to implement one idea gives you more ideas. So shelving an idea costs you not only that delay in implementing it, but also all the ideas that implementing it would have led to. In fact, shelving an idea probably even inhibits new ideas: as you start to think of some new feature, you catch sight of the shelf and think "but I already have a lot of new things I want to do for the next release."What big companies do instead of implementing features is plan them. At Viaweb we sometimes ran into trouble on this account. Investors and analysts would ask us what we had planned for the future. The truthful answer would have been, we didn't have any plans. We had general ideas about things we wanted to improve, but if we knew how we would have done it already. What were we going to do in the next six months? Whatever looked like the biggest win. I don't know if I ever dared give this answer, but that was the truth. Plans are just another word for ideas on the shelf. When we thought of good ideas, we implemented them.At Viaweb, as at many software companies, most code had one definite owner. But when you owned something you really owned it: no one except the owner of a piece of software had to approve (or even know about) a release. There was no protection against breakage except the fear of looking like an idiot to one's peers, and that was more than enough. I may have given the impression that we just blithely plowed forward writing code. We did go fast, but we thought very carefully before we released software onto those servers. And paying attention is more important to reliability than moving slowly. Because he pays close attention, a Navy pilot can land a 40,000 lb. aircraft at 140 miles per hour on a pitching carrier deck, at night, more safely than the average teenager can cut a bagel.This way of writing software is a double-edged sword of course. It works a lot better for a small team of good, trusted programmers than it would for a big company of mediocre ones, where bad ideas are caught by committees instead of the people that had them.Brooks in ReverseFortunately, Web-based software does require fewer programmers. I once worked for a medium-sized desktop software company that had over 100 people working in engineering as a whole. Only 13 of these were in product development. All the rest were working on releases, ports, and so on. With Web-based software, all you need (at most) are the 13 people, because there are no releases, ports, and so on.Viaweb was written by just three people. [7] I was always under pressure to hire more, because we wanted to get bought, and we knew that buyers would have a hard time paying a high price for a company with only three programmers. (Solution: we hired more, but created new projects for them.)When you can write software with fewer programmers, it saves you more than money. As Fred Brooks pointed out in The Mythical Man-Month, adding people to a project tends to slow it down. The number of possible connections between developers grows exponentially with the size of the group. The larger the group, the more time they'll spend in meetings negotiating how their software will work together, and the more bugs they'll get from unforeseen interactions. Fortunately, this process also works in reverse: as groups get smaller, software development gets exponentially more efficient. I can't remember the programmers at Viaweb ever having an actual meeting. We never had more to say at any one time than we could say as we were walking to lunch.If there is a downside here, it is that all the programmers have to be to some degree system administrators as well. When you're hosting software, someone has to be watching the servers, and in practice the only people who can do this properly are the ones who wrote the software. At Viaweb our system had so many components and changed so frequently that there was no definite border between software and infrastructure. Arbitrarily declaring such a border would have constrained our design choices. And so although we were constantly hoping that one day ("in a couple months") everything would be stable enough that we could hire someone whose job was just to worry about the servers, it never happened.I don't think it could be any other way, as long as you're still actively developing the product. Web-based software is never going to be something you write, check in, and go home. It's a live thing, running on your servers right now. A bad bug might not just crash one user's process; it could crash them all. If a bug in your code corrupts some data on disk, you have to fix it. And so on. We found that you don't have to watch the servers every minute (after the first year or so), but you definitely want to keep an eye on things you've changed recently. You don't release code late at night and then go home.Watching UsersWith server-based software, you're in closer touch with your code. You can also be in closer touch with your users. Intuit is famous for introducing themselves to customers at retail stores and asking to follow them home. If you've ever watched someone use your software for the first time, you know what surprises must have awaited them.Software should do what users think it will. But you can't have any idea what users will be thinking, believe me, until you watch them. And server-based software gives you unprecedented information about their behavior. You're not limited to small, artificial focus groups. You can see every click made by every user. You have to consider carefully what you're going to look at, because you don't want to violate users' privacy, but even the most general statistical sampling can be very useful.When you have the users on your server, you don't have to rely on benchmarks, for example. Benchmarks are simulated users. With server-based software, you can watch actual users. To decide what to optimize, just log into a server and see what's consuming all the CPU. And you know when to stop optimizing too: we eventually got the Viaweb editor to the point where it was memory-bound rather than CPU-bound, and since there was nothing we could do to decrease the size of users' data (well, nothing easy), we knew we might as well stop there.Efficiency matters for server-based software, because you're paying for the hardware. The number of users you can support per server is the divisor of your capital cost, so if you can make your software very efficient you can undersell competitors and still make a profit. At Viaweb we got the capital cost per user down to about $5. It would be less now, probably less than the cost of sending them the first month's bill. Hardware is free now, if your software is reasonably efficient.Watching users can guide you in design as well as optimization. Viaweb had a scripting language called RTML that let advanced users define their own page styles. We found that RTML became a kind of suggestion box, because users only used it when the predefined page styles couldn't do what they wanted. Originally the editor put button bars across the page, for example, but after a number of users used RTML to put buttons down the left side, we made that an option (in fact the default) in the predefined page styles.Finally, by watching users you can often tell when they're in trouble. And since the customer is always right, that's a sign of something you need to fix. At Viaweb the key to getting users was the online test drive. It was not just a series of slides built by marketing people. In our test drive, users actually used the software. It took about five minutes, and at the end of it they had built a real, working store. The test drive was the way we got nearly all our new users. I think it will be the same for most Web-based applications. If users can get through a test drive successfully, they'll like the product. If they get confused or bored, they won't. So anything we could do to get more people through the test drive would increase our growth rate.I studied click trails of people taking the test drive and found that at a certain step they would get confused and click on the browser's Back button. (If you try writing Web-based applications, you'll find that the Back button becomes one of your most interesting philosophical problems.) So I added a message at that point, telling users that they were nearly finished, and reminding them not to click on the Back button. Another great thing about Web-based software is that you get instant feedback from changes: the number of people completing the test drive rose immediately from 60% to 90%. And since the number of new users was a function of the number of completed test drives, our revenue growth increased by 50%, just from that change.MoneyIn the early 1990s I read an article in which someone said that software was a subscription business. At first this seemed a very cynical statement. But later I realized that it reflects reality: software development is an ongoing process. I think it's cleaner if you openly charge subscription fees, instead of forcing people to keep buying and installing new versions so that they'll keep paying you. And fortunately, subscriptions are the natural way to bill for Web-based applications.Hosting applications is an area where companies will play a role that is not likely to be filled by freeware. Hosting applications is a lot of stress, and has real expenses. No one is going to want to do it for free.For companies, Web-based applications are an ideal source of revenue. Instead of starting each quarter with a blank slate, you have a recurring revenue stream. Because your software evolves gradually, you don't have to worry that a new model will flop; there never need be a new model, per se, and if you do something to the software that users hate, you'll know right away. You have no trouble with uncollectable bills; if someone won't pay you can just turn off the service. And there is no possibility of piracy.That last "advantage" may turn out to be a problem. Some amount of piracy is to the advantage of software companies. If some user really would not have bought your software at any price, you haven't lost anything if he uses a pirated copy. In fact you gain, because he is one more user helping to make your software the standard-- or who might buy a copy later, when he graduates from high school.When they can, companies like to do something called price discrimination, which means charging each customer as much as they can afford. [8] Software is particularly suitable for price discrimination, because the marginal cost is close to zero. This is why some software costs more to run on Suns than on Intel boxes: a company that uses Suns is not interested in saving money and can safely be charged more. Piracy is effectively the lowest tier of price discrimination. I think that software companies understand this and deliberately turn a blind eye to some kinds of piracy. [9] With server-based software they are going to have to come up with some other solution.Web-based software sells well, especially in comparison to desktop software, because it's easy to buy. You might think that people decide to buy something, and then buy it, as two separate steps. That's what I thought before Viaweb, to the extent I thought about the question at all. In fact the second step can propagate back into the first: if something is hard to buy, people will change their mind about whether they wanted it. And vice versa: you'll sell more of something when it's easy to buy. I buy more books because Amazon exists. Web-based software is just about the easiest thing in the world to buy, especially if you have just done an online demo. Users should not have to do much more than enter a credit card number. (Make them do more at your peril.) Sometimes Web-based software is offered through ISPs acting as resellers. This is a bad idea. You have to be administering the servers, because you need to be constantly improving both hardware and software. If you give up direct control of the servers, you give up most of the advantages of developing Web-based applications.Several of our competitors shot themselves in the foot this way-- usually, I think, because they were overrun by suits who were excited about this huge potential channel, and didn't realize that it would ruin the product they hoped to sell through it. Selling Web-based software through ISPs is like selling sushi through vending machines.CustomersWho will the customers be? At Viaweb they were initially individuals and smaller companies, and I think this will be the rule with Web-based applications. These are the users who are ready to try new things, partly because they're more flexible, and partly because they want the lower costs of new technology.Web-based applications will often be the best thing for big companies too (though they'll be slow to realize it). The best intranet is the Internet. If a company uses true Web-based applications, the software will work better, the servers will be better administered, and employees will have access to the system from anywhere.The argument against this approach usually hinges on security: if access is easier for employees, it will be for bad guys too. Some larger merchants were reluctant to use Viaweb because they thought customers' credit card information would be safer on their own servers. It was not easy to make this point diplomatically, but in fact the data was almost certainly safer in our hands than theirs. Who can hire better people to manage security, a technology startup whose whole business is running servers, or a clothing retailer? Not only did we have better people worrying about security, we worried more about it. If someone broke into the clothing retailer's servers, it would affect at most one merchant, could probably be hushed up, and in the worst case might get one person fired. If someone broke into ours, it could affect thousands of merchants, would probably end up as news on CNet, and could put us out of business.If you want to keep your money safe, do you keep it under your mattress at home, or put it in a bank? This argument applies to every aspect of server administration: not just security, but uptime, bandwidth, load management, backups, etc. Our existence depended on doing these things right. Server problems were the big no-no for us, like a dangerous toy would be for a toy maker, or a salmonella outbreak for a food processor.A big company that uses Web-based applications is to that extent outsourcing IT. Drastic as it sounds, I think this is generally a good idea. Companies are likely to get better service this way than they would from in-house system administrators. System administrators can become cranky and unresponsive because they're not directly exposed to competitive pressure: a salesman has to deal with customers, and a developer has to deal with competitors' software, but a system administrator, like an old bachelor, has few external forces to keep him in line. [10] At Viaweb we had external forces in plenty to keep us in line. The people calling us were customers, not just co-workers. If a server got wedged, we jumped; just thinking about it gives me a jolt of adrenaline, years later.So Web-based applications will ordinarily be the right answer for big companies too. They will be the last to realize it, however, just as they were with desktop computers. And partly for the same reason: it will be worth a lot of money to convince big companies that they need something more expensive.There is always a tendency for rich customers to buy expensive solutions, even when cheap solutions are better, because the people offering expensive solutions can spend more to sell them. At Viaweb we were always up against this. We lost several high-end merchants to Web consulting firms who convinced them they'd be better off if they paid half a million dollars for a custom-made online store on their own server. They were, as a rule, not better off, as more than one discovered when Christmas shopping season came around and loads rose on their server. Viaweb was a lot more sophisticated than what most of these merchants got, but we couldn't afford to tell them. At $300 a month, we couldn't afford to send a team of well-dressed and authoritative-sounding people to make presentations to customers.A large part of what big companies pay extra for is the cost of selling expensive things to them. (If the Defense Department pays a thousand dollars for toilet seats, it's partly because it costs a lot to sell toilet seats for a thousand dollars.) And this is one reason intranet software will continue to thrive, even though it is probably a bad idea. It's simply more expensive. There is nothing you can do about this conundrum, so the best plan is to go for the smaller customers first. The rest will come in time.Son of ServerRunning software on the server is nothing new. In fact it's the old model: mainframe applications are all server-based. If server-based software is such a good idea, why did it lose last time? Why did desktop computers eclipse mainframes?At first desktop computers didn't look like much of a threat. The first users were all hackers-- or hobbyists, as they were called then. They liked microcomputers because they were cheap. For the first time, you could have your own computer. The phrase "personal computer" is part of the language now, but when it was first used it had a deliberately audacious sound, like the phrase "personal satellite" would today.Why did desktop computers take over? I think it was because they had better software. And I think the reason microcomputer software was better was that it could be written by small companies.I don't think many people realize how fragile and tentative startups are in the earliest stage. Many startups begin almost by accident-- as a couple guys, either with day jobs or in school, writing a prototype of something that might, if it looks promising, turn into a company. At this larval stage, any significant obstacle will stop the startup dead in its tracks. Writing mainframe software required too much commitment up front. Development machines were expensive, and because the customers would be big companies, you'd need an impressive-looking sales force to sell it to them. Starting a startup to write mainframe software would be a much more serious undertaking than just hacking something together on your Apple II in the evenings. And so you didn't get a lot of startups writing mainframe applications.The arrival of desktop computers inspired a lot of new software, because writing applications for them seemed an attainable goal to larval startups. Development was cheap, and the customers would be individual people that you could reach through computer stores or even by mail-order.The application that pushed desktop computers out into the mainstream was VisiCalc, the first spreadsheet. It was written by two guys working in an attic, and yet did things no mainframe software could do. [11] VisiCalc was such an advance, in its time, that people bought Apple IIs just to run it. And this was the beginning of a trend: desktop computers won because startups wrote software for them.It looks as if server-based software will be good this time around, because startups will write it. Computers are so cheap now that you can get started, as we did, using a desktop computer as a server. Inexpensive processors have eaten the workstation market (you rarely even hear the word now) and are most of the way through the server market; Yahoo's servers, which deal with loads as high as any on the Internet, all have the same inexpensive Intel processors that you have in your desktop machine. And once you've written the software, all you need to sell it is a Web site. Nearly all our users came direct to our site through word of mouth and references in the press. [12]Viaweb was a typical larval startup. We were terrified of starting a company, and for the first few months comforted ourselves by treating the whole thing as an experiment that we might call off at any moment. Fortunately, there were few obstacles except technical ones. While we were writing the software, our Web server was the same desktop machine we used for development, connected to the outside world by a dialup line. Our only expenses in that phase were food and rent.There is all the more reason for startups to write Web-based software now, because writing desktop software has become a lot less fun. If you want to write desktop software now you do it on Microsoft's terms, calling their APIs and working around their buggy OS. And if you manage to write something that takes off, you may find that you were merely doing market research for Microsoft.If a company wants to make a platform that startups will build on, they have to make it something that hackers themselves will want to use. That means it has to be inexpensive and well-designed. The Mac was popular with hackers when it first came out, and a lot of them wrote software for it. [13] You see this less with Windows, because hackers don't use it. The kind of people who are good at writing software tend to be running Linux or FreeBSD now.I don't think we would have started a startup to write desktop software, because desktop software has to run on Windows, and before we could write software for Windows we'd have to use it. The Web let us do an end-run around Windows, and deliver software running on Unix direct to users through the browser. That is a liberating prospect, a lot like the arrival of PCs twenty-five years ago.MicrosoftBack when desktop computers arrived, IBM was the giant that everyone was afraid of. It's hard to imagine now, but I remember the feeling very well. Now the frightening giant is Microsoft, and I don't think they are as blind to the threat facing them as IBM was. After all, Microsoft deliberately built their business in IBM's blind spot.I mentioned earlier that my mother doesn't really need a desktop computer. Most users probably don't. That's a problem for Microsoft, and they know it. If applications run on remote servers, no one needs Windows. What will Microsoft do? Will they be able to use their control of the desktop to prevent, or constrain, this new generation of software?My guess is that Microsoft will develop some kind of server/desktop hybrid, where the operating system works together with servers they control. At a minimum, files will be centrally available for users who want that. I don't expect Microsoft to go all the way to the extreme of doing the computations on the server, with only a browser for a client, if they can avoid it. If you only need a browser for a client, you don't need Microsoft on the client, and if Microsoft doesn't control the client, they can't push users towards their server-based applications.I think Microsoft will have a hard time keeping the genie in the bottle. There will be too many different types of clients for them to control them all. And if Microsoft's applications only work with some clients, competitors will be able to trump them by offering applications that work from any client. [14]In a world of Web-based applications, there is no automatic place for Microsoft. They may succeed in making themselves a place, but I don't think they'll dominate this new world as they did the world of desktop applications.It's not so much that a competitor will trip them up as that they will trip over themselves. With the rise of Web-based software, they will be facing not just technical problems but their own wishful thinking. What they need to do is cannibalize their existing business, and I can't see them facing that. The same single-mindedness that has brought them this far will now be working against them. IBM was in exactly the same situation, and they could not master it. IBM made a late and half-hearted entry into the microcomputer business because they were ambivalent about threatening their cash cow, mainframe computing. Microsoft will likewise be hampered by wanting to save the desktop. A cash cow can be a damned heavy monkey on your back.I'm not saying that no one will dominate server-based applications. Someone probably will eventually. But I think that there will be a good long period of cheerful chaos, just as there was in the early days of microcomputers. That was a good time for startups. Lots of small companies flourished, and did it by making cool things.Startups but More SoThe classic startup is fast and informal, with few people and little money. Those few people work very hard, and technology magnifies the effect of the decisions they make. If they win, they win big.In a startup writing Web-based applications, everything you associate with startups is taken to an extreme. You can write and launch a product with even fewer people and even less money. You have to be even faster, and you can get away with being more informal. You can literally launch your product as three guys sitting in the living room of an apartment, and a server collocated at an ISP. We did.Over time the teams have gotten smaller, faster, and more informal. In 1960, software development meant a roomful of men with horn rimmed glasses and narrow black neckties, industriously writing ten lines of code a day on IBM coding forms. In 1980, it was a team of eight to ten people wearing jeans to the office and typing into vt100s. Now it's a couple of guys sitting in a living room with laptops. (And jeans turn out not to be the last word in informality.)Startups are stressful, and this, unfortunately, is also taken to an extreme with Web-based applications. Many software companies, especially at the beginning, have periods where the developers slept under their desks and so on. The alarming thing about Web-based software is that there is nothing to prevent this becoming the default. The stories about sleeping under desks usually end: then at last we shipped it and we all went home and slept for a week. Web-based software never ships. You can work 16-hour days for as long as you want to. And because you can, and your competitors can, you tend to be forced to. You can, so you must. It's Parkinson's Law running in reverse.The worst thing is not the hours but the responsibility. Programmers and system administrators traditionally each have their own separate worries. Programmers have to worry about bugs, and system administrators have to worry about infrastructure. Programmers may spend a long day up to their elbows in source code, but at some point they get to go home and forget about it. System administrators never quite leave the job behind, but when they do get paged at 4:00 AM, they don't usually have to do anything very complicated. With Web-based applications, these two kinds of stress get combined. The programmers become system administrators, but without the sharply defined limits that ordinarily make the job bearable.At Viaweb we spent the first six months just writing software. We worked the usual long hours of an early startup. In a desktop software company, this would have been the part where we were working hard, but it felt like a vacation compared to the next phase, when we took users onto our server. The second biggest benefit of selling Viaweb to Yahoo (after the money) was to be able to dump ultimate responsibility for the whole thing onto the shoulders of a big company.Desktop software forces users to become system administrators. Web-based software forces programmers to. There is less stress in total, but more for the programmers. That's not necessarily bad news. If you're a startup competing with a big company, it's good news. [15] Web-based applications offer a straightforward way to outwork your competitors. No startup asks for more.Just Good EnoughOne thing that might deter you from writing Web-based applications is the lameness of Web pages as a UI. That is a problem, I admit. There were a few things we would have really liked to add to HTML and HTTP. What matters, though, is that Web pages are just good enough.There is a parallel here with the first microcomputers. The processors in those machines weren't actually intended to be the CPUs of computers. They were designed to be used in things like traffic lights. But guys like Ed Roberts, who designed the Altair, realized that they were just good enough. You could combine one of these chips with some memory (256 bytes in the first Altair), and front panel switches, and you'd have a working computer. Being able to have your own computer was so exciting that there were plenty of people who wanted to buy them, however limited.Web pages weren't designed to be a UI for applications, but they're just good enough. And for a significant number of users, software that you can use from any browser will be enough of a win in itself to outweigh any awkwardness in the UI. Maybe you can't write the best-looking spreadsheet using HTML, but you can write a spreadsheet that several people can use simultaneously from different locations without special client software, or that can incorporate live data feeds, or that can page you when certain conditions are triggered. More importantly, you can write new kinds of applications that don't even have names yet. VisiCalc was not merely a microcomputer version of a mainframe application, after all-- it was a new type of application.Of course, server-based applications don't have to be Web-based. You could have some other kind of client. But I'm pretty sure that's a bad idea. It would be very convenient if you could assume that everyone would install your client-- so convenient that you could easily convince yourself that they all would-- but if they don't, you're hosed. Because Web-based software assumes nothing about the client, it will work anywhere the Web works. That's a big advantage already, and the advantage will grow as new Web devices proliferate. Users will like you because your software just works, and your life will be easier because you won't have to tweak it for every new client. [16]I feel like I've watched the evolution of the Web as closely as anyone, and I can't predict what's going to happen with clients. Convergence is probably coming, but where? I can't pick a winner. One thing I can predict is conflict between AOL and Microsoft. Whatever Microsoft's .NET turns out to be, it will probably involve connecting the desktop to servers. Unless AOL fights back, they will either be pushed aside or turned into a pipe between Microsoft client and server software. If Microsoft and AOL get into a client war, the only thing sure to work on both will be browsing the Web, meaning Web-based applications will be the only kind that work everywhere.How will it all play out? I don't know. And you don't have to know if you bet on Web-based applications. No one can break that without breaking browsing. The Web may not be the only way to deliver software, but it's one that works now and will continue to work for a long time. Web-based applications are cheap to develop, and easy for even the smallest startup to deliver. They're a lot of work, and of a particularly stressful kind, but that only makes the odds better for startups.Why Not?E. B. White was amused to learn from a farmer friend that many electrified fences don't have any current running through them. The cows apparently learn to stay away from them, and after that you don't need the current. "Rise up, cows!" he wrote, "Take your liberty while despots snore!"If you're a hacker who has thought of one day starting a startup, there are probably two things keeping you from doing it. One is that you don't know anything about business. The other is that you're afraid of competition. Neither of these fences have any current in them.There are only two things you have to know about business: build something users love, and make more than you spend. If you get these two right, you'll be ahead of most startups. You can figure out the rest as you go.You may not at first make more than you spend, but as long as the gap is closing fast enough you'll be ok. If you start out underfunded, it will at least encourage a habit of frugality. The less you spend, the easier it is to make more than you spend. Fortunately, it can be very cheap to launch a Web-based application. We launched on under $10,000, and it would be even cheaper today. We had to spend thousands on a server, and thousands more to get SSL. (The only company selling SSL software at the time was Netscape.) Now you can rent a much more powerful server, with SSL included, for less than we paid for bandwidth alone. You could launch a Web-based application now for less than the cost of a fancy office chair.As for building something users love, here are some general tips. Start by making something clean and simple that you would want to use yourself. Get a version 1.0 out fast, then continue to improve the software, listening closely to the users as you do. The customer is always right, but different customers are right about different things; the least sophisticated users show you what you need to simplify and clarify, and the most sophisticated tell you what features you need to add. The best thing software can be is easy, but the way to do this is to get the defaults right, not to limit users' choices. Don't get complacent if your competitors' software is lame; the standard to compare your software to is what it could be, not what your current competitors happen to have. Use your software yourself, all the time. Viaweb was supposed to be an online store builder, but we used it to make our own site too. Don't listen to marketing people or designers or product managers just because of their job titles. If they have good ideas, use them, but it's up to you to decide; software has to be designed by hackers who understand design, not designers who know a little about software. If you can't design software as well as implement it, don't start a startup.Now let's talk about competition. What you're afraid of is not presumably groups of hackers like you, but actual companies, with offices and business plans and salesmen and so on, right? Well, they are more afraid of you than you are of them, and they're right. It's a lot easier for a couple of hackers to figure out how to rent office space or hire sales people than it is for a company of any size to get software written. I've been on both sides, and I know. When Viaweb was bought by Yahoo, I suddenly found myself working for a big company, and it was like trying to run through waist-deep water.I don't mean to disparage Yahoo. They had some good hackers, and the top management were real butt-kickers. For a big company, they were exceptional. But they were still only about a tenth as productive as a small startup. No big company can do much better than that. What's scary about Microsoft is that a company so big can develop software at all. They're like a mountain that can walk.Don't be intimidated. You can do as much that Microsoft can't as they can do that you can't. And no one can stop you. You don't have to ask anyone's permission to develop Web-based applications. You don't have to do licensing deals, or get shelf space in retail stores, or grovel to have your application bundled with the OS. You can deliver software right to the browser, and no one can get between you and potential users without preventing them from browsing the Web.You may not believe it, but I promise you, Microsoft is scared of you. The complacent middle managers may not be, but Bill is, because he was you once, back in 1975, the last time a new way of delivering software appeared.Notes[1] Realizing that much of the money is in the services, companies building lightweight clients have usually tried to combine the hardware with an online service. This approach has not worked well, partly because you need two different kinds of companies to build consumer electronics and to run an online service, and partly because users hate the idea. Giving away the razor and making money on the blades may work for Gillette, but a razor is much smaller commitment than a Web terminal. Cell phone handset makers are satisfied to sell hardware without trying to capture the service revenue as well. That should probably be the model for Internet clients too. If someone just sold a nice-looking little box with a Web browser that you could use to connect through any ISP, every technophobe in the country would buy one.[2] Security always depends more on not screwing up than any design decision, but the nature of server-based software will make developers pay more attention to not screwing up. Compromising a server could cause such damage that ASPs (that want to stay in business) are likely to be careful about security.[3] In 1995, when we started Viaweb, Java applets were supposed to be the technology everyone was going to use to develop server-based applications. Applets seemed to us an old-fashioned idea. Download programs to run on the client? Simpler just to go all the way and run the programs on the server. We wasted little time on applets, but countless other startups must have been lured into this tar pit. Few can have escaped alive, or Microsoft could not have gotten away with dropping Java in the most recent version of Explorer.[4] This point is due to Trevor Blackwell, who adds "the cost of writing software goes up more than linearly with its size. Perhaps this is mainly due to fixing old bugs, and the cost can be more linear if all bugs are found quickly."[5] The hardest kind of bug to find may be a variant of compound bug where one bug happens to compensate for another. When you fix one bug, the other becomes visible. But it will seem as if the fix is at fault, since that was the last thing you changed.[6] Within Viaweb we once had a contest to describe the worst thing about our software. Two customer support people tied for first prize with entries I still shiver to recall. We fixed both problems immediately.[7] Robert Morris wrote the ordering system, which shoppers used to place orders. Trevor Blackwell wrote the image generator and the manager, which merchants used to retrieve orders, view statistics, and configure domain names etc. I wrote the editor, which merchants used to build their sites. The ordering system and image generator were written in C and C++, the manager mostly in Perl, and the editor in Lisp.[8] Price discrimination is so pervasive (how often have you heard a retailer claim that their buying power meant lower prices for you?) that I was surprised to find it was outlawed in the U.S. by the Robinson-Patman Act of 1936. This law does not appear to be vigorously enforced.[9] In No Logo, Naomi Klein says that clothing brands favored by "urban youth" do not try too hard to prevent shoplifting because in their target market the shoplifters are also the fashion leaders.[10] Companies often wonder what to outsource and what not to. One possible answer: outsource any job that's not directly exposed to competitive pressure, because outsourcing it will thereby expose it to competitive pressure.[11] The two guys were Dan Bricklin and Bob Frankston. Dan wrote a prototype in Basic in a couple days, then over the course of the next year they worked together (mostly at night) to make a more powerful version written in 6502 machine language. Dan was at Harvard Business School at the time and Bob nominally had a day job writing software. "There was no great risk in doing a business," Bob wrote, "If it failed it failed. No big deal."[12] It's not quite as easy as I make it sound. It took a painfully long time for word of mouth to get going, and we did not start to get a lot of press coverage until we hired a PR firm (admittedly the best in the business) for $16,000 per month. However, it was true that the only significant channel was our own Web site.[13] If the Mac was so great, why did it lose? Cost, again. Microsoft concentrated on the software business, and unleashed a swarm of cheap component suppliers on Apple hardware. It did not help, either, that suits took over during a critical period.[14] One thing that would help Web-based applications, and help keep the next generation of software from being overshadowed by Microsoft, would be a good open-source browser. Mozilla is open-source but seems to have suffered from having been corporate software for so long. A small, fast browser that was actively maintained would be a great thing in itself, and would probably also encourage companies to build little Web appliances.Among other things, a proper open-source browser would cause HTTP and HTML to continue to evolve (as e.g. Perl has). It would help Web-based applications greatly to be able to distinguish between selecting a link and following it; all you'd need to do this would be a trivial enhancement of HTTP, to allow multiple urls in a request. Cascading menus would also be good.If you want to change the world, write a new Mosaic. Think it's too late? In 1998 a lot of people thought it was too late to launch a new search engine, but Google proved them wrong. There is always room for something new if the current options suck enough. Make sure it works on all the free OSes first-- new things start with their users.[15] Trevor Blackwell, who probably knows more about this from personal experience than anyone, writes:"I would go farther in saying that because server-based software is so hard on the programmers, it causes a fundamental economic shift away from large companies. It requires the kind of intensity and dedication from programmers that they will only be willing to provide when it's their own company. Software companies can hire skilled people to work in a not-too-demanding environment, and can hire unskilled people to endure hardships, but they can't hire highly skilled people to bust their asses. Since capital is no longer needed, big companies have little to bring to the table."[16] In the original version of this essay, I advised avoiding Javascript. That was a good plan in 2001, but Javascript now works. Thanks to Sarah Harlin, Trevor Blackwell, Robert Morris, Eric Raymond, Ken Anderson, and Dan Giffin for reading drafts of this paper; to Dan Bricklin and Bob Frankston for information about VisiCalc; and again to Ken Anderson for inviting me to speak at BBN. You'll find this essay and 14 others in Hackers & Painters. Some Technical DetailsJapanese TranslationMicrosoft finally agreesGates Email

---

_분석일: 2025. 11. 29._
_수집일: 2025. 11. 28._