---
layout: essay
title: "Being Popular"
category: Mindset
difficulty: 중급
year: 
url_original: "https://paulgraham.com/popular.html"
---

## 요약 (Summary)

🎯 인기 있는 언어가 되려면?

✨ 핵심 내용 요약

Paul Graham이 분석합니다: 왜 어떤 프로그래밍 언어는 인기 있고 어떤 언어는 안 쓰일까요?

기술적 우수성만으로는 부족합니다. Lisp은 기술적으로 훌륭하지만 인기가 없습니다. 반면 PHP는 기술적으로 형편없지만 인기가 많습니다. 왜? **사용하기 쉽기 때문입니다**. PHP는 배우기 쉽고, 설치하기 쉽고, 웹 호스팅이 많습니다. 반면 Lisp은 어렵고, 설정이 복잡합니다. Graham의 통찰: 인기 = 기술력 + 접근성. 제품도 마찬가지입니다. 기술적으로 최고여도 사용하기 어려우면 실패합니다. iPhone이 성공한 이유: 기술 + 쉬운 사용.

**핵심 포인트**
• 기술력만으로는 인기를 얻을 수 없습니다
• 사용하기 쉬워야 합니다
• 접근성이 성공의 열쇠입니다

🚀 오늘 바로 실천해볼 한 가지
당신의 제품을 처음 쓰는 사람이 10분 안에 가치를 느낄 수 있나요? 아니라면 단순화하세요.

---

## 한국어 번역 (Korean Translation)

2001년 5월(

이 기사는 새로운 언어에 대한 일종의 사업 계획으로 작성되었습니다. 따라서 좋은 프로그래밍 언어의 가장 중요한 기능인 매우 강력한 추상화가 누락되었습니다(당연히 여기기 때문에).) 내 친구가 저명한 운영 체제 전문가에게 정말 좋은 프로그래밍 언어를 디자인하고 싶다고 말한 적이 있습니다.전문가는 그에게 프로그래밍 언어는 장점에 따라 인기를 얻거나 인기가 없어지는 것이 아니기 때문에 그의 언어가 아무리 좋아도 아무도 그것을 사용하지 않을 것이라고 말했습니다.적어도 그가 디자인한 언어에는 그런 일이 일어났습니다. 무엇이 언어를 대중적으로 만드는가?인기있는 언어는 인기를 얻을 자격이 있습니까?좋은 프로그래밍 언어를 정의하려고 노력할 가치가 있나요?어떻게 하시겠습니까? 이러한 질문에 대한 답은 해커를 관찰하고 그들이 원하는 것이 무엇인지 알아봄으로써 찾을 수 있다고 생각합니다.프로그래밍 언어는 해커를 위한 것이며, 프로그래밍 언어는 해커가 좋아할 경우에만 (표시적 의미론이나 컴파일러 설계 연습보다는) 프로그래밍 언어로서 좋습니다.1 인기의 메커니즘대부분의 사람들이 단지 장점만 보고 프로그래밍 언어를 선택하지 않는다는 것은 확실히 사실입니다.대부분의 프로그래머는 다른 사람이 어떤 언어를 사용해야 하는지 알려줍니다.그러나 나는 그러한 외부 요인이 프로그래밍 언어의 인기에 미치는 영향이 때때로 생각되는 것만큼 크지 않다고 생각합니다.더 큰 문제는 좋은 프로그래밍 언어에 대한 해커의 생각이 대부분의 언어 디자이너의 생각과 다르다는 것입니다. 둘 중에서 중요한 것은 해커의 의견입니다.프로그래밍 언어는 정리가 아닙니다.신발은 사람을 위해 설계된 도구이고, 신발이 사람의 발에 맞게 디자인되어야 하는 것처럼 신발도 사람의 강점과 약점에 맞게 디자인되어야 합니다.신발을 신을 때 끼어들면 불량 신발입니다. 아무리 조각품처럼 우아하더라도 대부분의 프로그래머는 좋은 언어와 나쁜 언어를 구별하지 못하는 것일 수 있습니다.하지만 이는 다른 도구와 크게 다르지 않습니다.좋은 언어를 디자인하려고 노력하는 것이 시간낭비라는 뜻은 아닙니다.전문 해커는 좋은 언어를 보면 그 언어를 말할 수 있고 그것을 사용할 것입니다.물론 전문 해커는 극소수입니다. 하지만 그 극소수가 좋은 소프트웨어를 모두 작성하고 그들의 영향력은 나머지 프로그래머들이 자신이 사용하는 언어를 사용하는 경향이 있을 정도입니다.실제로 그것은 단지 영향력이 아니라 명령입니다. 전문 해커는 상사나 교수진으로서 다른 프로그래머에게 어떤 언어를 사용할지 알려주는 바로 그 사람들입니다. 전문 해커의 의견은 프로그래밍 언어의 상대적인 인기를 결정하는 유일한 힘은 아닙니다. 레거시 소프트웨어(Cobol)와 과대 광고(Ada, Java)도 역할을 합니다. 그러나 장기적으로 볼 때 이것이 가장 강력한 힘이라고 생각합니다.초기의 임계량과 충분한 시간이 주어지면 프로그래밍 언어는 아마도 그만한 인기를 얻게 될 것입니다.그리고 실제 사용자의 피드백은 항상 개선으로 이어지기 때문에 인기는 좋은 언어와 나쁜 언어를 더욱 구분합니다.대중적인 언어가 그 수명 동안 얼마나 많이 변했는지 살펴보십시오.Perl과 Fortran은 극단적인 경우이지만 Lisp도 많이 바뀌었습니다.예를 들어 Lisp 1.5에는 매크로가 없었습니다.이는 나중에 MIT의 해커들이 Lisp를 사용하여 실제 프로그램을 작성하는 데 몇 년을 보낸 후에 발전했습니다.[1]그래서 언어가 좋아야 대중적이 되든, 대중적이 되어야 언어가 좋아진다고 생각합니다.그리고 좋은 상태를 유지하려면 인기를 유지해야 합니다.프로그래밍 언어의 최신 기술은 여전히 ​​존재하지 않습니다.그럼에도 불구하고 오늘날 우리가 가지고 있는 Lisp는 여전히 1980년대 중반 MIT에서 사용했던 것과 거의 같습니다. 왜냐하면 그때가 Lisp가 충분히 크고 까다로운 사용자 기반을 가졌던 마지막 시간이기 때문입니다. 물론 해커는 언어를 사용하기 전에 언어에 대해 알아야 합니다.그들은 어떻게 듣게 될까요?다른 해커로부터.그러나 다른 사람들이 그 언어에 대해 듣게 하려면 해당 언어를 사용하는 초기 해커 그룹이 있어야 합니다.궁금해요

이 그룹의 규모는 얼마나 커야 하는지;임계 질량을 만드는 사용자는 몇 명입니까?내 머리 꼭대기에서 나는 20이라고 말하고 싶습니다.어떤 언어에 20명의 개별 사용자가 있다면, 즉 스스로 사용하기로 결정한 20명의 사용자를 의미한다면 나는 그것이 진짜라고 생각합니다. 거기까지 가는 것은 쉽지 않습니다.20에서 1000으로 가는 것보다 0에서 20으로 가는 것이 더 어렵다고 해도 놀라지 않을 것입니다.초기 20명의 사용자를 확보하는 가장 좋은 방법은 아마도 트로이 목마를 사용하는 것입니다. 사람들에게 그들이 원하는 응용 프로그램을 제공하는 것입니다. 이 응용 프로그램은 우연히 새로운 언어로 작성되었습니다.2 외부 요인프로그래밍 언어의 인기에 영향을 미치는 한 가지 외부 요인을 인정하는 것부터 시작하겠습니다.인기를 얻으려면 프로그래밍 언어가 인기 있는 시스템의 스크립팅 언어여야 합니다.Fortran과 Cobol은 초기 IBM 메인프레임의 스크립팅 언어였습니다.C는 Unix의 스크립팅 언어였고 나중에는 Perl도 되었습니다.Tcl은 Tk의 스크립팅 언어입니다.Java와 Javascript는 웹 브라우저의 스크립팅 언어로 만들어졌습니다. Lisp는 대중적인 시스템의 스크립팅 언어가 아니기 때문에 대중적인 언어가 아닙니다.이것이 인기를 유지한 것은 MIT의 스크립팅 언어였던 1960년대와 1970년대로 거슬러 올라갑니다.당시의 많은 위대한 프로그래머들은 어느 시점에서 MIT와 연관되어 있었습니다.그리고 1970년대 초, C 이전에는 MacLisp라고 불리는 MIT의 Lisp 방언이 심각한 해커가 사용하고 싶어하는 유일한 프로그래밍 언어 중 하나였습니다. 오늘날 Lisp는 적당히 인기 있는 두 시스템인 Emacs와 Autocad의 스크립팅 언어입니다. 그런 이유로 저는 오늘날 수행되는 대부분의 Lisp 프로그래밍이 Emacs Lisp 또는 AutoLisp에서 수행된다고 생각합니다. 프로그래밍 언어는 고립되어 존재하지 않습니다.해킹하는 것은 타동사입니다. 해커는 일반적으로 무언가를 해킹하고 있습니다. 실제로 언어는 해킹하는 데 사용된 것과 관련하여 판단됩니다.따라서 대중적인 언어를 디자인하려면 언어 이상의 것을 제공하거나 기존 시스템의 스크립트 언어를 대체하도록 언어를 디자인해야 합니다. Common Lisp는 부분적으로 고아이기 때문에 인기가 없습니다.원래는 해킹할 시스템인 Lisp Machine이 함께 제공되었습니다.그러나 Lisp 머신(병렬 컴퓨터와 함께)은 1980년대에 범용 프로세서의 성능이 증가함에 따라 강세를 보였습니다.Common Lisp가 Unix용 좋은 스크립트 언어였다면 계속해서 인기를 끌었을 것입니다.슬프게도 이것은 지독하게 나쁜 상황입니다. 이 상황을 설명하는 한 가지 방법은 언어가 그 자체의 장점으로 판단되지 않는다고 말하는 것입니다.또 다른 견해는 프로그래밍 언어가 어떤 것의 스크립팅 언어가 아닌 이상 프로그래밍 언어가 아니라는 것입니다.이는 놀라운 일인 경우에만 불공평해 보입니다.나는 프로그래밍 언어가 구현을 갖기를 기대하는 것보다 더 불공평하다고 생각하지 않습니다.이는 프로그래밍 언어의 일부일 뿐입니다. 프로그래밍 언어에는 물론 좋은 구현이 필요하며 이는 무료여야 합니다.기업은 소프트웨어 비용을 지불하지만 개별 해커는 그렇지 않습니다. 유치해야 할 것은 해커입니다. 언어에도 이에 대한 책이 있어야 합니다.책은 얇고, 잘 쓰여지고, 좋은 예들로 가득 차 있어야 합니다.K&R이 여기에 이상적입니다.지금으로서는 언어에는 오라일리(O'Reilly)가 출판한 책이 있어야 한다고 말하고 싶습니다.이는 해커들에게 중요한 시험대가 되고 있습니다. 온라인 문서도 있어야 합니다.실제로 이 책은 온라인 문서로 시작할 수 있습니다.하지만 아직은 종이책이 시대에 뒤떨어졌다고 생각하지 않습니다.형식이 편리하고 게시자가 부과하는 사실상의 검열은 필터가 불완전하더라도 유용합니다.서점은 새로운 언어를 배우는 데 가장 중요한 장소 중 하나입니다.3 간결성모든 언어에 필요한 세 가지, 즉 무료 구현, 책, 해킹할 항목을 제공할 수 있다면 해커가 좋아할 언어를 어떻게 만들 수 있습니까? 해커가 좋아하는 것 중 하나는 간결함입니다.해커는 수학자나 모더니스트 건축가가 게으른 것과 마찬가지로 게으릅니다. 그들은 관련 없는 것을 싫어합니다.나

프로그램을 작성하려는 해커가 자신이 입력해야 하는 총 문자 수에 따라 적어도 무의식적으로 어떤 언어를 사용할지 결정한다고 해도 과언이 아닙니다.이것이 해커들이 생각하는 것과 정확히 다르다면, 언어 설계자는 마치 그것이 있는 것처럼 행동하는 것이 좋을 것입니다. 영어를 닮은 장황한 표현으로 사용자를 속이려는 것은 실수입니다.Cobol은 이 결함으로 악명 높습니다.해커는 z = x+yas 대신에 x를 y에 추가하여 자신의 지능에 대한 모욕과 신에 대한 죄 사이의 어떤 것을 쓰라는 요청을 고려할 것입니다. 때때로 Lisp는 car와 cdr 대신에 first와 Rest를 사용해야 한다고 말했습니다. 왜냐하면 그렇게 하면 프로그램을 더 쉽게 읽을 수 있기 때문입니다.아마 처음 몇 시간 동안은 그럴 거예요.그러나 해커는 car가 목록의 첫 번째 요소를 의미하고 cdr이 나머지 요소를 의미한다는 사실을 충분히 빨리 배울 수 있습니다.먼저 사용하고 나머지를 사용하면 타이핑이 50% 더 늘어납니다.그리고 길이도 다르기 때문에 car와 cdr이 호출될 때 인수가 연속된 줄에 정렬되지 않는 경우가 많습니다.페이지에서 코드가 어떻게 정렬되는지가 매우 중요하다는 것을 알았습니다.Lisp 코드가 가변 너비 글꼴로 설정되면 거의 읽을 수 없으며 친구들은 이것이 다른 언어에서도 마찬가지라고 말합니다. 간결성은 강력한 유형의 언어가 지는 곳 중 하나입니다.다른 모든 조건이 동일하다면 어느 누구도 많은 선언으로 프로그램을 시작하고 싶어하지 않습니다.암시적일 수 있는 것은 무엇이든 암시적이어야 합니다. 개별 토큰도 짧아야 합니다.Perl과 Common Lisp는 이 문제에 대해 서로 반대되는 입장을 취하고 있습니다.Perl 프로그램은 거의 암호처럼 밀도가 높지만 내장된 Common Lisp 연산자의 이름은 우스꽝스러울 정도로 길다.Common Lisp의 설계자는 아마도 사용자가 긴 이름을 입력할 수 있는 텍스트 편집기를 갖기를 기대했을 것입니다.그러나 긴 이름의 비용은 단지 이름을 입력하는 데 드는 비용만이 아닙니다.읽는 데 드는 비용과 화면에서 차지하는 공간에 대한 비용도 발생합니다.4 해킹 가능성 해커에게 간결함보다 더 중요한 것이 하나 있습니다. 바로 원하는 것을 수행할 수 있다는 것입니다.프로그래밍 언어의 역사에서 프로그래머가 부적절하다고 간주되는 작업을 수행하는 것을 방지하기 위해 놀라운 노력이 기울여졌습니다.이것은 위험할 정도로 주제넘은 계획이다.프로그래머가 무엇을 해야 하는지 언어 디자이너는 어떻게 알 수 있습니까?내 생각에 언어 디자이너는 대상 사용자를 자신으로부터 보호해야 하는 범법자보다는 자신이 예상하지 못한 일을 수행해야 하는 천재로 간주하는 것이 더 나을 것이라고 생각합니다.범블러는 어쨌든 발에 총을 쏠 것입니다.다른 패키지의 변수를 참조하는 일을 막을 수는 있지만, 잘못된 문제를 해결하기 위해 잘못 설계된 프로그램을 작성하고 그 일에 시간을 낭비하는 일을 막을 수는 없습니다. 좋은 프로그래머는 종종 위험하고 불미스러운 일을 하고 싶어합니다.불미스러운 것은 언어가 표현하려고 하는 의미론적 외관 뒤에 있는 것을 의미합니다. 예를 들어 일부 상위 수준 추상화의 내부 표현을 파악하는 것입니다.해커는 해킹을 좋아하며, 해킹이란 사물 내부로 들어가서 원래 디자이너를 다시 추측하는 것을 의미합니다. 자신이 다시 추측되도록 하십시오.도구를 만들면 사람들은 의도하지 않은 방식으로 도구를 사용하게 되며, 이는 특히 프로그래밍 언어와 같이 고도로 명확한 도구의 경우에 해당됩니다.많은 해커는 당신이 상상하지 못했던 방식으로 의미 체계 모델을 조정하고 싶어할 것입니다.나는 말한다.가비지 컬렉터와 같은 런타임 시스템을 위험에 빠뜨리지 않으면서 프로그래머가 가능한 한 많은 내부 항목에 액세스할 수 있도록 합니다. Common Lisp에서 저는 종종 구조체의 필드를 반복하고 싶었습니다. 예를 들어 삭제된 객체에 대한 참조를 찾아내거나 초기화되지 않은 필드를 찾는 것입니다.나는 구조체가 아래의 벡터라는 것을 알고 있습니다.하지만 아직은 어떤 구조체에서도 호출할 수 있는 범용 함수를 작성할 수 없습니다.이름으로만 필드에 액세스할 수 있습니다. 왜냐하면 그것이 구조체의 의미이기 때문입니다. 해커는 큰 프로그램에서 의도한 모델을 한두 번만 파괴하고 싶을 수도 있습니다.하지만 무슨

할 수 있다는 차이가 있습니다.그리고 이는 단순히 문제를 해결하는 것 이상의 문제일 수도 있습니다.여기에도 일종의 즐거움이 있습니다.해커들은 심한 내장을 찌르는 외과의사의 은밀한 즐거움과 여드름을 터뜨리는 십대의 은밀한 즐거움을 공유합니다.[2] 적어도 소년들에게는 특정한 종류의 공포가 매혹적입니다.Maxim 매거진은 핀업 사진과 소름 끼치는 사고가 혼합된 사진을 매년 발행합니다.그들은 청중을 알고 있습니다. 역사적으로 Lisp는 해커들이 원하는 대로 하도록 하는 데 능숙했습니다.Common Lisp의 정치적 정확성은 일탈입니다.초기 Lisps를 사용하면 모든 것을 손에 넣을 수 있습니다.다행스럽게도 그 정신의 상당 부분이 매크로에 보존되어 있습니다.소스 코드를 임의로 변환할 수 있다는 것은 정말 멋진 일입니다. 클래식 매크로는 단순하고 강력하며 위험한 진정한 해커 도구입니다.그들이 하는 일을 이해하는 것은 매우 쉽습니다. 매크로의 인수에 대해 함수를 호출하면 함수가 반환하는 모든 것이 매크로 호출 대신 삽입됩니다.위생적인 매크로는 반대 원칙을 구현합니다.그들은 자신들이 하고 있는 일을 당신이 이해하지 못하도록 보호하려고 합니다.위생적인 매크로를 한 문장으로 설명하는 것을 들어본 적이 없습니다.그리고 이는 프로그래머가 무엇을 원하는지 결정할 때의 위험성을 보여주는 전형적인 예입니다.위생적인 매크로는 무엇보다도 변수 캡처로부터 나를 보호하기 위한 것이지만 변수 캡처는 일부 매크로에서 정확히 내가 원하는 것입니다. 정말 좋은 언어는 깨끗하면서도 지저분해야 합니다. 잘 이해되고 고도로 직교하는 연산자의 작은 핵심으로 깔끔하게 설계되었지만 해커가 마음대로 사용할 수 있다는 점에서는 더럽습니다.C는 이렇습니다.초기 Lisp도 마찬가지였습니다.실제 해커의 언어에는 항상 약간의 엉뚱한 성격이 있습니다. 좋은 프로그래밍 언어는 "소프트웨어 엔지니어링"이라는 문구를 사용하는 사람들이 못마땅하게 고개를 저게 만드는 기능을 갖추고 있어야 합니다.연속체의 반대쪽 끝에는 Ada 및 Pascal과 같은 언어가 있는데, 이는 가르치는 데 적합하고 다른 것은 많지 않은 타당성 모델입니다.5 일회용 프로그램 해커에게 매력적이려면 언어가 그들이 작성하고 싶은 종류의 프로그램을 작성하는 데 적합해야 합니다.이는 아마도 놀랍게도 일회용 프로그램을 작성하는 데 적합해야 한다는 것을 의미합니다. 일회용 프로그램은 일부 제한된 작업을 위해 빠르게 작성하는 프로그램입니다. 일부 시스템 관리 작업을 자동화하거나 시뮬레이션을 위한 테스트 데이터를 생성하거나 데이터를 한 형식에서 다른 형식으로 변환하는 프로그램입니다.일회용 프로그램의 놀라운 점은 제2차 세계대전 당시 수많은 미국 대학에 건설된 '임시' 건물처럼 이 건물도 종종 버려지지 않는다는 것입니다.많은 것들이 실제 기능과 실제 사용자를 갖춘 실제 프로그램으로 진화합니다. 저는 최고의 대형 프로그램이 후버 댐처럼 처음부터 크게 설계되기보다는 이런 식으로 시작된다는 예감이 듭니다.처음부터 큰 것을 만드는 것은 무서운 일입니다.사람들은 너무 큰 프로젝트를 맡게 되면 압도당하게 됩니다.프로젝트가 정체되거나 결과는 무미건조하고 무미건조합니다. 실제 시내가 아닌 쇼핑몰, 로마가 아닌 브라질리아, C가 아닌 Ada가 됩니다. 큰 프로그램을 얻는 또 다른 방법은 일회용 프로그램으로 시작하여 계속 개선하는 것입니다.이 접근 방식은 덜 까다롭고 프로그램 설계는 발전을 통해 이점을 얻습니다.내 생각에, 살펴보면 대부분의 대형 프로그램이 개발된 방식이 이것이었을 것이라고 생각합니다.그리고 이런 식으로 발전한 것들은 아마도 처음에 작성된 언어로 여전히 작성되었을 것입니다. 왜냐하면 정치적인 이유를 제외하고는 프로그램이 이식되는 경우가 거의 없기 때문입니다.따라서 역설적이게도 큰 시스템에 사용되는 언어를 만들고 싶다면 이를 일회용 프로그램 작성에 적합하게 만들어야 합니다. 왜냐하면 그것이 큰 시스템이 나오는 곳이기 때문입니다. Perl은 이러한 아이디어의 놀라운 예입니다.이는 일회용 프로그램을 작성하기 위해 설계되었을 뿐만 아니라 그 자체로도 거의 일회용 프로그램이었습니다.Perl은 보고서 생성을 위한 유틸리티 모음으로 시작되었습니다.

s, 사람들이 작성한 일회용 프로그램이 더 커지면서 프로그래밍 언어로 진화했습니다.Perl 5가 나오기 전까지는 언어가 진지한 프로그램을 작성하는 데 적합하지 않았지만 이미 엄청난 인기를 얻었습니다. 언어가 일회용 프로그램에 좋은 이유는 무엇입니까?우선, 쉽게 사용할 수 있어야 합니다.일회용 프로그램은 한 시간 안에 작성할 것으로 예상되는 프로그램입니다.따라서 사용 중인 컴퓨터에 해당 언어가 이미 설치되어 있어야 합니다.사용하기 전에 설치해야 할 것은 없습니다.거기에 있어야합니다.C는 운영 체제와 함께 제공되었기 때문에 거기에 있었습니다.Perl은 원래 시스템 관리자를 위한 도구였고 이미 설치되어 있었기 때문에 존재했습니다. 그러나 사용 가능하다는 것은 설치된다는 것 이상의 의미를 갖습니다.명령줄 인터페이스를 갖춘 대화형 언어는 별도로 컴파일하고 실행해야 하는 언어보다 더 유용합니다.널리 사용되는 프로그래밍 언어는 대화형이어야 하며 빠르게 시작되어야 합니다. 일회용 프로그램에서 원하는 또 다른 것은 간결함입니다.간결함은 해커들에게 항상 매력적이며, 그들이 한 시간 안에 나올 것으로 기대하는 프로그램보다 더 매력적이지는 않습니다.6 라이브러리물론 간결함의 궁극적인 방법은 프로그램을 이미 작성해 두고 단지 호출하기만 하면 된다는 것입니다.그리고 이것은 프로그래밍 언어의 점점 더 중요한 기능인 라이브러리 기능이 될 것이라고 생각합니다.Perl은 문자열을 조작하기 위한 대규모 라이브러리를 갖고 있기 때문에 승리합니다.이 클래스의 라이브러리 함수는 원래 데이터 변환이나 추출을 위해 작성된 일회용 프로그램에 특히 중요합니다.많은 Perl 프로그램은 아마도 몇 개의 라이브러리 호출이 서로 붙어 있는 것으로 시작될 것입니다. 나는 향후 50년 동안 프로그래밍 언어에서 일어날 많은 발전이 라이브러리 기능과 관련이 있을 것이라고 생각합니다.미래의 프로그래밍 언어에는 핵심 언어만큼 세심하게 설계된 라이브러리가 있을 것이라고 생각합니다.프로그래밍 언어 디자인은 언어를 강력하게 또는 약한 형식으로 만들 것인지, 객체 지향적으로 만들 것인지, 기능적으로 만들 것인지에 관한 것이 아니라 훌륭한 라이브러리를 디자인하는 방법에 관한 것입니다.유형 시스템을 디자인하는 방법에 대해 생각하고 싶어하는 언어 디자이너는 이것에 몸서리칠 수 있습니다.마치 신청서를 작성하는 것과 거의 같습니다!안타깝네요.언어는 프로그래머를 위한 것이고, 라이브러리는 프로그래머에게 필요한 것입니다. 좋은 라이브러리를 디자인하는 것은 어렵습니다.단순히 코드를 많이 작성하는 문제가 아닙니다.라이브러리가 너무 커지면 코드를 직접 작성하는 것보다 필요한 기능을 찾는 데 시간이 더 걸릴 수 있습니다.라이브러리는 핵심 언어와 마찬가지로 작은 직교 연산자 집합을 사용하여 설계해야 합니다.프로그래머는 어떤 라이브러리 호출이 자신에게 필요한 작업을 수행할지 추측할 수 있어야 합니다. 라이브러리는 Common Lisp가 부족한 부분 중 하나입니다.문자열을 조작하기 위한 기본적인 라이브러리만 있고 운영 체제와 통신하기 위한 라이브러리는 거의 없습니다.역사적인 이유로 Common Lisp는 OS가 존재하지 않는 척하려고 합니다.그리고 OS와 대화할 수 없기 때문에 Common Lisp에 내장된 연산자만 사용하여 심각한 프로그램을 작성할 가능성은 거의 없습니다.일부 구현별 해킹도 사용해야 하며 실제로는 원하는 모든 것을 제공하지 못하는 경향이 있습니다.해커들은 Common Lisp에 강력한 문자열 라이브러리와 좋은 OS 지원이 있다면 Lisp를 훨씬 더 높이 평가할 것입니다.7 구문 Lisp의 구문이 있는 언어, 더 정확하게는 구문이 부족한 언어가 대중화될 수 있을까요?나는 이 질문에 대한 답을 모른다.나는 Lisp가 현재 인기가 없는 주된 이유가 구문이 아니라고 생각합니다.Common Lisp에는 익숙하지 않은 구문보다 더 심각한 문제가 있습니다.나는 접두사 구문에 익숙하지만 기본적으로 Perl을 사용하는 프로그래머를 알고 있습니다. 왜냐하면 Perl은 강력한 문자열 라이브러리를 갖고 있고 OS와 통신할 수 있기 때문입니다. 접두사 표기법에는 두 가지 문제가 있을 수 있습니다. 프로그래머에게 익숙하지 않다는 것과 충분히 조밀하지 않다는 것입니다.Lisp 세계의 전통적인 통념은 최초의 프로

흠은 진짜입니다.잘 모르겠습니다.그렇습니다. 접두사 표기법은 일반 프로그래머를 당황하게 만듭니다.하지만 저는 일반 프로그래머의 의견은 중요하지 않다고 생각합니다.언어는 전문 해커가 어떻게 생각하느냐에 따라 인기가 있을 수도 있고 인기가 없을 수도 있는데, 전문 해커라면 접두사 표기법을 다룰 수 있지 않을까 생각합니다.Perl 구문은 꽤 이해하기 어려울 수 있지만 이것이 Perl의 인기를 방해하지는 않습니다.오히려 Perl 숭배를 조장하는 데 도움이 되었을 수도 있습니다. 더 심각한 문제는 접두사 표기법이 널리 퍼져 있다는 것입니다.전문 해커에게는 이것이 정말 문제입니다.a[x,y]를 쓸 수 있는데 (aref a x y)를 쓰고 싶어하는 사람은 없습니다. 이 특별한 경우에는 문제에서 벗어날 수 있는 방법이 있습니다.데이터 구조를 인덱스의 함수인 것처럼 처리하면 Perl 형식보다 훨씬 짧은 (a x y)를 대신 쓸 수 있습니다.유사한 트릭을 사용하면 다른 유형의 표현식도 단축할 수 있습니다. 들여쓰기를 중요하게 만들어 많은 괄호를 제거(또는 선택적으로 만들)할 수 있습니다.어쨌든 이것이 프로그래머가 코드를 읽는 방법입니다. 들여쓰기가 한 가지를 말하고 구분 기호가 다른 것을 말하는 경우 우리는 들여쓰기를 따릅니다.들여쓰기를 중요한 것으로 처리하면 이러한 일반적인 버그 소스가 제거되고 프로그램이 더 짧아질 수 있습니다. 때로는 중위 구문이 읽기 더 쉽습니다.이는 수학 표현식의 경우 특히 그렇습니다.나는 프로그래밍 생활 내내 Lisp를 사용해 왔지만 여전히 접두사 수학 표현이 자연스럽다고 생각하지 않습니다.그럼에도 불구하고 특히 코드를 생성할 때 임의 개수의 인수를 취하는 연산자를 갖는 것이 편리합니다.따라서 중위 구문이 있다면 일종의 읽기 매크로로 구현되어야 할 것입니다. Lisp가 잘 이해되는 방식으로 기본 s-표현식으로 변환되는 한 Lisp에 구문을 도입하는 것을 종교적으로 반대해서는 안 된다고 생각합니다.Lisp에는 이미 많은 구문이 있습니다.누구도 강제로 사용하지 않는 한, 더 많이 도입하는 것이 반드시 나쁜 것은 아닙니다.Common Lisp에서는 일부 구분 기호가 언어용으로 예약되어 있는데, 이는 적어도 디자이너 중 일부가 미래에 더 많은 구문을 사용하려고 했음을 나타냅니다. Common Lisp에서 가장 심각하게 명확하지 않은 구문 중 하나는 형식 문자열에서 발생합니다.형식은 그 자체로 언어이며 해당 언어는 Lisp가 아닙니다.Lisp에 더 많은 구문을 도입하려는 계획이 있다면 형식 지정자가 포함될 수 있습니다.매크로가 다른 종류의 코드를 생성하는 방식으로 형식 지정자를 생성할 수 있다면 좋을 것입니다. 저명한 Lisp 해커는 자신의 CLTL 사본이 섹션 형식에 공개되어 있다고 말했습니다.내 것도요.이는 아마도 개선의 여지가 있음을 나타냅니다.이는 또한 프로그램이 많은 I/O를 수행한다는 것을 의미할 수도 있습니다.8 효율성좋은 언어는 모두가 알고 있듯이 빠른 코드를 생성해야 합니다.그러나 실제로 나는 빠른 코드가 주로 언어 설계에서 수행하는 작업에서 비롯된다고 생각하지 않습니다.Knuth가 오래 전에 지적했듯이 속도는 특정한 중요한 병목 현상에서만 중요합니다.그 이후로 많은 프로그래머들이 관찰한 것처럼 이러한 병목 현상이 어디에 있는지에 대해 오해하는 경우가 많습니다. 따라서 실제로 빠른 코드를 얻는 방법은 언어를 강력한 형식으로 만드는 것보다 매우 좋은 프로파일러를 갖는 것입니다.프로그램의 모든 호출에서 모든 인수의 유형을 알 필요는 없습니다.병목 현상에서 인수 유형을 선언할 수 있어야 합니다.그리고 더 나아가 병목 현상이 발생하는 위치를 알아낼 수 있어야 합니다. Lisp에 대한 사람들의 불만 중 하나는 무엇이 비용이 많이 드는지 알기 어렵다는 것입니다.이것은 사실일 수도 있습니다.매우 추상적인 언어를 원한다면 불가피할 수도 있습니다.그리고 어쨌든 나는 좋은 프로파일링이 문제를 해결하는 데 큰 도움이 될 것이라고 생각합니다. 무엇이 비용이 많이 드는지 곧 알게 될 것입니다. 여기서 문제의 일부는 사회적입니다.언어 디자이너는 빠른 컴파일러를 작성하는 것을 좋아합니다.그것이 그들이 자신의 실력을 측정하는 방법입니다.그들은 프로파일러를 기껏해야 추가 기능으로 생각합니다.그러나 실제로 좋은 프로파일러는 fa를 생성하는 컴파일러보다 언어로 작성된 실제 프로그램의 속도를 향상시키는 데 더 많은 일을 할 수 있습니다.

세인트 코드.여기서도 언어 디자이너는 사용자와 어느 정도 접촉이 없습니다.그들은 잘못된 문제를 약간 해결하는 일을 정말 잘합니다. 프로그래머가 요청할 때까지 기다리는 대신 성능 데이터를 프로그래머에게 전달하는 활성 프로파일러를 갖는 것이 좋은 생각일 수 있습니다.예를 들어, 프로그래머가 소스 코드를 편집할 때 편집기는 병목 현상을 빨간색으로 표시할 수 있습니다.또 다른 접근 방식은 실행 중인 프로그램에서 일어나는 일을 어떻게든 표현하는 것입니다.이는 살펴봐야 할 실행 중인 프로그램이 많은 서버 기반 응용 프로그램에서 특히 큰 이점이 될 것입니다.활성 프로파일러는 프로그램이 실행될 때 메모리에서 일어나는 일을 그래픽으로 표시하거나 심지어 무슨 일이 일어나고 있는지 알려주는 소리를 낼 수도 있습니다. 소리는 문제에 대한 좋은 신호입니다.제가 일했던 한 곳에서는 웹 서버에 무슨 일이 일어나고 있는지 보여주는 커다란 다이얼 보드가 있었습니다.손은 회전할 때 약간의 소음을 내는 작은 서보모터에 의해 움직였습니다.책상에서 보드를 볼 수는 없었지만 서버에 문제가 있을 때 소리를 통해 즉시 알 수 있다는 것을 알았습니다. 비효율적인 알고리즘을 자동으로 감지하는 프로파일러를 작성하는 것도 가능할 수도 있습니다.메모리 액세스의 특정 패턴이 잘못된 알고리즘의 확실한 징후로 판명되더라도 나는 놀라지 않을 것입니다.우리 프로그램을 실행하는 컴퓨터 내부를 돌아다니는 작은 사람이 있다면, 그 사람은 아마도 연방 정부 직원이라는 직업에 관해 길고 애처로운 이야기를 들려줄 것입니다.나는 종종 프로세서를 엄청나게 쫓고 있다는 느낌을 받았지만 그것이 무엇을 하고 있는지 살펴볼 좋은 방법이 없었습니다. 이제 많은 Lisps가 바이트 코드로 컴파일된 다음 인터프리터에 의해 실행됩니다.이는 일반적으로 구현을 더 쉽게 이식하기 위해 수행되지만 유용한 언어 기능이 될 수 있습니다.바이트 코드를 언어의 공식 부분으로 만들고 프로그래머가 병목 현상이 발생할 때 인라인 바이트 코드를 사용할 수 있도록 허용하는 것은 좋은 생각일 수 있습니다.그러면 이러한 최적화도 이식 가능합니다. 최종 사용자가 인식하는 속도의 특성은 변할 수 있습니다.서버 기반 애플리케이션이 증가하면서 점점 더 많은 프로그램이 I/O 바인딩되는 것으로 드러날 수 있습니다.I/O를 빠르게 만드는 것은 가치가 있습니다.이 언어는 간단하고 빠르며 형식화된 출력 기능과 같은 간단한 측정뿐만 아니라 캐싱 및 영구 개체와 같은 심층적인 구조 변경에도 도움이 될 수 있습니다. 사용자는 응답 시간에 관심이 있습니다.그러나 또 다른 종류의 효율성, 즉 프로세서당 지원할 수 있는 동시 사용자 수는 점점 더 중요해질 것입니다.가까운 미래에 작성되는 많은 흥미로운 애플리케이션은 서버 기반이 될 것이며, 서버당 사용자 수는 그러한 애플리케이션을 호스팅하는 사람에게 중요한 질문입니다.서버 기반 애플리케이션을 제공하는 기업의 자본 비용에서 이것이 제수입니다. 수년 동안 대부분의 최종 사용자 애플리케이션에서 효율성은 그다지 중요하지 않았습니다.개발자들은 각 사용자가 책상 위에 점점 더 강력한 프로세서를 갖게 될 것이라고 가정할 수 있었습니다.그리고 파킨슨의 법칙에 따라 소프트웨어는 사용 가능한 리소스를 사용하도록 확장되었습니다.서버 기반 애플리케이션에서는 이러한 상황이 바뀔 것입니다.그 세계에서는 하드웨어와 소프트웨어가 함께 공급됩니다.서버 기반 응용 프로그램을 제공하는 회사의 경우 서버당 지원할 수 있는 사용자 수에 따라 수익이 크게 달라집니다. 일부 응용 프로그램에서는 프로세서가 제한 요소가 되며 실행 속도는 최적화하는 데 가장 중요한 요소입니다.그러나 종종 기억력이 한계가 될 것입니다.동시 사용자 수는 각 사용자의 데이터에 필요한 메모리 양에 따라 결정됩니다.여기서도 언어가 도움이 될 수 있습니다.스레드를 잘 지원하면 모든 사용자가 단일 힙을 공유할 수 있습니다.지연 로딩을 위한 지속적인 객체 및/또는 언어 수준 지원을 갖는 것도 도움이 될 수 있습니다.9 시간 대중적인 언어에 필요한 마지막 요소는 시간입니다.많은 프로그래밍 언어처럼 사라질 수 있는 언어로 프로그램을 작성하고 싶어하는 사람은 아무도 없습니다.

그렇죠.따라서 대부분의 해커는 언어가 존재하게 될 때까지 몇 년 정도 기다린 후 사용을 고려하는 경향이 있습니다. 놀라운 새로운 것을 발명한 사람들은 종종 이를 발견하고 놀라지만, 사람들에게 메시지를 전달하려면 시간이 필요합니다.내 친구는 누군가가 그에게 처음 요청하면 거의 아무 것도 하지 않습니다.그는 사람들이 때때로 원하지 않는 것을 요구한다는 것을 알고 있습니다.시간 낭비를 피하기 위해 그는 세 번째나 네 번째로 어떤 일을 하라는 요청을 받을 때까지 기다립니다.그때쯤이면 그에게 묻는 사람은 상당히 짜증이 날 수도 있지만 적어도 그들은 자신이 요구하는 것이 무엇이든 정말로 원할 것입니다. 대부분의 사람들은 자신이 듣는 새로운 것에 대해 비슷한 종류의 필터링을 수행하는 방법을 배웠습니다.그들은 어떤 것에 대해 열 번 듣기 전까지는 주의를 기울이기 시작하지도 않습니다.그들은 완벽하게 정당화됩니다. 최신의 새로운 것의 대부분은 시간 낭비로 판명되고 결국 사라집니다.VRML 학습을 연기함으로써 나는 VRML을 전혀 배울 필요가 없게 되었습니다. 따라서 새로운 것을 발명하는 사람은 사람들이 그것을 이해하기 시작하기까지 몇 년 동안 메시지를 계속 반복해야 합니다.내가 아는 한, 우리는 최초의 웹 서버 기반 애플리케이션을 작성했고 다운로드할 필요가 없다는 사실을 사람들에게 전달하는 데 수년이 걸렸습니다.그들이 멍청해서가 아니었습니다.그들은 단지 우리를 무시했습니다. 좋은 소식은 간단한 반복으로 문제가 해결된다는 것입니다.당신이 해야 할 일은 계속해서 이야기를 하는 것뿐입니다. 그러면 결국 사람들은 듣기 시작할 것입니다.사람들이 주의를 기울이는 것은 당신이 거기에 있다는 것을 알아차릴 때가 아닙니다.그것은 그들이 당신이 여전히 거기에 있다는 것을 알아차릴 때입니다. 일반적으로 추진력을 얻는 데 시간이 걸리는 것도 마찬가지입니다.대부분의 기술은 처음 출시된 후에도 상당한 발전을 이루었습니다. 특히 프로그래밍 언어는 더욱 그렇습니다.새로운 기술의 경우 소수의 얼리 어답터만이 몇 년간 사용하는 것보다 더 나은 것은 없습니다.얼리 어답터는 정교하고 까다로우며 기술에 남아 있는 결함을 신속하게 제거합니다.소수의 사용자만 있으면 모든 사용자와 긴밀한 접촉을 할 수 있습니다.그리고 얼리 어답터들은 시스템을 개선하면 일부 손상이 발생하더라도 관대합니다. 새로운 기술을 도입하는 방법에는 두 가지가 있습니다: 유기적 성장 방식과 빅뱅 방식입니다.유기적 성장 방법은 자금이 부족한 전형적인 차고 스타트업의 예시입니다.무명에서 일하는 두 사람이 새로운 기술을 개발합니다.그들은 마케팅 없이 이를 출시했으며 처음에는 소수의(열광적으로 헌신적인) 사용자만 보유했습니다.그들은 계속해서 기술을 개선하는 동시에 입소문을 통해 사용자 기반을 확대하고 있습니다.다른 접근 방식인 빅뱅 방법의 예로는 VC의 지원을 받고 마케팅 활동이 활발한 스타트업이 있습니다.그들은 서둘러 제품을 개발하고, 이를 출시하여 큰 주목을 받게 되면 즉시 (그들이 희망하는) 대규모 사용자 기반을 갖게 됩니다. 일반적으로 차고 사람들은 빅뱅 사람들을 부러워합니다.빅뱅 사람들은 매끄럽고 자신감이 넘치며 VC들로부터 존경을 받습니다.그들은 모든 것의 최고를 감당할 수 있고, 출시를 둘러싼 홍보 캠페인은 그들을 유명인으로 만드는 부작용을 가지고 있습니다.차고에 앉아 있는 유기적 성장가들은 가난하고 사랑받지 못한다고 느낍니다.그럼에도 불구하고 그들은 종종 자신을 불쌍히 여기는 오해를 받는 것 같습니다.유기적 성장은 빅뱅 방식보다 더 나은 기술과 더 부유한 창업자를 낳는 것 같습니다.오늘날 지배적인 기술을 살펴보면 대부분 유기적으로 성장했다는 것을 알 수 있습니다. 이러한 패턴은 기업에만 적용되는 것이 아닙니다.후원 연구에서도 이를 볼 수 있습니다.Multics와 Common Lisp는 대규모 프로젝트였으며 Unix와 MacLisp는 유기적 성장 프로젝트였습니다.10 Redesign E. B. White는 "가장 좋은 글쓰기는 다시 쓰는 것입니다"라고 썼습니다.훌륭한 작가라면 누구나 이것을 알고 있으며 이는 소프트웨어에도 적용됩니다.디자인에서 가장 중요한 부분은 리디자인이다.특히 프로그래밍 언어는 충분히 재설계되지 않습니다. 좋은 소프트웨어를 작성하려면 두 가지 반대되는 아이디어를 동시에 머릿속에 유지해야 합니다.안녕에 대한 젊은 해커의 순진한 믿음이 필요합니다.

능력과 동시에 베테랑의 회의감.얼마나 어려울 수 있는지 생각할 수 있어야합니까?두뇌의 절반은 결코 작동하지 않을 것이라고 생각하면서 다른 절반은 작동하지 않습니다. 비결은 여기에 실제 모순이 없다는 것을 깨닫는 것입니다.당신은 두 가지 다른 것에 대해 낙관적이면서도 회의적이기를 원합니다.문제 해결의 가능성에 대해서는 낙관해야 하지만, 지금까지 얻은 해결책의 가치에 대해서는 회의적이어야 합니다. 좋은 일을 하는 사람들은 종종 자신이 하고 있는 일이 무엇이든 좋지 않다고 생각합니다.다른 사람들은 자신이 한 일을 보고 놀라지만, 창조자는 걱정으로 가득 차 있습니다.이 패턴은 우연이 아닙니다. 걱정이 일을 좋게 만들었습니다. 희망과 걱정의 균형을 유지할 수 있다면 두 다리가 자전거를 앞으로 나아가는 것처럼 프로젝트도 앞으로 나아갈 것입니다.2주기 혁신 엔진의 첫 번째 단계에서는 어떤 문제를 해결할 수 있다는 자신감을 갖고 어떤 문제에 대해 맹렬하게 노력합니다.두 번째 단계에서는 아침의 차가운 빛 속에서 자신이 한 일을 살펴보고 그 모든 결점을 아주 분명하게 봅니다.그러나 비판적 정신이 희망을 능가하지 않는 한, 불완전하다고 인정되는 시스템을 보면서 나머지 방법을 찾는 것이 얼마나 어려울 수 있는지 생각하여 순환을 계속할 수 있습니다. 두 힘의 균형을 유지하는 것은 까다롭습니다.젊은 해커들에게는 낙관주의가 우세합니다.그들은 무언가를 생산하고 그것이 훌륭하다고 확신하지만 결코 개선하지 않습니다.오래된 해커들에게는 회의론이 지배적이며 야심찬 프로젝트에 감히 착수조차 하지 않을 것입니다. 재설계 주기를 계속 유지하기 위해 할 수 있는 모든 것이 좋습니다.산문은 마음에 들 때까지 계속해서 다시 쓸 수 있습니다.그러나 일반적으로 소프트웨어는 충분히 재설계되지 않습니다.산문에는 독자가 있지만 소프트웨어에는 사용자가 있습니다.작가가 에세이를 다시 쓴다면 이전 버전을 읽은 사람들은 새로 도입된 비호환성으로 인해 자신의 생각이 무너졌다고 불평하지 않을 것입니다. 사용자는 양날의 검입니다.언어 향상에 도움이 될 수 있지만 언어 향상을 방해할 수도 있습니다.따라서 사용자를 신중하게 선택하고 사용자 수를 늘리는 데 속도를 늦추십시오.사용자를 갖는 것은 최적화와 같습니다. 현명한 방법은 이를 지연시키는 것입니다.또한 일반적으로 주어진 시간에 생각보다 더 많은 것을 변경할 수 있습니다.변화를 도입하는 것은 붕대를 떼어내는 것과 같습니다. 고통은 느끼자마자 거의 기억이 됩니다. 위원회에서 설계한 언어를 갖는 것이 좋은 생각이 아니라는 것은 누구나 알고 있습니다.위원회는 나쁜 디자인을 낳습니다.하지만 위원회의 가장 큰 위험은 재설계를 방해한다는 것입니다.아무도 방해하고 싶지 않은 변화를 도입하는 것은 너무 많은 일입니다.위원회가 결정한 것은 대부분의 구성원이 좋아하지 않더라도 그대로 유지되는 경향이 있습니다. 심지어 두 명으로 구성된 위원회도 재설계를 방해합니다.이는 특히 서로 다른 두 사람이 작성한 소프트웨어 간의 인터페이스에서 발생합니다.인터페이스를 변경하려면 두 사람이 동시에 변경하는 데 동의해야 합니다.따라서 인터페이스는 전혀 변경되지 않는 경향이 있는데, 이는 시스템에서 가장 임시적인 부분 중 하나이기 때문에 문제가 됩니다. 여기서 한 가지 해결책은 인터페이스가 수직이 아닌 수평이 되도록 시스템을 설계하여 모듈이 항상 수직으로 쌓인 추상화 계층이 되도록 하는 것입니다.그러면 인터페이스는 그 중 하나의 소유가 되는 경향이 있습니다.두 수준 중 낮은 수준은 상위 수준이 작성된 언어가 되며, 이 경우 하위 수준이 인터페이스를 소유하게 되거나, 슬레이브가 되어 인터페이스가 상위 수준에 의해 지시될 수 있습니다.11 Lisp이 모든 것이 의미하는 바는 새로운 Lisp에 대한 희망이 있다는 것입니다.Lisp를 포함하여 해커가 원하는 것을 제공하는 모든 언어에는 희망이 있습니다.Lisp의 이상함 때문에 해커들이 의기소침해질 것이라고 생각하는 것은 우리가 실수를 했을 수도 있다고 생각합니다.이러한 위안이 되는 환상으로 인해 우리는 Lisp 또는 적어도 해커가 원하는 작업을 수행하기에는 형편없는 Common Lisp의 실제 문제를 보지 못하게 되었을 수 있습니다.해커의 언어

강력한 라이브러리와 해킹할 무언가가 필요합니다.Common Lisp에는 둘 다 없습니다.해커의 언어는 간결하고 해킹이 가능합니다.Common Lisp는 그렇지 않습니다. 좋은 소식은 형편없는 Lisp가 아니라 Common Lisp라는 것입니다.진짜 해커의 언어인 새로운 Lisp를 개발할 수 있다면 해커들이 그것을 사용할 것이라고 생각합니다.그들은 작업에 필요한 모든 언어를 사용할 것입니다.우리가 해야 할 일은 이 새로운 Lisp가 다른 언어보다 중요한 작업을 더 잘 수행하는지 확인하는 것입니다. 역사는 약간의 격려를 제공합니다.시간이 지남에 따라 연속적인 새로운 프로그래밍 언어가 Lisp에서 점점 더 많은 기능을 가져왔습니다.당신이 만든 언어가 Lisp가 되기 전에 더 이상 복사할 일이 많이 남지 않았습니다.최신 인기 언어인 Python은 중위 구문을 사용하고 매크로가 없는 간결한 Lisp입니다.새로운 Lisp는 이러한 발전의 자연스러운 단계가 될 것입니다. 나는 때때로 그것을 Python의 향상된 버전이라고 부르는 것이 좋은 마케팅 트릭이 될 것이라고 생각합니다.Lisp보다 더 힙하게 들리네요.많은 사람들에게 Lisp는 괄호가 많은 느린 AI 언어입니다.Fritz Kunze의 공식 전기에서는 L 단어에 대한 언급을 조심스럽게 피합니다.그러나 내 생각에는 우리가 새로운 Lisp Lisp를 부르는 것을 두려워해서는 안 될 것 같습니다.Lisp는 여전히 최고의 해커들 사이에서 잠재된 존경심을 갖고 있습니다. 예를 들어 6.001을 가져와 이해한 해커들입니다.그리고 그들은 승리해야 하는 사용자입니다. "해커가 되는 방법"에서 Eric Raymond는 Lisp를 라틴어 또는 그리스어와 같은 것으로 설명합니다. 이는 실제로 사용하지 않더라도 지적 연습으로 배워야 하는 언어입니다. Lisp는 마침내 얻게 될 심오한 깨달음 경험을 위해 배울 가치가 있습니다.그 경험은 당신이 실제로 Lisp 자체를 많이 사용하지 않더라도 남은 날 동안 당신을 더 나은 프로그래머로 만들 것입니다.내가 Lisp을 몰랐다면 이 글을 읽으면서 질문이 생길 것입니다.나를 더 나은 프로그래머로 만들어주는 언어는 프로그래밍에 더 나은 언어를 의미합니다.그리고 그것이 실제로 Eric이 말하는 내용의 의미입니다. 그 아이디어가 여전히 떠돌고 있는 한, 해커들은 Lisp라고 불리는 새로운 Lisp를 충분히 수용할 것이라고 생각합니다.하지만 이 Lisp는 1970년대의 고전적인 Lisp와 같은 해커의 언어임에 틀림없습니다.간결하고 단순하며 해킹이 가능해야 합니다.그리고 해커가 지금 하고 싶어하는 일을 하려면 강력한 라이브러리가 있어야 합니다. 라이브러리 문제에 관해서는 Perl이나 Python과 같은 언어를 자체 게임에서 이길 여지가 있다고 생각합니다.앞으로 작성해야 할 새로운 애플리케이션 중 상당수는 서버 기반 애플리케이션이 될 것입니다.새로운 Lisp가 Perl만큼 좋은 문자열 라이브러리를 갖지 못할 이유는 없으며, 이 새로운 Lisp가 서버 기반 애플리케이션을 위한 강력한 라이브러리도 가지고 있다면 매우 인기가 있을 것입니다.실제 해커들은 몇 번의 라이브러리 호출만으로 어려운 문제를 해결할 수 있는 새로운 도구에 눈을 돌리지 않을 것입니다.해커는 게으르다는 점을 기억하십시오. 서버 기반 응용 프로그램에 대한 핵심 언어 지원을 갖추는 것이 훨씬 더 큰 승리가 될 수 있습니다.예를 들어, 여러 사용자가 있는 프로그램에 대한 명시적인 지원이나 태그 유형 수준의 데이터 소유권이 있습니다. 서버 기반 애플리케이션은 또한 이 새로운 Lisp가 해킹에 사용될 것인지에 대한 질문에 대한 답을 제공합니다.Lisp를 Unix용 스크립팅 언어로 더 좋게 만드는 것은 나쁠 것이 없습니다.(더 나쁘게 만드는 것은 어려울 것입니다.) 하지만 기존 언어가 더 쉽게 이길 수있는 영역이 있다고 생각합니다.나는 Tcl 모델을 따르고 서버 기반 애플리케이션을 지원하기 위한 완전한 시스템과 함께 Lisp를 제공하는 것이 더 나을 것이라고 생각합니다.Lisp는 서버 기반 애플리케이션에 적합합니다.어휘 클로저는 UI가 일련의 웹 페이지일 때 서브루틴의 효과를 얻는 방법을 제공합니다.S-표현식은 HTML에 잘 매핑되며 매크로는 HTML을 생성하는 데 적합합니다.서버 기반 애플리케이션을 작성하기 위한 더 나은 도구가 필요하고 새로운 Lisp가 있어야 하며 두 가지가 함께 잘 작동할 것입니다.12 꿈의 언어 요약하자면, 해커의 꿈의 언어를 설명해보자.꿈의 언어는 아름답고 깨끗하며

간결하다.빠르게 시작되는 대화형 최상위 레벨이 있습니다.아주 적은 코드로 일반적인 문제를 해결하는 프로그램을 작성할 수 있습니다.여러분이 작성하는 모든 프로그램의 거의 모든 코드는 여러분의 애플리케이션에 특정한 코드입니다.다른 모든 것은 당신을 위해 이루어졌습니다. 언어의 구문은 간단해서 결함이 있습니다.불필요한 문자를 입력할 필요가 없으며 Shift 키를 많이 사용할 필요도 없습니다. 큰 추상화를 사용하면 프로그램의 첫 번째 버전을 매우 빠르게 작성할 수 있습니다.나중에 최적화하고 싶을 때 어디에 주의를 집중해야 하는지 알려주는 정말 좋은 프로파일러가 있습니다.필요한 경우 인라인 바이트 코드를 작성하여 내부 루프를 엄청나게 빠르게 만들 수 있습니다. 배울 수 있는 좋은 예제가 많이 있으며, 언어는 몇 분 안에 예제를 통해 사용 방법을 배울 수 있을 만큼 직관적입니다.설명서를 많이 볼 필요는 없습니다.매뉴얼은 얇으며 경고 및 제한 사항이 거의 없습니다. 이 언어에는 핵심 언어만큼 신중하게 설계된 작은 핵심과 강력하고 고도로 직교하는 라이브러리가 있습니다.도서관은 모두 함께 잘 작동합니다.언어의 모든 것은 정밀한 카메라의 부품처럼 서로 조화를 이룹니다.더 이상 사용되지 않거나 호환성을 위해 유지되는 것은 없습니다.모든 라이브러리의 소스 코드는 쉽게 사용할 수 있습니다.운영 체제 및 다른 언어로 작성된 애플리케이션과 대화하는 것은 쉽습니다. 언어는 레이어로 구성됩니다.더 높은 수준의 추상화는 낮은 수준의 추상화에서 매우 투명한 방식으로 구축되므로 원할 경우 얻을 수 있습니다. 반드시 숨겨야 할 필요가 없는 것은 아무것도 숨겨져 있지 않습니다.언어는 수행할 작업을 알려주는 방법이 아니라 작업을 저장하는 방법으로만 추상화를 제공합니다.사실, 언어는 당신이 그 디자인에 동등한 참여자가 되도록 장려합니다.구문까지 포함하여 모든 것을 변경할 수 있으며 작성하는 모든 내용은 가능한 한 사전 정의된 것과 동일한 상태를 갖습니다. 참고[1] 현대 아이디어에 매우 가까운 매크로는 Lisp 1.5가 출시된 지 2년 후인 1964년 Timothy Hart에 의해 제안되었습니다.처음에는 변수 캡처와 다중 평가를 피하는 방법이 누락되었습니다.Hart의 예는 두 가지 모두에 적용됩니다.[2]공기가 뇌에 닿을 때 신경외과 의사인 Frank Vertosick은 수석 레지던트인 Gary가 외과 의사와 내과 의사("벼룩")의 차이점에 대해 이야기한 대화를 자세히 설명합니다. Gary와 나는 큰 피자를 주문하고 열린 부스를 발견했습니다.추장은 담배에 불을 붙였다."그 망할 벼룩들 좀 봐, 일생에 한 번 볼 질병에 대해 읭읭. 그게 벼룩의 문제야. 그들은 기괴한 것만 좋아해. 그들은 빵과 버터 상자를 싫어해. 그게 우리와 빌어먹을 벼룩의 차이야. 봐, 우리는 크고 육즙이 많은 요추 추간판 탈출증을 좋아하지만 그들은 고혈압을 싫어해...." 요추 추간판 탈출증을 육즙이 많은 것으로 생각하기는 어렵습니다(말 그대로).하지만 나는 그 말이 무슨 뜻인지 알 것 같아요.나는 종종 추적해야 할 흥미로운 버그를 겪었습니다.프로그래머가 아닌 사람은 버그에 즐거움이 있을 수 있다는 것을 상상하기 어려울 것입니다.확실히 모든 것이 제대로 작동한다면 더 좋습니다.어떤 면에서는 그렇습니다.그럼에도 불구하고 특정 종류의 버그를 추적하는 데에는 부인할 수 없는 암울한 만족감이 있습니다. 포스트스크립트 버전Arc언어 디자인에 관한 다섯 가지 질문해커가 되는 방법일본어 번역

---

## 원문 (Original Essay)

May 2001(This article was written as a kind of business plan for a new language. So it is missing (because it takes for granted) the most important feature of a good programming language: very powerful abstractions.)A friend of mine once told an eminent operating systems expert that he wanted to design a really good programming language. The expert told him that it would be a waste of time, that programming languages don't become popular or unpopular based on their merits, and so no matter how good his language was, no one would use it. At least, that was what had happened to the language he had designed.What does make a language popular? Do popular languages deserve their popularity? Is it worth trying to define a good programming language? How would you do it?I think the answers to these questions can be found by looking at hackers, and learning what they want. Programming languages are for hackers, and a programming language is good as a programming language (rather than, say, an exercise in denotational semantics or compiler design) if and only if hackers like it.1 The Mechanics of PopularityIt's true, certainly, that most people don't choose programming languages simply based on their merits. Most programmers are told what language to use by someone else. And yet I think the effect of such external factors on the popularity of programming languages is not as great as it's sometimes thought to be. I think a bigger problem is that a hacker's idea of a good programming language is not the same as most language designers'.Between the two, the hacker's opinion is the one that matters. Programming languages are not theorems. They're tools, designed for people, and they have to be designed to suit human strengths and weaknesses as much as shoes have to be designed for human feet. If a shoe pinches when you put it on, it's a bad shoe, however elegant it may be as a piece of sculpture.It may be that the majority of programmers can't tell a good language from a bad one. But that's no different with any other tool. It doesn't mean that it's a waste of time to try designing a good language. Expert hackers can tell a good language when they see one, and they'll use it. Expert hackers are a tiny minority, admittedly, but that tiny minority write all the good software, and their influence is such that the rest of the programmers will tend to use whatever language they use. Often, indeed, it is not merely influence but command: often the expert hackers are the very people who, as their bosses or faculty advisors, tell the other programmers what language to use.The opinion of expert hackers is not the only force that determines the relative popularity of programming languages — legacy software (Cobol) and hype (Ada, Java) also play a role — but I think it is the most powerful force over the long term. Given an initial critical mass and enough time, a programming language probably becomes about as popular as it deserves to be. And popularity further separates good languages from bad ones, because feedback from real live users always leads to improvements. Look at how much any popular language has changed during its life. Perl and Fortran are extreme cases, but even Lisp has changed a lot. Lisp 1.5 didn't have macros, for example; these evolved later, after hackers at MIT had spent a couple years using Lisp to write real programs. [1]So whether or not a language has to be good to be popular, I think a language has to be popular to be good. And it has to stay popular to stay good. The state of the art in programming languages doesn't stand still. And yet the Lisps we have today are still pretty much what they had at MIT in the mid-1980s, because that's the last time Lisp had a sufficiently large and demanding user base.Of course, hackers have to know about a language before they can use it. How are they to hear? From other hackers. But there has to be some initial group of hackers using the language for others even to hear about it. I wonder how large this group has to be; how many users make a critical mass? Off the top of my head, I'd say twenty. If a language had twenty separate users, meaning twenty users who decided on their own to use it, I'd consider it to be real.Getting there can't be easy. I would not be surprised if it is harder to get from zero to twenty than from twenty to a thousand. The best way to get those initial twenty users is probably to use a trojan horse: to give people an application they want, which happens to be written in the new language.2 External FactorsLet's start by acknowledging one external factor that does affect the popularity of a programming language. To become popular, a programming language has to be the scripting language of a popular system. Fortran and Cobol were the scripting languages of early IBM mainframes. C was the scripting language of Unix, and so, later, was Perl. Tcl is the scripting language of Tk. Java and Javascript are intended to be the scripting languages of web browsers.Lisp is not a massively popular language because it is not the scripting language of a massively popular system. What popularity it retains dates back to the 1960s and 1970s, when it was the scripting language of MIT. A lot of the great programmers of the day were associated with MIT at some point. And in the early 1970s, before C, MIT's dialect of Lisp, called MacLisp, was one of the only programming languages a serious hacker would want to use.Today Lisp is the scripting language of two moderately popular systems, Emacs and Autocad, and for that reason I suspect that most of the Lisp programming done today is done in Emacs Lisp or AutoLisp.Programming languages don't exist in isolation. To hack is a transitive verb — hackers are usually hacking something — and in practice languages are judged relative to whatever they're used to hack. So if you want to design a popular language, you either have to supply more than a language, or you have to design your language to replace the scripting language of some existing system.Common Lisp is unpopular partly because it's an orphan. It did originally come with a system to hack: the Lisp Machine. But Lisp Machines (along with parallel computers) were steamrollered by the increasing power of general purpose processors in the 1980s. Common Lisp might have remained popular if it had been a good scripting language for Unix. It is, alas, an atrociously bad one.One way to describe this situation is to say that a language isn't judged on its own merits. Another view is that a programming language really isn't a programming language unless it's also the scripting language of something. This only seems unfair if it comes as a surprise. I think it's no more unfair than expecting a programming language to have, say, an implementation. It's just part of what a programming language is.A programming language does need a good implementation, of course, and this must be free. Companies will pay for software, but individual hackers won't, and it's the hackers you need to attract.A language also needs to have a book about it. The book should be thin, well-written, and full of good examples. K&R is the ideal here. At the moment I'd almost say that a language has to have a book published by O'Reilly. That's becoming the test of mattering to hackers.There should be online documentation as well. In fact, the book can start as online documentation. But I don't think that physical books are outmoded yet. Their format is convenient, and the de facto censorship imposed by publishers is a useful if imperfect filter. Bookstores are one of the most important places for learning about new languages.3 BrevityGiven that you can supply the three things any language needs — a free implementation, a book, and something to hack — how do you make a language that hackers will like?One thing hackers like is brevity. Hackers are lazy, in the same way that mathematicians and modernist architects are lazy: they hate anything extraneous. It would not be far from the truth to say that a hacker about to write a program decides what language to use, at least subconsciously, based on the total number of characters he'll have to type. If this isn't precisely how hackers think, a language designer would do well to act as if it were.It is a mistake to try to baby the user with long-winded expressions that are meant to resemble English. Cobol is notorious for this flaw. A hacker would consider being asked to writeadd x to y giving zinstead ofz = x+yas something between an insult to his intelligence and a sin against God.It has sometimes been said that Lisp should use first and rest instead of car and cdr, because it would make programs easier to read. Maybe for the first couple hours. But a hacker can learn quickly enough that car means the first element of a list and cdr means the rest. Using first and rest means 50% more typing. And they are also different lengths, meaning that the arguments won't line up when they're called, as car and cdr often are, in successive lines. I've found that it matters a lot how code lines up on the page. I can barely read Lisp code when it is set in a variable-width font, and friends say this is true for other languages too.Brevity is one place where strongly typed languages lose. All other things being equal, no one wants to begin a program with a bunch of declarations. Anything that can be implicit, should be.The individual tokens should be short as well. Perl and Common Lisp occupy opposite poles on this question. Perl programs can be almost cryptically dense, while the names of built-in Common Lisp operators are comically long. The designers of Common Lisp probably expected users to have text editors that would type these long names for them. But the cost of a long name is not just the cost of typing it. There is also the cost of reading it, and the cost of the space it takes up on your screen.4 HackabilityThere is one thing more important than brevity to a hacker: being able to do what you want. In the history of programming languages a surprising amount of effort has gone into preventing programmers from doing things considered to be improper. This is a dangerously presumptuous plan. How can the language designer know what the programmer is going to need to do? I think language designers would do better to consider their target user to be a genius who will need to do things they never anticipated, rather than a bumbler who needs to be protected from himself. The bumbler will shoot himself in the foot anyway. You may save him from referring to variables in another package, but you can't save him from writing a badly designed program to solve the wrong problem, and taking forever to do it.Good programmers often want to do dangerous and unsavory things. By unsavory I mean things that go behind whatever semantic facade the language is trying to present: getting hold of the internal representation of some high-level abstraction, for example. Hackers like to hack, and hacking means getting inside things and second guessing the original designer.Let yourself be second guessed. When you make any tool, people use it in ways you didn't intend, and this is especially true of a highly articulated tool like a programming language. Many a hacker will want to tweak your semantic model in a way that you never imagined. I say, let them; give the programmer access to as much internal stuff as you can without endangering runtime systems like the garbage collector.In Common Lisp I have often wanted to iterate through the fields of a struct — to comb out references to a deleted object, for example, or find fields that are uninitialized. I know the structs are just vectors underneath. And yet I can't write a general purpose function that I can call on any struct. I can only access the fields by name, because that's what a struct is supposed to mean.A hacker may only want to subvert the intended model of things once or twice in a big program. But what a difference it makes to be able to. And it may be more than a question of just solving a problem. There is a kind of pleasure here too. Hackers share the surgeon's secret pleasure in poking about in gross innards, the teenager's secret pleasure in popping zits. [2] For boys, at least, certain kinds of horrors are fascinating. Maxim magazine publishes an annual volume of photographs, containing a mix of pin-ups and grisly accidents. They know their audience.Historically, Lisp has been good at letting hackers have their way. The political correctness of Common Lisp is an aberration. Early Lisps let you get your hands on everything. A good deal of that spirit is, fortunately, preserved in macros. What a wonderful thing, to be able to make arbitrary transformations on the source code.Classic macros are a real hacker's tool — simple, powerful, and dangerous. It's so easy to understand what they do: you call a function on the macro's arguments, and whatever it returns gets inserted in place of the macro call. Hygienic macros embody the opposite principle. They try to protect you from understanding what they're doing. I have never heard hygienic macros explained in one sentence. And they are a classic example of the dangers of deciding what programmers are allowed to want. Hygienic macros are intended to protect me from variable capture, among other things, but variable capture is exactly what I want in some macros.A really good language should be both clean and dirty: cleanly designed, with a small core of well understood and highly orthogonal operators, but dirty in the sense that it lets hackers have their way with it. C is like this. So were the early Lisps. A real hacker's language will always have a slightly raffish character.A good programming language should have features that make the kind of people who use the phrase "software engineering" shake their heads disapprovingly. At the other end of the continuum are languages like Ada and Pascal, models of propriety that are good for teaching and not much else.5 Throwaway ProgramsTo be attractive to hackers, a language must be good for writing the kinds of programs they want to write. And that means, perhaps surprisingly, that it has to be good for writing throwaway programs.A throwaway program is a program you write quickly for some limited task: a program to automate some system administration task, or generate test data for a simulation, or convert data from one format to another. The surprising thing about throwaway programs is that, like the "temporary" buildings built at so many American universities during World War II, they often don't get thrown away. Many evolve into real programs, with real features and real users.I have a hunch that the best big programs begin life this way, rather than being designed big from the start, like the Hoover Dam. It's terrifying to build something big from scratch. When people take on a project that's too big, they become overwhelmed. The project either gets bogged down, or the result is sterile and wooden: a shopping mall rather than a real downtown, Brasilia rather than Rome, Ada rather than C.Another way to get a big program is to start with a throwaway program and keep improving it. This approach is less daunting, and the design of the program benefits from evolution. I think, if one looked, that this would turn out to be the way most big programs were developed. And those that did evolve this way are probably still written in whatever language they were first written in, because it's rare for a program to be ported, except for political reasons. And so, paradoxically, if you want to make a language that is used for big systems, you have to make it good for writing throwaway programs, because that's where big systems come from.Perl is a striking example of this idea. It was not only designed for writing throwaway programs, but was pretty much a throwaway program itself. Perl began life as a collection of utilities for generating reports, and only evolved into a programming language as the throwaway programs people wrote in it grew larger. It was not until Perl 5 (if then) that the language was suitable for writing serious programs, and yet it was already massively popular.What makes a language good for throwaway programs? To start with, it must be readily available. A throwaway program is something that you expect to write in an hour. So the language probably must already be installed on the computer you're using. It can't be something you have to install before you use it. It has to be there. C was there because it came with the operating system. Perl was there because it was originally a tool for system administrators, and yours had already installed it.Being available means more than being installed, though. An interactive language, with a command-line interface, is more available than one that you have to compile and run separately. A popular programming language should be interactive, and start up fast.Another thing you want in a throwaway program is brevity. Brevity is always attractive to hackers, and never more so than in a program they expect to turn out in an hour.6 LibrariesOf course the ultimate in brevity is to have the program already written for you, and merely to call it. And this brings us to what I think will be an increasingly important feature of programming languages: library functions. Perl wins because it has large libraries for manipulating strings. This class of library functions are especially important for throwaway programs, which are often originally written for converting or extracting data. Many Perl programs probably begin as just a couple library calls stuck together.I think a lot of the advances that happen in programming languages in the next fifty years will have to do with library functions. I think future programming languages will have libraries that are as carefully designed as the core language. Programming language design will not be about whether to make your language strongly or weakly typed, or object oriented, or functional, or whatever, but about how to design great libraries. The kind of language designers who like to think about how to design type systems may shudder at this. It's almost like writing applications! Too bad. Languages are for programmers, and libraries are what programmers need.It's hard to design good libraries. It's not simply a matter of writing a lot of code. Once the libraries get too big, it can sometimes take longer to find the function you need than to write the code yourself. Libraries need to be designed using a small set of orthogonal operators, just like the core language. It ought to be possible for the programmer to guess what library call will do what he needs.Libraries are one place Common Lisp falls short. There are only rudimentary libraries for manipulating strings, and almost none for talking to the operating system. For historical reasons, Common Lisp tries to pretend that the OS doesn't exist. And because you can't talk to the OS, you're unlikely to be able to write a serious program using only the built-in operators in Common Lisp. You have to use some implementation-specific hacks as well, and in practice these tend not to give you everything you want. Hackers would think a lot more highly of Lisp if Common Lisp had powerful string libraries and good OS support.7 SyntaxCould a language with Lisp's syntax, or more precisely, lack of syntax, ever become popular? I don't know the answer to this question. I do think that syntax is not the main reason Lisp isn't currently popular. Common Lisp has worse problems than unfamiliar syntax. I know several programmers who are comfortable with prefix syntax and yet use Perl by default, because it has powerful string libraries and can talk to the os.There are two possible problems with prefix notation: that it is unfamiliar to programmers, and that it is not dense enough. The conventional wisdom in the Lisp world is that the first problem is the real one. I'm not so sure. Yes, prefix notation makes ordinary programmers panic. But I don't think ordinary programmers' opinions matter. Languages become popular or unpopular based on what expert hackers think of them, and I think expert hackers might be able to deal with prefix notation. Perl syntax can be pretty incomprehensible, but that has not stood in the way of Perl's popularity. If anything it may have helped foster a Perl cult.A more serious problem is the diffuseness of prefix notation. For expert hackers, that really is a problem. No one wants to write (aref a x y) when they could write a[x,y].In this particular case there is a way to finesse our way out of the problem. If we treat data structures as if they were functions on indexes, we could write (a x y) instead, which is even shorter than the Perl form. Similar tricks may shorten other types of expressions.We can get rid of (or make optional) a lot of parentheses by making indentation significant. That's how programmers read code anyway: when indentation says one thing and delimiters say another, we go by the indentation. Treating indentation as significant would eliminate this common source of bugs as well as making programs shorter.Sometimes infix syntax is easier to read. This is especially true for math expressions. I've used Lisp my whole programming life and I still don't find prefix math expressions natural. And yet it is convenient, especially when you're generating code, to have operators that take any number of arguments. So if we do have infix syntax, it should probably be implemented as some kind of read-macro.I don't think we should be religiously opposed to introducing syntax into Lisp, as long as it translates in a well-understood way into underlying s-expressions. There is already a good deal of syntax in Lisp. It's not necessarily bad to introduce more, as long as no one is forced to use it. In Common Lisp, some delimiters are reserved for the language, suggesting that at least some of the designers intended to have more syntax in the future.One of the most egregiously unlispy pieces of syntax in Common Lisp occurs in format strings; format is a language in its own right, and that language is not Lisp. If there were a plan for introducing more syntax into Lisp, format specifiers might be able to be included in it. It would be a good thing if macros could generate format specifiers the way they generate any other kind of code.An eminent Lisp hacker told me that his copy of CLTL falls open to the section format. Mine too. This probably indicates room for improvement. It may also mean that programs do a lot of I/O.8 EfficiencyA good language, as everyone knows, should generate fast code. But in practice I don't think fast code comes primarily from things you do in the design of the language. As Knuth pointed out long ago, speed only matters in certain critical bottlenecks. And as many programmers have observed since, one is very often mistaken about where these bottlenecks are.So, in practice, the way to get fast code is to have a very good profiler, rather than by, say, making the language strongly typed. You don't need to know the type of every argument in every call in the program. You do need to be able to declare the types of arguments in the bottlenecks. And even more, you need to be able to find out where the bottlenecks are.One complaint people have had with Lisp is that it's hard to tell what's expensive. This might be true. It might also be inevitable, if you want to have a very abstract language. And in any case I think good profiling would go a long way toward fixing the problem: you'd soon learn what was expensive.Part of the problem here is social. Language designers like to write fast compilers. That's how they measure their skill. They think of the profiler as an add-on, at best. But in practice a good profiler may do more to improve the speed of actual programs written in the language than a compiler that generates fast code. Here, again, language designers are somewhat out of touch with their users. They do a really good job of solving slightly the wrong problem.It might be a good idea to have an active profiler — to push performance data to the programmer instead of waiting for him to come asking for it. For example, the editor could display bottlenecks in red when the programmer edits the source code. Another approach would be to somehow represent what's happening in running programs. This would be an especially big win in server-based applications, where you have lots of running programs to look at. An active profiler could show graphically what's happening in memory as a program's running, or even make sounds that tell what's happening.Sound is a good cue to problems. In one place I worked, we had a big board of dials showing what was happening to our web servers. The hands were moved by little servomotors that made a slight noise when they turned. I couldn't see the board from my desk, but I found that I could tell immediately, by the sound, when there was a problem with a server.It might even be possible to write a profiler that would automatically detect inefficient algorithms. I would not be surprised if certain patterns of memory access turned out to be sure signs of bad algorithms. If there were a little guy running around inside the computer executing our programs, he would probably have as long and plaintive a tale to tell about his job as a federal government employee. I often have a feeling that I'm sending the processor on a lot of wild goose chases, but I've never had a good way to look at what it's doing.A number of Lisps now compile into byte code, which is then executed by an interpreter. This is usually done to make the implementation easier to port, but it could be a useful language feature. It might be a good idea to make the byte code an official part of the language, and to allow programmers to use inline byte code in bottlenecks. Then such optimizations would be portable too.The nature of speed, as perceived by the end-user, may be changing. With the rise of server-based applications, more and more programs may turn out to be i/o-bound. It will be worth making i/o fast. The language can help with straightforward measures like simple, fast, formatted output functions, and also with deep structural changes like caching and persistent objects.Users are interested in response time. But another kind of efficiency will be increasingly important: the number of simultaneous users you can support per processor. Many of the interesting applications written in the near future will be server-based, and the number of users per server is the critical question for anyone hosting such applications. In the capital cost of a business offering a server-based application, this is the divisor.For years, efficiency hasn't mattered much in most end-user applications. Developers have been able to assume that each user would have an increasingly powerful processor sitting on their desk. And by Parkinson's Law, software has expanded to use the resources available. That will change with server-based applications. In that world, the hardware and software will be supplied together. For companies that offer server-based applications, it will make a very big difference to the bottom line how many users they can support per server.In some applications, the processor will be the limiting factor, and execution speed will be the most important thing to optimize. But often memory will be the limit; the number of simultaneous users will be determined by the amount of memory you need for each user's data. The language can help here too. Good support for threads will enable all the users to share a single heap. It may also help to have persistent objects and/or language level support for lazy loading.9 TimeThe last ingredient a popular language needs is time. No one wants to write programs in a language that might go away, as so many programming languages do. So most hackers will tend to wait until a language has been around for a couple years before even considering using it.Inventors of wonderful new things are often surprised to discover this, but you need time to get any message through to people. A friend of mine rarely does anything the first time someone asks him. He knows that people sometimes ask for things that they turn out not to want. To avoid wasting his time, he waits till the third or fourth time he's asked to do something; by then, whoever's asking him may be fairly annoyed, but at least they probably really do want whatever they're asking for.Most people have learned to do a similar sort of filtering on new things they hear about. They don't even start paying attention until they've heard about something ten times. They're perfectly justified: the majority of hot new whatevers do turn out to be a waste of time, and eventually go away. By delaying learning VRML, I avoided having to learn it at all.So anyone who invents something new has to expect to keep repeating their message for years before people will start to get it. We wrote what was, as far as I know, the first web-server based application, and it took us years to get it through to people that it didn't have to be downloaded. It wasn't that they were stupid. They just had us tuned out.The good news is, simple repetition solves the problem. All you have to do is keep telling your story, and eventually people will start to hear. It's not when people notice you're there that they pay attention; it's when they notice you're still there.It's just as well that it usually takes a while to gain momentum. Most technologies evolve a good deal even after they're first launched — programming languages especially. Nothing could be better, for a new techology, than a few years of being used only by a small number of early adopters. Early adopters are sophisticated and demanding, and quickly flush out whatever flaws remain in your technology. When you only have a few users you can be in close contact with all of them. And early adopters are forgiving when you improve your system, even if this causes some breakage.There are two ways new technology gets introduced: the organic growth method, and the big bang method. The organic growth method is exemplified by the classic seat-of-the-pants underfunded garage startup. A couple guys, working in obscurity, develop some new technology. They launch it with no marketing and initially have only a few (fanatically devoted) users. They continue to improve the technology, and meanwhile their user base grows by word of mouth. Before they know it, they're big.The other approach, the big bang method, is exemplified by the VC-backed, heavily marketed startup. They rush to develop a product, launch it with great publicity, and immediately (they hope) have a large user base.Generally, the garage guys envy the big bang guys. The big bang guys are smooth and confident and respected by the VCs. They can afford the best of everything, and the PR campaign surrounding the launch has the side effect of making them celebrities. The organic growth guys, sitting in their garage, feel poor and unloved. And yet I think they are often mistaken to feel sorry for themselves. Organic growth seems to yield better technology and richer founders than the big bang method. If you look at the dominant technologies today, you'll find that most of them grew organically.This pattern doesn't only apply to companies. You see it in sponsored research too. Multics and Common Lisp were big-bang projects, and Unix and MacLisp were organic growth projects.10 Redesign"The best writing is rewriting," wrote E. B. White. Every good writer knows this, and it's true for software too. The most important part of design is redesign. Programming languages, especially, don't get redesigned enough.To write good software you must simultaneously keep two opposing ideas in your head. You need the young hacker's naive faith in his abilities, and at the same time the veteran's skepticism. You have to be able to think how hard can it be? with one half of your brain while thinking it will never work with the other.The trick is to realize that there's no real contradiction here. You want to be optimistic and skeptical about two different things. You have to be optimistic about the possibility of solving the problem, but skeptical about the value of whatever solution you've got so far.People who do good work often think that whatever they're working on is no good. Others see what they've done and are full of wonder, but the creator is full of worry. This pattern is no coincidence: it is the worry that made the work good.If you can keep hope and worry balanced, they will drive a project forward the same way your two legs drive a bicycle forward. In the first phase of the two-cycle innovation engine, you work furiously on some problem, inspired by your confidence that you'll be able to solve it. In the second phase, you look at what you've done in the cold light of morning, and see all its flaws very clearly. But as long as your critical spirit doesn't outweigh your hope, you'll be able to look at your admittedly incomplete system, and think, how hard can it be to get the rest of the way?, thereby continuing the cycle.It's tricky to keep the two forces balanced. In young hackers, optimism predominates. They produce something, are convinced it's great, and never improve it. In old hackers, skepticism predominates, and they won't even dare to take on ambitious projects.Anything you can do to keep the redesign cycle going is good. Prose can be rewritten over and over until you're happy with it. But software, as a rule, doesn't get redesigned enough. Prose has readers, but software has users. If a writer rewrites an essay, people who read the old version are unlikely to complain that their thoughts have been broken by some newly introduced incompatibility.Users are a double-edged sword. They can help you improve your language, but they can also deter you from improving it. So choose your users carefully, and be slow to grow their number. Having users is like optimization: the wise course is to delay it. Also, as a general rule, you can at any given time get away with changing more than you think. Introducing change is like pulling off a bandage: the pain is a memory almost as soon as you feel it.Everyone knows that it's not a good idea to have a language designed by a committee. Committees yield bad design. But I think the worst danger of committees is that they interfere with redesign. It is so much work to introduce changes that no one wants to bother. Whatever a committee decides tends to stay that way, even if most of the members don't like it.Even a committee of two gets in the way of redesign. This happens particularly in the interfaces between pieces of software written by two different people. To change the interface both have to agree to change it at once. And so interfaces tend not to change at all, which is a problem because they tend to be one of the most ad hoc parts of any system.One solution here might be to design systems so that interfaces are horizontal instead of vertical — so that modules are always vertically stacked strata of abstraction. Then the interface will tend to be owned by one of them. The lower of two levels will either be a language in which the upper is written, in which case the lower level will own the interface, or it will be a slave, in which case the interface can be dictated by the upper level.11 LispWhat all this implies is that there is hope for a new Lisp. There is hope for any language that gives hackers what they want, including Lisp. I think we may have made a mistake in thinking that hackers are turned off by Lisp's strangeness. This comforting illusion may have prevented us from seeing the real problem with Lisp, or at least Common Lisp, which is that it sucks for doing what hackers want to do. A hacker's language needs powerful libraries and something to hack. Common Lisp has neither. A hacker's language is terse and hackable. Common Lisp is not.The good news is, it's not Lisp that sucks, but Common Lisp. If we can develop a new Lisp that is a real hacker's language, I think hackers will use it. They will use whatever language does the job. All we have to do is make sure this new Lisp does some important job better than other languages.History offers some encouragement. Over time, successive new programming languages have taken more and more features from Lisp. There is no longer much left to copy before the language you've made is Lisp. The latest hot language, Python, is a watered-down Lisp with infix syntax and no macros. A new Lisp would be a natural step in this progression.I sometimes think that it would be a good marketing trick to call it an improved version of Python. That sounds hipper than Lisp. To many people, Lisp is a slow AI language with a lot of parentheses. Fritz Kunze's official biography carefully avoids mentioning the L-word. But my guess is that we shouldn't be afraid to call the new Lisp Lisp. Lisp still has a lot of latent respect among the very best hackers — the ones who took 6.001 and understood it, for example. And those are the users you need to win.In "How to Become a Hacker," Eric Raymond describes Lisp as something like Latin or Greek — a language you should learn as an intellectual exercise, even though you won't actually use it: Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot. If I didn't know Lisp, reading this would set me asking questions. A language that would make me a better programmer, if it means anything at all, means a language that would be better for programming. And that is in fact the implication of what Eric is saying.As long as that idea is still floating around, I think hackers will be receptive enough to a new Lisp, even if it is called Lisp. But this Lisp must be a hacker's language, like the classic Lisps of the 1970s. It must be terse, simple, and hackable. And it must have powerful libraries for doing what hackers want to do now.In the matter of libraries I think there is room to beat languages like Perl and Python at their own game. A lot of the new applications that will need to be written in the coming years will be server-based applications. There's no reason a new Lisp shouldn't have string libraries as good as Perl, and if this new Lisp also had powerful libraries for server-based applications, it could be very popular. Real hackers won't turn up their noses at a new tool that will let them solve hard problems with a few library calls. Remember, hackers are lazy.It could be an even bigger win to have core language support for server-based applications. For example, explicit support for programs with multiple users, or data ownership at the level of type tags.Server-based applications also give us the answer to the question of what this new Lisp will be used to hack. It would not hurt to make Lisp better as a scripting language for Unix. (It would be hard to make it worse.) But I think there are areas where existing languages would be easier to beat. I think it might be better to follow the model of Tcl, and supply the Lisp together with a complete system for supporting server-based applications. Lisp is a natural fit for server-based applications. Lexical closures provide a way to get the effect of subroutines when the ui is just a series of web pages. S-expressions map nicely onto html, and macros are good at generating it. There need to be better tools for writing server-based applications, and there needs to be a new Lisp, and the two would work very well together.12 The Dream LanguageBy way of summary, let's try describing the hacker's dream language. The dream language is beautiful, clean, and terse. It has an interactive toplevel that starts up fast. You can write programs to solve common problems with very little code. Nearly all the code in any program you write is code that's specific to your application. Everything else has been done for you.The syntax of the language is brief to a fault. You never have to type an unnecessary character, or even to use the shift key much.Using big abstractions you can write the first version of a program very quickly. Later, when you want to optimize, there's a really good profiler that tells you where to focus your attention. You can make inner loops blindingly fast, even writing inline byte code if you need to.There are lots of good examples to learn from, and the language is intuitive enough that you can learn how to use it from examples in a couple minutes. You don't need to look in the manual much. The manual is thin, and has few warnings and qualifications.The language has a small core, and powerful, highly orthogonal libraries that are as carefully designed as the core language. The libraries all work well together; everything in the language fits together like the parts in a fine camera. Nothing is deprecated, or retained for compatibility. The source code of all the libraries is readily available. It's easy to talk to the operating system and to applications written in other languages.The language is built in layers. The higher-level abstractions are built in a very transparent way out of lower-level abstractions, which you can get hold of if you want.Nothing is hidden from you that doesn't absolutely have to be. The language offers abstractions only as a way of saving you work, rather than as a way of telling you what to do. In fact, the language encourages you to be an equal participant in its design. You can change everything about it, including even its syntax, and anything you write has, as much as possible, the same status as what comes predefined.Notes[1] Macros very close to the modern idea were proposed by Timothy Hart in 1964, two years after Lisp 1.5 was released. What was missing, initially, were ways to avoid variable capture and multiple evaluation; Hart's examples are subject to both.[2] In When the Air Hits Your Brain, neurosurgeon Frank Vertosick recounts a conversation in which his chief resident, Gary, talks about the difference between surgeons and internists ("fleas"): Gary and I ordered a large pizza and found an open booth. The chief lit a cigarette. "Look at those goddamn fleas, jabbering about some disease they'll see once in their lifetimes. That's the trouble with fleas, they only like the bizarre stuff. They hate their bread and butter cases. That's the difference between us and the fucking fleas. See, we love big juicy lumbar disc herniations, but they hate hypertension...." It's hard to think of a lumbar disc herniation as juicy (except literally). And yet I think I know what they mean. I've often had a juicy bug to track down. Someone who's not a programmer would find it hard to imagine that there could be pleasure in a bug. Surely it's better if everything just works. In one way, it is. And yet there is undeniably a grim satisfaction in hunting down certain sorts of bugs.Postscript VersionArcFive Questions about Language DesignHow to Become a HackerJapanese Translation

---

_분석일: 2025. 11. 29._
_수집일: 2025. 11. 28._