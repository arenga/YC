# Beating the Averages
**카테고리**: Mindset
**난이도**: 중급
**출판일**: N/A
**원문**: https://paulgraham.com/avg.html
---
## 요약 (Summary)

🎯 평균을 어떻게 이기나요?

✨ 핵심 내용 요약

Paul Graham의 비밀 무기: **Lisp**. Viaweb이 경쟁자를 이긴 이유입니다.

1990년대 전자상거래 경쟁: 수십 개 회사가 같은 것을 만들었습니다. 하지만 Viaweb이 이겼습니다. 왜? Graham은 Lisp을 썼고, 경쟁자는 C++를 썼습니다. Lisp은 10배 빠르게 개발할 수 있었습니다. 경쟁자가 1개 기능을 만드는 동안, Viaweb은 10개를 만들었습니다. 결과: Yahoo가 $50M에 인수했습니다. Graham의 교훈: **비밀 무기를 가지세요**. 경쟁자가 모르는 기술, 경쟁자가 못 쓰는 도구. 한국 스타트업: "모두가 쓰는" 기술만 쓰면 평균입니다. 남다른 것을 찾으세요.

**핵심 포인트**
• 비밀 무기가 경쟁 우위입니다
• 남들이 안 쓰는 도구를 찾으세요
• 10배 빠르게 만들 수 있는 방법을 찾으세요

🚀 오늘 바로 실천해볼 한 가지
경쟁자가 모르는 "비밀 무기" 하나를 찾으세요. 도구, 프로세스, 사람 - 뭐든 좋습니다.

---

## 한국어 번역 (Korean Translation)

스타트업을 시작하고 싶나요?Y Combinator에서 자금을 지원받으세요.2001년 4월 개정판.2003년 4월(이 기사는 2001년 프란츠 개발자 심포지엄에서 발표한 내용을 바탕으로 작성되었습니다.) 1995년 여름, 내 친구 Robert Morris와 저는 Viaweb이라는 스타트업을 시작했습니다.우리의 계획은 최종 사용자가 온라인 상점을 구축할 수 있는 소프트웨어를 작성하는 것이었습니다.당시 이 소프트웨어의 참신한 점은 일반 웹 페이지를 인터페이스로 사용하여 우리 서버에서 실행되었다는 것입니다. 물론 많은 사람들이 동시에 이 아이디어를 갖고 있었을 수도 있지만 제가 아는 한 Viaweb은 최초의 웹 기반 애플리케이션이었습니다.우리의 소프트웨어가 데스크톱 컴퓨터에서 실행되는 대신 웹을 통해 작동했기 때문에 회사 이름을 Viaweb으로 명명한 것은 우리에게 참신한 아이디어로 보였습니다. 이 소프트웨어의 또 다른 특이한 점은 주로 Lisp라는 프로그래밍 언어로 작성되었다는 것입니다.이는 Lisp로 작성된 최초의 대규모 최종 사용자 애플리케이션 중 하나였으며, 그때까지 주로 대학과 연구실에서 사용되었습니다.[1]비밀 무기Eric Raymond는 "해커가 되는 방법"이라는 에세이를 썼는데, 그 안에는 무엇보다도 해커가 될 지망생들이 배워야 할 언어가 무엇인지 알려 줍니다.그는 배우기 쉽기 때문에 Python과 Java부터 시작할 것을 제안합니다.진지한 해커는 Unix를 해킹하기 위해 C를 배우고 시스템 관리 및 cgi 스크립트를 위해 Perl을 배우고 싶어할 것입니다.마지막으로, 진정으로 진지한 해커는 Lisp 학습을 고려해야 합니다. Lisp는 마침내 얻게 될 심오한 깨달음 경험을 위해 배울 가치가 있습니다.그 경험은 당신이 실제로 Lisp 자체를 많이 사용하지 않더라도 남은 날 동안 당신을 더 나은 프로그래머로 만들 것입니다.이것은 라틴어를 배울 때 듣는 경향이 있는 것과 동일한 주장입니다.고전 교수 외에는 직업을 얻을 수는 없지만 마음이 향상되고 영어처럼 사용하고 싶은 언어로 더 나은 작가가 될 수 있습니다. 하지만 잠깐만요.이 은유는 그다지 확장되지 않습니다.라틴어가 직업을 얻지 못하는 이유는 아무도 라틴어를 사용하지 않기 때문입니다.라틴어로 글을 쓰면 아무도 당신을 이해할 수 없습니다.그러나 Lisp는 컴퓨터 언어이고 컴퓨터는 프로그래머가 지시하는 모든 언어를 사용합니다. 따라서 Lisp가 말한 것처럼 Lisp가 당신을 더 나은 프로그래머로 만든다면 왜 그것을 사용하고 싶지 않습니까?화가에게 자신을 더 나은 화가로 만들어 줄 붓을 제공한다면, 그 사람은 자신의 모든 그림에 그 붓을 사용하고 싶어할 것 같지 않습니까?나는 여기서 Eric Raymond를 놀리려는 것이 아닙니다.전반적으로 그의 조언은 좋습니다.그가 Lisp에 대해 말하는 것은 거의 일반적인 통념과 같습니다.그러나 일반적인 통념에는 모순이 있습니다. Lisp는 당신을 더 나은 프로그래머로 만들어 주지만 당신은 그것을 사용하지 않을 것입니다. 왜 안 될까요?프로그래밍 언어는 결국 도구일 뿐입니다.Lisp가 정말 더 나은 프로그램을 만들어낸다면 그것을 사용해야 합니다.그렇지 않다면 누가 그것을 필요로 합니까? 이것은 단지 이론적인 질문이 아닙니다.소프트웨어는 경쟁이 매우 치열한 사업이며 자연 독점이 발생하기 쉽습니다.소프트웨어를 더 빨리 작성하고 더 나은 의지를 갖는 회사는 다른 모든 조건이 동일할 때 경쟁업체를 퇴출시킵니다.그리고 스타트업을 시작할 때, 여러분은 이것을 매우 예민하게 느낍니다.스타트업은 전부 아니면 전무라는 제안을 하는 경향이 있습니다.당신은 부자가 되거나 아무것도 얻지 못합니다.스타트업에서는 잘못된 기술에 돈을 걸면 경쟁자들이 당신을 압도할 것입니다. 로버트와 저는 둘 다 Lisp를 잘 알고 있었고 우리의 본능을 믿지 않고 Lisp를 따르지 않을 이유가 전혀 없었습니다.우리는 다른 모든 사람들이 C++나 Perl로 소프트웨어를 작성하고 있다는 것을 알고 있었습니다.그러나 우리는 그것이 아무 의미도 없다는 것도 알고 있었습니다.그런 방식으로 기술을 선택했다면 Windows를 실행하게 될 것입니다.기술을 선택할 때는 다른 사람들이 하는 일을 무시하고 가장 효과적인 것만 고려해야 합니다. 특히 스타트업에서는 더욱 그렇습니다.대기업에서는 다른 대기업들이 하는 일을 당신도 할 수 있습니다.하지만 스타트업은 다른 모든 스타트업이 하는 일을 할 수는 없습니다.스타트업에서도 많은 사람들이 이것을 깨닫지 못하는 것 같아요. 평균적인 대기업은

1년에 10퍼센트 정도 빚을 지고 있어요.그러므로 당신이 큰 회사를 운영하고 있고 모든 것을 일반적인 큰 회사가 하는 방식으로 한다면, 당신은 평균적인 큰 회사만큼 잘 할 것을 기대할 수 있습니다. 즉, 연간 약 10%의 성장을 기대할 수 있습니다. 물론 스타트업을 운영하는 경우에도 같은 일이 일어날 것입니다.일반적인 스타트업이 하는 방식으로 모든 작업을 수행한다면 평균적인 성능을 기대할 수 있습니다.여기서 문제는 평균적인 성과는 곧 사업을 중단한다는 것을 의미한다는 것입니다.스타트업의 생존율은 50%도 채 되지 않습니다.따라서 스타트업을 운영하고 있다면 뭔가 이상한 일을 하는 것이 좋습니다.그렇지 않다면 문제가 발생합니다. 1995년에 우리는 경쟁자들이 이해하지 못할 것 같고 지금도 이해하는 사람이 거의 없다는 사실을 알고 있었습니다. 자체 서버에서만 실행되어야 하는 소프트웨어를 작성할 때 원하는 언어를 사용할 수 있다는 것입니다.데스크톱 소프트웨어를 작성할 때 운영 체제와 동일한 언어로 애플리케이션을 작성하려는 강한 편견이 있습니다.10년 전에는 애플리케이션을 작성한다는 것은 C로 애플리케이션을 작성하는 것을 의미했습니다. 그러나 웹 기반 소프트웨어의 경우, 특히 언어와 운영 체제의 소스 코드가 모두 있는 경우 원하는 언어를 무엇이든 사용할 수 있습니다. 그러나 이러한 새로운 자유는 양날의 검입니다.이제 어떤 언어든 사용할 수 있으므로 어떤 언어를 사용할지 고민해야 합니다.아무것도 변하지 않은 척하려고 노력하는 회사는 경쟁자가 변하지 않는다는 사실을 알게 될 위험이 있습니다. 어떤 언어든 사용할 수 있다면 어떤 언어를 사용하십니까?우리는 Lisp를 선택했습니다.우선, 이 시장에서는 빠른 발전이 중요할 것이 분명했습니다.우리는 모두 처음부터 시작했기 때문에 경쟁사보다 먼저 새로운 기능을 완료할 수 있는 회사는 큰 이점을 갖게 될 것입니다.우리는 Lisp가 소프트웨어를 빠르게 작성하는 데 정말 좋은 언어라는 것을 알고 있었고 서버 기반 애플리케이션은 소프트웨어가 완성되는 즉시 출시할 수 있기 때문에 빠른 개발의 효과를 확대합니다. 다른 회사가 Lisp를 사용하고 싶어하지 않는다면 훨씬 더 좋습니다.이는 우리에게 기술적 우위를 제공할 수 있었고 우리는 얻을 수 있는 모든 도움이 필요했습니다.Viaweb을 시작했을 때 우리는 사업 경험이 없었습니다.우리는 마케팅, 인력 채용, 자금 조달, 고객 유치에 대해 아무것도 몰랐습니다.우리 둘 다 당신이 진짜 직업이라고 부를 만한 일을 해본 적도 없었습니다.우리가 유일하게 잘한 것은 소프트웨어를 작성하는 것뿐이었습니다.우리는 그것이 우리를 구해주길 바랐습니다.소프트웨어 부서에서 얻을 수 있는 이점은 무엇이든 받아들였습니다. 따라서 Lisp를 사용하는 것은 실험이라고 말할 수 있습니다.우리의 가설은 Lisp로 소프트웨어를 작성하면 경쟁사보다 기능을 더 빠르게 수행할 수 있을 뿐만 아니라 경쟁사에서 할 수 없는 작업도 소프트웨어에서 수행할 수 있다는 것이었습니다.그리고 Lisp는 매우 수준이 높기 때문에 대규모 개발 팀이 필요하지 않으므로 비용이 더 낮아질 것입니다.그렇다면 우리는 더 적은 비용으로 더 나은 제품을 제공하면서도 여전히 이익을 얻을 수 있습니다.우리는 결국 모든 사용자를 확보하게 될 것이고, 경쟁업체는 아무것도 얻지 못하고 결국 사업을 중단하게 될 것입니다.어쨌든 우리는 그런 일이 일어나기를 바랐습니다. 이 실험의 결과는 어땠나요?다소 놀랍게도 효과가 있었습니다.결국에는 20~30개 정도의 경쟁업체가 생겼지만 그 어떤 소프트웨어도 우리 소프트웨어와 경쟁할 수 없었습니다.우리는 서버에서 실행되지만 데스크탑 애플리케이션처럼 느껴지는 wysiwyg 온라인 상점 빌더를 가지고 있었습니다.우리 경쟁업체에는 CGI 스크립트가 있었습니다.그리고 우리는 기능 면에서 항상 그들보다 훨씬 앞서 있었습니다.때로는 필사적으로 경쟁자들이 우리가 갖고 있지 않은 기능을 도입하려고 시도하기도 했습니다.하지만 Lisp를 사용하면 개발 주기가 너무 빨라서 때로는 경쟁사가 보도 자료를 통해 새로운 기능을 발표한 지 하루나 이틀 만에 새로운 기능을 복제할 수도 있었습니다.보도 자료를 취재하는 기자들이 우리에게 전화를 걸었을 때 우리도 새로운 기능을 갖게 되었을 것입니다. 경쟁자들에게는 우리가 일종의 비밀 무기를 가지고 있는 것처럼 보였을 것입니다. 즉, 우리가 그들의 Enigma 트래픽을 해독하고 있다는 것이었습니다.사실 우리에게는 비밀 무기가 있었지만 그것은 그들이 생각했던 것보다 더 간단했습니다.아무도 소식을 유출하지 않았어

우리에게 그들의 특징을 알려주세요.우리는 누구도 가능하다고 생각했던 것보다 더 빨리 소프트웨어를 개발할 수 있었습니다. 제가 9살쯤 되었을 때 저는 우연히 Frederick Forsyth의 The Day of the Jackal의 사본을 손에 넣었습니다.주인공은 프랑스 대통령을 살해하기 위해 고용된 암살자이다.암살자는 대통령의 경로가 내려다보이는 아파트에 도달하기 위해 경찰을 통과해야 합니다.그는 목발을 짚은 노인 복장을 하고 그들 바로 옆으로 걸어가지만 그들은 그를 전혀 의심하지 않습니다. 우리의 비밀 무기도 비슷했습니다.우리는 괄호로 가득 찬 이상한 구문을 사용하여 이상한 AI 언어로 소프트웨어를 작성했습니다.수년 동안 Lisp가 그런 식으로 설명하는 것을 듣는 것은 나를 짜증나게 했습니다.그러나 이제는 그것이 우리에게 유리하게 작용했습니다.비즈니스에서는 경쟁업체가 이해하지 못하는 기술적 이점보다 더 가치 있는 것은 없습니다.전쟁에서와 마찬가지로 비즈니스에서도 기습은 힘만큼 가치가 있습니다. 그래서 말하기가 조금 부끄럽지만 Viaweb을 작업하는 동안 나는 Lisp에 대해 공개적으로 말한 적이 없습니다.우리는 그것을 언론에 언급한 적이 없으며, 우리 웹사이트에서 Lisp를 검색하면 내 약력에 있는 책 두 권의 제목만 찾을 수 있습니다.이것은 우연이 아니었습니다.스타트업은 경쟁자에게 가능한 한 적은 정보를 제공해야 합니다.그들이 우리 소프트웨어가 어떤 언어로 작성되었는지 모르거나 관심이 없다면 그대로 유지하고 싶었습니다.[2]우리 기술을 가장 잘 이해하는 사람은 고객이었습니다.그들은 Viaweb이 어떤 언어로 작성되었는지 관심이 없었지만 그것이 정말 잘 작동한다는 것을 알았습니다.말 그대로 몇 분 만에 멋진 온라인 상점을 구축할 수 있게 되었습니다.그래서 주로 입소문을 통해 점점 더 많은 사용자를 확보하게 되었습니다.1996년 말까지 우리는 약 70개의 온라인 매장을 보유하게 되었습니다.1997년 말에는 500명이 있었습니다. 6개월 후 Yahoo가 우리를 인수했을 때 사용자는 1070명이었습니다.오늘날 Yahoo Store로서 이 소프트웨어는 계속해서 시장을 장악하고 있습니다.이는 야후에서 가장 수익성이 높은 제품 중 하나이며 이를 기반으로 구축된 매장은 야후 쇼핑의 기반입니다.저는 1999년에 Yahoo를 떠났기 때문에 지금은 사용자가 정확히 몇 명인지는 모르지만, 마지막으로 듣기로는 약 20,000명 정도라고 들었습니다.Blub Paradox Lisp의 장점은 무엇입니까?그리고 Lisp가 그렇게 훌륭하다면 왜 모든 사람이 그것을 사용하지 않습니까?이것은 수사학적인 질문처럼 들리지만 실제로는 간단한 답을 가지고 있습니다.Lisp가 그렇게 대단한 이유는 헌신적인 사람들에게만 보이는 마법 같은 특성 때문이 아니라 단순히 사용할 수 있는 가장 강력한 언어이기 때문입니다.그리고 모두가 그것을 사용하지 않는 이유는 프로그래밍 언어는 단순한 기술이 아니라 마음의 습관이기도 하고, 느리게 변하는 것은 아무것도 없기 때문입니다.물론, 이 두 대답 모두 설명이 필요합니다. 저는 충격적으로 논쟁의 여지가 있는 진술로 시작하겠습니다: 프로그래밍 언어의 힘은 다양합니다. 적어도 고급 언어가 기계 언어보다 더 강력하다는 점에 이의를 제기할 사람은 거의 없습니다.오늘날 대부분의 프로그래머는 일반적으로 기계어로 프로그래밍하고 싶지 않다는 데 동의합니다.대신, 고급 언어로 프로그래밍하고 컴파일러가 이를 기계어로 번역하도록 해야 합니다.이 아이디어는 이제 하드웨어에도 내장되어 있습니다. 1980년대 이후 명령어 세트는 인간 프로그래머가 아닌 컴파일러를 위해 설계되었습니다. 전체 프로그램을 기계어로 직접 작성하는 것이 실수라는 것은 누구나 알고 있습니다.덜 자주 이해되는 것은 여기에 더 일반적인 원칙이 있다는 것입니다. 즉, 여러 언어를 선택할 수 있는 경우 다른 모든 것이 동일하다면 가장 강력한 언어가 아닌 다른 언어로 프로그래밍하는 것은 실수라는 것입니다.[3] 이 규칙에는 많은 예외가 있습니다.특정 언어로 작성된 프로그램과 매우 밀접하게 작동해야 하는 프로그램을 작성하는 경우 동일한 언어로 새 프로그램을 작성하는 것이 좋습니다.숫자 처리나 비트 조작과 같이 매우 간단한 작업만 수행해야 하는 프로그램을 작성하는 경우 덜 추상적인 언어를 사용하는 것이 좋습니다. 특히 약간 더 빠를 수 있기 때문입니다.그리고 짧고 일회용 프로그램을 작성하는 경우 최고의 라이브러리 기능을 갖춘 언어를 사용하는 것이 더 나을 수도 있습니다.

작업에 대한 내용입니다.그러나 일반적으로 응용 프로그램 소프트웨어의 경우 얻을 수 있는 가장 강력한(합리적으로 효율적인) 언어를 사용하고 싶어하며, 다른 것을 사용하는 것은 기계 언어로 프로그래밍하는 것과 정확히 같은 종류의 실수입니다. 정도는 낮을 수 있지만 기계 언어는 매우 낮은 수준이라는 것을 알 수 있습니다.그러나 적어도 일종의 사회적 관습으로서 고급 언어는 모두 동등한 것으로 취급되는 경우가 많습니다.그렇지 않습니다.기술적으로 "고급 언어"라는 용어는 매우 명확한 의미를 의미하지 않습니다.한쪽에는 기계어가 있고 다른 한쪽에는 모든 고급 언어가 있다는 구분선이 없습니다.언어는 가장 강력한 것부터 기계어에 이르기까지 추상성의 연속체 [4]에 속하며, 그 자체의 힘은 다양합니다. Cobol을 생각해 보십시오.Cobol은 기계어로 컴파일된다는 점에서 고급 언어입니다.Cobol이 Python과 동등하다고 진지하게 주장할 사람이 있을까요?아마도 Python보다 기계어에 더 가깝습니다. 아니면 Perl 4는 어떻습니까?Perl 4와 Perl 5 사이에 어휘 클로저가 언어에 추가되었습니다.대부분의 Perl 해커는 Perl 5가 Perl 4보다 강력하다는 데 동의합니다. 그러나 일단 이를 인정하면 하나의 고급 언어가 다른 고급 언어보다 더 강력할 수 있다는 점을 인정한 것입니다.그리고 특별한 경우를 제외하고는 얻을 수 있는 가장 강력한 것을 사용해야 한다는 결론이 나옵니다. 하지만 이 아이디어가 결론에 도달하는 경우는 거의 없습니다.특정 연령이 지나면 프로그래머가 자발적으로 언어를 바꾸는 경우는 거의 없습니다.사람들은 어떤 언어에 익숙하든 그것만으로도 충분하다고 생각하는 경향이 있습니다. 프로그래머는 자신이 좋아하는 언어에 매우 애착을 갖고 있으며, 저는 다른 사람의 감정을 상하게 하고 싶지 않기 때문에 이 점을 설명하기 위해 Blub이라는 가상의 언어를 사용하겠습니다.Blub는 추상성 연속체의 한가운데에 위치합니다.가장 강력한 언어는 아니지만 Cobol이나 기계어보다 더 강력합니다. 그리고 사실 우리의 가상의 Blub 프로그래머는 둘 중 어느 것도 사용하지 않을 것입니다.물론 그는 기계어로 프로그래밍하지 않을 것이다.이것이 바로 컴파일러의 목적입니다.그리고 Cobol의 경우, 그는 누군가가 그걸 어떻게 처리할 수 있는지 모릅니다.x(귀하가 선택한 Blub 기능)도 없습니다. 가상의 Blub 프로그래머가 전력 연속체를 내려다보는 한 그는 자신이 내려다보고 있다는 것을 알고 있습니다.Blub보다 덜 강력한 언어는 그가 익숙한 일부 기능이 없기 때문에 분명히 덜 강력합니다.그러나 가상의 Blub 프로그래머가 다른 방향, 즉 전력 연속체를 바라볼 때 그는 자신이 위를 보고 있다는 사실을 깨닫지 못합니다.그가 보는 것은 단지 이상한 언어들일 뿐이다.그는 아마도 그것들이 Blub와 동등한 힘을 가지고 있다고 생각할 것입니다. 그러나 다른 모든 털이 많은 것들도 포함되어 있습니다.Blub은 그에게 충분합니다. 왜냐하면 그는 Blub에서 생각하기 때문입니다. 그러나 전력 연속체보다 더 높은 언어를 사용하는 프로그래머의 관점으로 전환하면 그도 Blub를 무시한다는 것을 알 수 있습니다.Blub에서는 어떻게 작업을 수행할 수 있나요?심지어 y도 없습니다. 귀납적으로 다양한 언어 간의 성능 차이를 모두 볼 수 있는 위치에 있는 유일한 프로그래머는 가장 강력한 언어를 이해하는 사람입니다.(이것은 아마도 Lisp가 당신을 더 나은 프로그래머로 만든다는 의미일 것입니다.) Blub 역설 때문에 다른 사람들의 의견을 믿을 수 없습니다. 그들은 어떤 언어를 사용하든 프로그램에 대해 생각하는 방식을 결정하기 때문에 어떤 언어를 사용하더라도 만족합니다. 나는 고등학생이 Basic으로 프로그램을 작성하면서 내 자신의 경험을 통해 이것을 알고 있습니다.해당 언어는 재귀도 지원하지 않았습니다.재귀를 사용하지 않고 프로그램을 작성한다는 것은 상상하기 힘든 일이지만 당시에는 이를 놓치지 않았습니다.나는 기본으로 생각했다.그리고 나는 그것에 능숙했습니다.제가 조사한 모든 것의 마스터입니다. Eric Raymond가 해커에게 권장하는 다섯 가지 언어는 권력 연속체의 다양한 지점에 속합니다.서로 상대적인 위치는 민감한 주제입니다.내가 말하려는 것은 Lisp가 맨 위에 있다고 생각한다는 것입니다.그리고 이를 지원하기 위해

다른 네 가지 언어를 볼 때 누락된 것 중 하나에 대해 말씀드리겠습니다.매크로 없이 어떻게 작업을 수행할 수 있을까요?[5] 많은 언어에는 매크로라는 것이 있습니다.그러나 Lisp 매크로는 독특합니다.믿거나 말거나, 그들이 하는 일은 괄호와 관련이 있습니다.Lisp의 디자이너들은 단지 다르게 하기 위해 언어에 괄호를 모두 넣은 것이 아닙니다.Blub 프로그래머에게 Lisp 코드는 이상하게 보입니다.그러나 이러한 괄호가 있는 데에는 이유가 있습니다.이는 Lisp와 다른 언어 간의 근본적인 차이점을 보여주는 외부 증거입니다. Lisp 코드는 Lisp 데이터 개체로 만들어집니다.그리고 소스 파일에 문자가 포함되어 있고 문자열이 언어에서 지원하는 데이터 유형 중 하나라는 사소한 의미는 아닙니다.Lisp 코드는 파서가 읽은 후 탐색할 수 있는 데이터 구조로 구성됩니다. 컴파일러가 어떻게 작동하는지 이해한다면 실제로 일어나는 일은 Lisp에 구문이 없기 때문에 Lisp에 이상한 구문이 있다는 것이 아닙니다.다른 언어가 구문 분석될 때 컴파일러 내에서 생성되는 구문 분석 트리에 프로그램을 작성합니다.그러나 이러한 구문 분석 트리는 프로그램에서 완전히 액세스할 수 있습니다.이를 조작하는 프로그램을 작성할 수 있습니다.Lisp에서는 이러한 프로그램을 매크로라고 합니다.프로그램을 작성하는 프로그램입니다.프로그램을 작성하는 프로그램?언제 그런 일을 하고 싶나요?Cobol에서 생각한다면 그리 자주는 아닙니다.Lisp에서 생각한다면 항상.여기서는 강력한 매크로의 예를 들어 설명할 수 있으면 편리할 것입니다!그건 어때?하지만 내가 그렇게 한다면 Lisp를 모르는 사람에게는 그저 횡설수설처럼 보일 것입니다.여기서는 그것이 의미하는 바를 이해하기 위해 알아야 할 모든 것을 설명할 공간이 없습니다.Ansi Common Lisp에서 나는 가능한 한 빨리 작업을 진행하려고 노력했지만 그럼에도 불구하고 160페이지까지 매크로에 도달하지 못했습니다. 그러나 설득력 있는 일종의 주장을 제시할 수 있다고 생각합니다.Viaweb 편집기의 소스 코드는 아마도 20~25% 정도의 매크로였을 것입니다.매크로는 일반 Lisp 함수보다 작성하기 어렵고, 필요하지 않을 때 사용하는 것은 좋지 않은 스타일로 간주됩니다.따라서 해당 코드의 모든 매크로는 있어야 하기 때문에 거기에 있습니다.이것이 의미하는 바는 이 프로그램 코드의 최소 20-25%가 다른 언어에서는 쉽게 할 수 없는 작업을 수행한다는 것입니다.Blub 프로그래머가 Lisp의 신비스러운 힘에 대한 나의 주장에 대해 아무리 회의적일지라도, 이것이 그를 궁금해하게 만들 것입니다.우리는 우리 자신의 즐거움을 위해 이 코드를 작성한 것이 아닙니다.우리는 작은 스타트업이었고 경쟁사와 기술적인 장벽을 쌓기 위해 최선을 다해 프로그래밍했습니다. 의심스러운 사람은 여기에 어떤 상관관계가 있는지 궁금해하기 시작할 수도 있습니다.우리 코드의 상당 부분은 다른 언어에서는 수행하기 매우 어려운 작업을 수행하고 있었습니다.그 결과 소프트웨어는 경쟁사의 소프트웨어가 할 수 없는 일을 해냈습니다.어쩌면 어떤 종류의 연관성이 있었을 수도 있습니다.나는 당신이 그 스레드를 따르도록 권장합니다.목발을 짚고 절뚝거리고 있는 그 노인에게는 눈에 보이는 것보다 더 많은 일이 있을 수 있습니다. 스타트업을 위한 합기도 그러나 나는 누군가(25세 이상)가 나가서 Lisp을 배우도록 설득할 것이라고 기대하지 않습니다.이 기사의 목적은 누군가의 마음을 바꾸려는 것이 아니라 이미 Lisp 사용에 관심이 있는 사람들, 즉 Lisp가 강력한 언어라는 것을 알고 있지만 널리 사용되지 않기 때문에 걱정하는 사람들을 안심시키기 위한 것입니다.경쟁 상황에서는 그것이 유리하다.Lisp의 힘은 경쟁자들이 그것을 이해하지 못한다는 사실로 인해 배가됩니다. 스타트업에서 Lisp를 사용할 생각이라면 그것이 널리 이해되지 않는다는 점을 걱정할 필요가 없습니다.계속 그런 상태가 유지되길 바라야 합니다.그리고 그럴 가능성이 높습니다.대부분의 사람들이 현재 사용하는 모든 것에 만족하도록 만드는 것이 프로그래밍 언어의 특성입니다.컴퓨터 하드웨어는 개인적인 습관보다 훨씬 빠르게 변화하므로 프로그래밍 연습은 일반적으로 프로세서보다 10~20년 정도 뒤쳐집니다.MIT와 같은 곳에서는 1960년대 초반에 고급 언어로 프로그램을 작성했지만, 많은 회사에서는 1980년대까지도 계속해서 기계어로 코드를 작성했습니다.나

많은 사람들이 프로세서가 문을 닫고 집에 가고 싶어하는 바텐더처럼 결국 위험한 명령어 세트로 전환하여 그들을 쫓아낼 때까지 계속해서 기계어를 작성했을 것입니다. 일반적으로 기술은 빠르게 변화합니다.그러나 프로그래밍 언어는 다릅니다. 프로그래밍 언어는 단순한 기술이 아니라 프로그래머가 생각하는 것입니다. 절반은 기술이고 절반은 종교입니다.[6]따라서 중앙값 프로그래머가 사용하는 언어가 무엇이든 의미하는 중앙값 언어는 빙산만큼 느리게 움직입니다.1960년경 Lisp에 의해 도입된 가비지 수집은 이제 좋은 것으로 널리 간주됩니다.런타임 타이핑도 마찬가지입니다. 인기가 높아지고 있습니다.1970년대 초 Lisp가 도입한 어휘 폐쇄는 이제 레이더 화면에 거의 나타나지 않습니다.1960년대 중반 Lisp에 의해 소개된 매크로는 여전히 테라 미크지타(terra incognita)입니다. 분명히 중간 언어는 엄청난 추진력을 가지고 있습니다.나는 당신이 이 강력한 세력과 싸울 수 있다고 제안하는 것이 아닙니다.제가 제안하는 것은 정반대입니다. 합기도 수련자처럼 상대방을 상대로 이를 사용할 수 있다는 것입니다. 대기업에서 일한다면 이것이 쉽지 않을 수도 있습니다.20년 전 Ada처럼 다른 언어가 세계를 장악할 준비가 되어 있다는 기사를 방금 신문에서 읽었을 때 뾰족한 머리의 상사가 Lisp에서 무언가를 만들 수 있도록 설득하는 데 어려움을 겪을 것입니다.하지만 아직 뾰족한 상사가 없는 스타트업에서 일한다면 우리처럼 Blub의 역설을 유리하게 활용할 수 있습니다. 즉, 중간 언어에 굳건히 붙어 있는 경쟁업체가 결코 따라잡을 수 없는 기술을 사용할 수 있습니다. 스타트업에서 일하게 된다면 경쟁사를 평가할 수 있는 유용한 팁이 여기에 있습니다.채용 정보를 읽어보세요.사이트의 다른 모든 것은 스톡 사진이거나 이에 상응하는 산문일 수 있지만 구인 목록은 원하는 것이 구체적이어야 합니다. 그렇지 않으면 잘못된 후보자를 얻게 될 것입니다. 수년 동안 Viaweb에서 근무하는 동안 저는 직무 설명을 많이 읽었습니다.매달 새로운 경쟁자가 목공 분야에서 등장하는 것 같았습니다.내가 실시간 온라인 데모가 있는지 확인한 후 가장 먼저 할 일은 채용 목록을 살펴보는 것이었습니다.몇 년이 지난 후에 나는 어떤 회사에 대해 걱정해야 할지, 어떤 회사에서는 걱정하지 않아도 될지 알 수 있었습니다.직무 설명에 IT 성향이 많을수록 회사의 위험은 줄어듭니다.가장 안전한 종류는 Oracle 경험을 원하는 사람들이었습니다.당신은 그것에 대해 걱정할 필요가 없었습니다.C++이나 Java 개발자를 원한다고 해도 안전합니다.그들이 Perl이나 Python 프로그래머를 원했다면 그것은 다소 무서웠을 것입니다. 적어도 기술적인 측면은 실제 해커가 운영하는 회사처럼 들리기 시작했습니다.Lisp 해커를 찾는 구인 공고를 본 적이 있었다면 정말 걱정했을 것입니다.참고[1] Viaweb은 처음에는 사람들이 사이트를 구축하는 데 사용했던 Lisp로 작성된 편집기와 주문을 처리하는 C로 작성된 주문 시스템의 두 부분으로 구성되었습니다.첫 번째 버전은 주문 시스템이 작았기 때문에 대부분 Lisp였습니다.나중에 우리는 두 개의 모듈, 즉 C로 작성된 이미지 생성기와 대부분 Perl로 작성된 백오피스 관리자를 추가했습니다. 2003년 1월 Yahoo는 C++ 및 Perl로 작성된 새 버전의 편집기를 출시했습니다.하지만 프로그램이 더 이상 Lisp로 작성되지 않았는지 말하기는 어렵습니다. 왜냐하면 이 프로그램을 C++로 번역하려면 말 그대로 Lisp 인터프리터를 작성해야 했기 때문입니다. 내가 아는 한 모든 페이지 생성 템플릿의 소스 파일은 여전히 ​​Lisp 코드입니다.(Greenspun의 10번째 규칙을 참조하십시오.)[2] Robert Morris는 경쟁업체가 우리가 Lisp를 사용하고 있다는 것을 알았더라도 그 이유를 이해하지 못했을 것이기 때문에 비밀로 할 필요가 없다고 말했습니다. "그들이 그렇게 똑똑했다면 그들은 이미 Lisp로 프로그래밍하고 있었을 것입니다."[3] 모든 언어는 Turing과 동등하다는 점에서 동등하게 강력하지만 프로그래머가 관심을 갖는 단어의 의미는 아닙니다.(튜링 기계를 프로그래밍하고 싶어하는 사람은 없습니다.) 강력한 프로그래머가 관심을 갖는 유형은 공식적으로 정의할 수 없지만 이를 설명하는 한 가지 방법은 다음과 같습니다.

t는 더 강력한 언어에 대한 통역사를 작성하여 덜 강력한 언어에서만 얻을 수 있는 기능을 나타냅니다.언어 A에는 문자열에서 공백을 제거하는 연산자가 있고 언어 B에는 없으면 B에서 이를 수행하기 위한 서브루틴을 작성할 수 있기 때문에 A를 더 강력하게 만들지 못할 것입니다. 그러나 예를 들어 A가 재귀를 지원하고 B는 지원하지 않는 경우 라이브러리 함수를 작성하여 해결할 수 있는 문제는 아닐 것입니다.[4]괴상한 참고 사항: 또는 위쪽으로 좁아지는 격자일 수도 있습니다.여기서 중요한 것은 모양이 아니라 적어도 부분적인 순서가 있다는 생각입니다.[5]매크로를 별도의 기능으로 취급하는 것은 약간 오해의 소지가 있습니다.실제로 그 유용성은 어휘 폐쇄 및 나머지 매개변수와 같은 다른 Lisp 기능에 의해 크게 향상됩니다.[6]결과적으로 프로그래밍 언어의 비교는 종교 전쟁의 형태를 취하거나 매우 중립적이어서 실제로는 인류학 작품인 학부 교과서의 형태를 취합니다.평화를 소중히 여기거나 임기를 원하는 사람들은 주제를 피합니다.그러나 문제는 종교적인 문제의 절반에 불과합니다.특히 새로운 언어를 디자인하고 싶다면 공부할 가치가 있는 것이 있습니다. 자세한 기술 세부 사항일본어 번역터키어 번역우즈벡어 번역Orbitz는 Lisp도 사용합니다How To Be A HackerA Scheme Story이탈리아어 번역 Hackers & Painters에서 이 에세이와 14개의 다른 에세이를 찾을 수 있습니다.

---

## 원문 (Original Essay)

Want to start a startup? Get funded by Y Combinator. April 2001, rev. April 2003(This article is derived from a talk given at the 2001 Franz Developer Symposium.) In the summer of 1995, my friend Robert Morris and I started a startup called Viaweb. Our plan was to write software that would let end users build online stores. What was novel about this software, at the time, was that it ran on our server, using ordinary Web pages as the interface.A lot of people could have been having this idea at the same time, of course, but as far as I know, Viaweb was the first Web-based application. It seemed such a novel idea to us that we named the company after it: Viaweb, because our software worked via the Web, instead of running on your desktop computer.Another unusual thing about this software was that it was written primarily in a programming language called Lisp. It was one of the first big end-user applications to be written in Lisp, which up till then had been used mostly in universities and research labs. [1]The Secret WeaponEric Raymond has written an essay called "How to Become a Hacker," and in it, among other things, he tells would-be hackers what languages they should learn. He suggests starting with Python and Java, because they are easy to learn. The serious hacker will also want to learn C, in order to hack Unix, and Perl for system administration and cgi scripts. Finally, the truly serious hacker should consider learning Lisp: Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot. This is the same argument you tend to hear for learning Latin. It won't get you a job, except perhaps as a classics professor, but it will improve your mind, and make you a better writer in languages you do want to use, like English.But wait a minute. This metaphor doesn't stretch that far. The reason Latin won't get you a job is that no one speaks it. If you write in Latin, no one can understand you. But Lisp is a computer language, and computers speak whatever language you, the programmer, tell them to.So if Lisp makes you a better programmer, like he says, why wouldn't you want to use it? If a painter were offered a brush that would make him a better painter, it seems to me that he would want to use it in all his paintings, wouldn't he? I'm not trying to make fun of Eric Raymond here. On the whole, his advice is good. What he says about Lisp is pretty much the conventional wisdom. But there is a contradiction in the conventional wisdom: Lisp will make you a better programmer, and yet you won't use it.Why not? Programming languages are just tools, after all. If Lisp really does yield better programs, you should use it. And if it doesn't, then who needs it?This is not just a theoretical question. Software is a very competitive business, prone to natural monopolies. A company that gets software written faster and better will, all other things being equal, put its competitors out of business. And when you're starting a startup, you feel this very keenly. Startups tend to be an all or nothing proposition. You either get rich, or you get nothing. In a startup, if you bet on the wrong technology, your competitors will crush you.Robert and I both knew Lisp well, and we couldn't see any reason not to trust our instincts and go with Lisp. We knew that everyone else was writing their software in C++ or Perl. But we also knew that that didn't mean anything. If you chose technology that way, you'd be running Windows. When you choose technology, you have to ignore what other people are doing, and consider only what will work the best.This is especially true in a startup. In a big company, you can do what all the other big companies are doing. But a startup can't do what all the other startups do. I don't think a lot of people realize this, even in startups.The average big company grows at about ten percent a year. So if you're running a big company and you do everything the way the average big company does it, you can expect to do as well as the average big company-- that is, to grow about ten percent a year.The same thing will happen if you're running a startup, of course. If you do everything the way the average startup does it, you should expect average performance. The problem here is, average performance means that you'll go out of business. The survival rate for startups is way less than fifty percent. So if you're running a startup, you had better be doing something odd. If not, you're in trouble.Back in 1995, we knew something that I don't think our competitors understood, and few understand even now: when you're writing software that only has to run on your own servers, you can use any language you want. When you're writing desktop software, there's a strong bias toward writing applications in the same language as the operating system. Ten years ago, writing applications meant writing applications in C. But with Web-based software, especially when you have the source code of both the language and the operating system, you can use whatever language you want.This new freedom is a double-edged sword, however. Now that you can use any language, you have to think about which one to use. Companies that try to pretend nothing has changed risk finding that their competitors do not.If you can use any language, which do you use? We chose Lisp. For one thing, it was obvious that rapid development would be important in this market. We were all starting from scratch, so a company that could get new features done before its competitors would have a big advantage. We knew Lisp was a really good language for writing software quickly, and server-based applications magnify the effect of rapid development, because you can release software the minute it's done.If other companies didn't want to use Lisp, so much the better. It might give us a technological edge, and we needed all the help we could get. When we started Viaweb, we had no experience in business. We didn't know anything about marketing, or hiring people, or raising money, or getting customers. Neither of us had ever even had what you would call a real job. The only thing we were good at was writing software. We hoped that would save us. Any advantage we could get in the software department, we would take.So you could say that using Lisp was an experiment. Our hypothesis was that if we wrote our software in Lisp, we'd be able to get features done faster than our competitors, and also to do things in our software that they couldn't do. And because Lisp was so high-level, we wouldn't need a big development team, so our costs would be lower. If this were so, we could offer a better product for less money, and still make a profit. We would end up getting all the users, and our competitors would get none, and eventually go out of business. That was what we hoped would happen, anyway.What were the results of this experiment? Somewhat surprisingly, it worked. We eventually had many competitors, on the order of twenty to thirty of them, but none of their software could compete with ours. We had a wysiwyg online store builder that ran on the server and yet felt like a desktop application. Our competitors had cgi scripts. And we were always far ahead of them in features. Sometimes, in desperation, competitors would try to introduce features that we didn't have. But with Lisp our development cycle was so fast that we could sometimes duplicate a new feature within a day or two of a competitor announcing it in a press release. By the time journalists covering the press release got round to calling us, we would have the new feature too.It must have seemed to our competitors that we had some kind of secret weapon-- that we were decoding their Enigma traffic or something. In fact we did have a secret weapon, but it was simpler than they realized. No one was leaking news of their features to us. We were just able to develop software faster than anyone thought possible.When I was about nine I happened to get hold of a copy of The Day of the Jackal, by Frederick Forsyth. The main character is an assassin who is hired to kill the president of France. The assassin has to get past the police to get up to an apartment that overlooks the president's route. He walks right by them, dressed up as an old man on crutches, and they never suspect him.Our secret weapon was similar. We wrote our software in a weird AI language, with a bizarre syntax full of parentheses. For years it had annoyed me to hear Lisp described that way. But now it worked to our advantage. In business, there is nothing more valuable than a technical advantage your competitors don't understand. In business, as in war, surprise is worth as much as force.And so, I'm a little embarrassed to say, I never said anything publicly about Lisp while we were working on Viaweb. We never mentioned it to the press, and if you searched for Lisp on our Web site, all you'd find were the titles of two books in my bio. This was no accident. A startup should give its competitors as little information as possible. If they didn't know what language our software was written in, or didn't care, I wanted to keep it that way.[2]The people who understood our technology best were the customers. They didn't care what language Viaweb was written in either, but they noticed that it worked really well. It let them build great looking online stores literally in minutes. And so, by word of mouth mostly, we got more and more users. By the end of 1996 we had about 70 stores online. At the end of 1997 we had 500. Six months later, when Yahoo bought us, we had 1070 users. Today, as Yahoo Store, this software continues to dominate its market. It's one of the more profitable pieces of Yahoo, and the stores built with it are the foundation of Yahoo Shopping. I left Yahoo in 1999, so I don't know exactly how many users they have now, but the last I heard there were about 20,000. The Blub ParadoxWhat's so great about Lisp? And if Lisp is so great, why doesn't everyone use it? These sound like rhetorical questions, but actually they have straightforward answers. Lisp is so great not because of some magic quality visible only to devotees, but because it is simply the most powerful language available. And the reason everyone doesn't use it is that programming languages are not merely technologies, but habits of mind as well, and nothing changes slower. Of course, both these answers need explaining.I'll begin with a shockingly controversial statement: programming languages vary in power.Few would dispute, at least, that high level languages are more powerful than machine language. Most programmers today would agree that you do not, ordinarily, want to program in machine language. Instead, you should program in a high-level language, and have a compiler translate it into machine language for you. This idea is even built into the hardware now: since the 1980s, instruction sets have been designed for compilers rather than human programmers.Everyone knows it's a mistake to write your whole program by hand in machine language. What's less often understood is that there is a more general principle here: that if you have a choice of several languages, it is, all other things being equal, a mistake to program in anything but the most powerful one. [3]There are many exceptions to this rule. If you're writing a program that has to work very closely with a program written in a certain language, it might be a good idea to write the new program in the same language. If you're writing a program that only has to do something very simple, like number crunching or bit manipulation, you may as well use a less abstract language, especially since it may be slightly faster. And if you're writing a short, throwaway program, you may be better off just using whatever language has the best library functions for the task. But in general, for application software, you want to be using the most powerful (reasonably efficient) language you can get, and using anything else is a mistake, of exactly the same kind, though possibly in a lesser degree, as programming in machine language.You can see that machine language is very low level. But, at least as a kind of social convention, high-level languages are often all treated as equivalent. They're not. Technically the term "high-level language" doesn't mean anything very definite. There's no dividing line with machine languages on one side and all the high-level languages on the other. Languages fall along a continuum [4] of abstractness, from the most powerful all the way down to machine languages, which themselves vary in power.Consider Cobol. Cobol is a high-level language, in the sense that it gets compiled into machine language. Would anyone seriously argue that Cobol is equivalent in power to, say, Python? It's probably closer to machine language than Python.Or how about Perl 4? Between Perl 4 and Perl 5, lexical closures got added to the language. Most Perl hackers would agree that Perl 5 is more powerful than Perl 4. But once you've admitted that, you've admitted that one high level language can be more powerful than another. And it follows inexorably that, except in special cases, you ought to use the most powerful you can get.This idea is rarely followed to its conclusion, though. After a certain age, programmers rarely switch languages voluntarily. Whatever language people happen to be used to, they tend to consider just good enough.Programmers get very attached to their favorite languages, and I don't want to hurt anyone's feelings, so to explain this point I'm going to use a hypothetical language called Blub. Blub falls right in the middle of the abstractness continuum. It is not the most powerful language, but it is more powerful than Cobol or machine language.And in fact, our hypothetical Blub programmer wouldn't use either of them. Of course he wouldn't program in machine language. That's what compilers are for. And as for Cobol, he doesn't know how anyone can get anything done with it. It doesn't even have x (Blub feature of your choice).As long as our hypothetical Blub programmer is looking down the power continuum, he knows he's looking down. Languages less powerful than Blub are obviously less powerful, because they're missing some feature he's used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn't realize he's looking up. What he sees are merely weird languages. He probably considers them about equivalent in power to Blub, but with all this other hairy stuff thrown in as well. Blub is good enough for him, because he thinks in Blub.When we switch to the point of view of a programmer using any of the languages higher up the power continuum, however, we find that he in turn looks down upon Blub. How can you get anything done in Blub? It doesn't even have y.By induction, the only programmers in a position to see all the differences in power between the various languages are those who understand the most powerful one. (This is probably what Eric Raymond meant about Lisp making you a better programmer.) You can't trust the opinions of the others, because of the Blub paradox: they're satisfied with whatever language they happen to use, because it dictates the way they think about programs.I know this from my own experience, as a high school kid writing programs in Basic. That language didn't even support recursion. It's hard to imagine writing programs without using recursion, but I didn't miss it at the time. I thought in Basic. And I was a whiz at it. Master of all I surveyed.The five languages that Eric Raymond recommends to hackers fall at various points on the power continuum. Where they fall relative to one another is a sensitive topic. What I will say is that I think Lisp is at the top. And to support this claim I'll tell you about one of the things I find missing when I look at the other four languages. How can you get anything done in them, I think, without macros? [5]Many languages have something called a macro. But Lisp macros are unique. And believe it or not, what they do is related to the parentheses. The designers of Lisp didn't put all those parentheses in the language just to be different. To the Blub programmer, Lisp code looks weird. But those parentheses are there for a reason. They are the outward evidence of a fundamental difference between Lisp and other languages.Lisp code is made out of Lisp data objects. And not in the trivial sense that the source files contain characters, and strings are one of the data types supported by the language. Lisp code, after it's read by the parser, is made of data structures that you can traverse.If you understand how compilers work, what's really going on is not so much that Lisp has a strange syntax as that Lisp has no syntax. You write programs in the parse trees that get generated within the compiler when other languages are parsed. But these parse trees are fully accessible to your programs. You can write programs that manipulate them. In Lisp, these programs are called macros. They are programs that write programs.Programs that write programs? When would you ever want to do that? Not very often, if you think in Cobol. All the time, if you think in Lisp. It would be convenient here if I could give an example of a powerful macro, and say there! how about that? But if I did, it would just look like gibberish to someone who didn't know Lisp; there isn't room here to explain everything you'd need to know to understand what it meant. In Ansi Common Lisp I tried to move things along as fast as I could, and even so I didn't get to macros until page 160.But I think I can give a kind of argument that might be convincing. The source code of the Viaweb editor was probably about 20-25% macros. Macros are harder to write than ordinary Lisp functions, and it's considered to be bad style to use them when they're not necessary. So every macro in that code is there because it has to be. What that means is that at least 20-25% of the code in this program is doing things that you can't easily do in any other language. However skeptical the Blub programmer might be about my claims for the mysterious powers of Lisp, this ought to make him curious. We weren't writing this code for our own amusement. We were a tiny startup, programming as hard as we could in order to put technical barriers between us and our competitors.A suspicious person might begin to wonder if there was some correlation here. A big chunk of our code was doing things that are very hard to do in other languages. The resulting software did things our competitors' software couldn't do. Maybe there was some kind of connection. I encourage you to follow that thread. There may be more to that old man hobbling along on his crutches than meets the eye.Aikido for StartupsBut I don't expect to convince anyone (over 25) to go out and learn Lisp. The purpose of this article is not to change anyone's mind, but to reassure people already interested in using Lisp-- people who know that Lisp is a powerful language, but worry because it isn't widely used. In a competitive situation, that's an advantage. Lisp's power is multiplied by the fact that your competitors don't get it.If you think of using Lisp in a startup, you shouldn't worry that it isn't widely understood. You should hope that it stays that way. And it's likely to. It's the nature of programming languages to make most people satisfied with whatever they currently use. Computer hardware changes so much faster than personal habits that programming practice is usually ten to twenty years behind the processor. At places like MIT they were writing programs in high-level languages in the early 1960s, but many companies continued to write code in machine language well into the 1980s. I bet a lot of people continued to write machine language until the processor, like a bartender eager to close up and go home, finally kicked them out by switching to a risc instruction set.Ordinarily technology changes fast. But programming languages are different: programming languages are not just technology, but what programmers think in. They're half technology and half religion.[6] And so the median language, meaning whatever language the median programmer uses, moves as slow as an iceberg. Garbage collection, introduced by Lisp in about 1960, is now widely considered to be a good thing. Runtime typing, ditto, is growing in popularity. Lexical closures, introduced by Lisp in the early 1970s, are now, just barely, on the radar screen. Macros, introduced by Lisp in the mid 1960s, are still terra incognita.Obviously, the median language has enormous momentum. I'm not proposing that you can fight this powerful force. What I'm proposing is exactly the opposite: that, like a practitioner of Aikido, you can use it against your opponents.If you work for a big company, this may not be easy. You will have a hard time convincing the pointy-haired boss to let you build things in Lisp, when he has just read in the paper that some other language is poised, like Ada was twenty years ago, to take over the world. But if you work for a startup that doesn't have pointy-haired bosses yet, you can, like we did, turn the Blub paradox to your advantage: you can use technology that your competitors, glued immovably to the median language, will never be able to match.If you ever do find yourself working for a startup, here's a handy tip for evaluating competitors. Read their job listings. Everything else on their site may be stock photos or the prose equivalent, but the job listings have to be specific about what they want, or they'll get the wrong candidates.During the years we worked on Viaweb I read a lot of job descriptions. A new competitor seemed to emerge out of the woodwork every month or so. The first thing I would do, after checking to see if they had a live online demo, was look at their job listings. After a couple years of this I could tell which companies to worry about and which not to. The more of an IT flavor the job descriptions had, the less dangerous the company was. The safest kind were the ones that wanted Oracle experience. You never had to worry about those. You were also safe if they said they wanted C++ or Java developers. If they wanted Perl or Python programmers, that would be a bit frightening-- that's starting to sound like a company where the technical side, at least, is run by real hackers. If I had ever seen a job posting looking for Lisp hackers, I would have been really worried. Notes[1] Viaweb at first had two parts: the editor, written in Lisp, which people used to build their sites, and the ordering system, written in C, which handled orders. The first version was mostly Lisp, because the ordering system was small. Later we added two more modules, an image generator written in C, and a back-office manager written mostly in Perl.In January 2003, Yahoo released a new version of the editor written in C++ and Perl. It's hard to say whether the program is no longer written in Lisp, though, because to translate this program into C++ they literally had to write a Lisp interpreter: the source files of all the page-generating templates are still, as far as I know, Lisp code. (See Greenspun's Tenth Rule.)[2] Robert Morris says that I didn't need to be secretive, because even if our competitors had known we were using Lisp, they wouldn't have understood why: "If they were that smart they'd already be programming in Lisp."[3] All languages are equally powerful in the sense of being Turing equivalent, but that's not the sense of the word programmers care about. (No one wants to program a Turing machine.) The kind of power programmers care about may not be formally definable, but one way to explain it would be to say that it refers to features you could only get in the less powerful language by writing an interpreter for the more powerful language in it. If language A has an operator for removing spaces from strings and language B doesn't, that probably doesn't make A more powerful, because you can probably write a subroutine to do it in B. But if A supports, say, recursion, and B doesn't, that's not likely to be something you can fix by writing library functions.[4] Note to nerds: or possibly a lattice, narrowing toward the top; it's not the shape that matters here but the idea that there is at least a partial order.[5] It is a bit misleading to treat macros as a separate feature. In practice their usefulness is greatly enhanced by other Lisp features like lexical closures and rest parameters.[6] As a result, comparisons of programming languages either take the form of religious wars or undergraduate textbooks so determinedly neutral that they're really works of anthropology. People who value their peace, or want tenure, avoid the topic. But the question is only half a religious one; there is something there worth studying, especially if you want to design new languages.More Technical DetailsJapanese TranslationTurkish TranslationUzbek TranslationOrbitz Uses Lisp TooHow To Become A HackerA Scheme StoryItalian Translation You'll find this essay and 14 others in Hackers & Painters.

---

_분석일: 2025. 11. 29._
_수집일: 2025. 11. 28._
