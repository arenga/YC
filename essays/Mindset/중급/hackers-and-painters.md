# Hackers and Painters
**카테고리**: Mindset
**난이도**: 중급
**출판일**: N/A
**원문**: https://paulgraham.com/hp.html
---
## 요약 (Summary)

🎯 해커와 화가는 어떻게 비슷할까요?

✨ 핵심 내용 요약

Paul Graham의 유명한 에세이: **해커는 화가처럼 일합니다**. 둘 다 "만드는 사람(makers)"이기 때문입니다.

화가는 어떻게 일할까요? 스케치 → 수정 → 다시 수정. 완벽한 계획 없이 시작합니다. 해커도 마찬가지입니다: 프로토타입 → 테스트 → 리팩토링. 설계 문서부터 만들지 않습니다. 학교는 반대로 가르칩니다: "계획 → 실행". 하지만 창조적인 일은 그렇게 안 됩니다. 만들면서 배웁니다. 한국 기업의 문제: "기획서부터 완벽하게". 하지만 스타트업은 "일단 만들고 고친다". 어느 쪽이 빠를까요? 당연히 후자입니다.

**핵심 포인트**
• 해커는 화가처럼 일합니다
• 만들면서 배웁니다
• 완벽한 계획보다 빠른 실행이 낫습니다

🚀 오늘 바로 실천해볼 한 가지
기획서를 쓰는 대신, 오늘 1시간 동안 프로토타입을 만들어보세요.

---

## 한국어 번역 (Korean Translation)

2003년 5월(이 에세이는 노스이스턴에서의 이전 강연을 통합한 하버드에서의 초청 강연에서 파생되었습니다.) 저는 컴퓨터 과학 대학원을 마친 후 미술 학교에 가서 회화를 공부했습니다.컴퓨터에 관심이 있는 사람이 그림에도 관심을 갖는다는 사실에 많은 사람들이 놀란 것 같았습니다.그들은 해킹과 페인팅이 매우 다른 종류의 작업이라고 생각하는 것 같았습니다. 해킹은 차갑고 정확하며 체계적이며 페인팅은 어떤 원초적 충동의 광적인 표현이라고 생각하는 것 같았습니다. 이 두 이미지는 모두 잘못된 것입니다.해킹과 페인팅은 공통점이 많습니다.사실, 제가 아는 다양한 유형의 사람들 중에서 해커와 화가는 가장 비슷합니다. 해커와 화가의 공통점은 둘 다 제작자라는 것입니다.작곡가, 건축가, 작가와 함께 해커, 화가들이 하려는 일은 좋은 것을 만드는 일이다.그들은 연구 자체를 하지 않습니다. 하지만 좋은 것을 만들려고 노력하는 과정에서 새로운 기술을 발견하면 훨씬 더 좋습니다. 저는 "컴퓨터 과학"이라는 용어를 결코 좋아하지 않습니다.내가 그것을 좋아하지 않는 가장 큰 이유는 그런 것이 없다는 것입니다.컴퓨터 과학은 유고슬라비아처럼 역사의 우연에 의해 합쳐진 미약한 관련 분야의 집합체입니다.한쪽에는 실제로 수학자이지만 DARPA 보조금을 받기 위해 컴퓨터 과학을 하고 있는 사람들이 있습니다.중간에는 컴퓨터의 자연사와 같은 작업을 하는 사람들이 있습니다. 예를 들어 네트워크를 통해 데이터를 라우팅하는 알고리즘의 동작을 연구합니다.그리고 다른 극단에는 흥미로운 소프트웨어를 작성하려고 하는 해커가 있습니다. 이들에게 컴퓨터는 건축가에게 콘크리트가, 화가에게 페인트가 그러하듯이 단지 표현의 매체일 뿐입니다.마치 수학자, 물리학자, 건축가가 모두 같은 부서에 있어야 하는 것 같습니다. 해커가 하는 일을 '소프트웨어 엔지니어링'이라고 부르기도 하는데 이 용어도 마찬가지로 오해를 불러일으킵니다.좋은 소프트웨어 디자이너는 건축가와 마찬가지로 엔지니어가 아닙니다.건축과 엔지니어링의 경계는 명확하게 정의되어 있지 않지만 존재합니다.그것은 무엇과 어떻게 사이에 있습니다. 건축가는 무엇을 해야할지 결정하고 엔지니어는 그것을 수행하는 방법을 알아냅니다. 무엇과 방법을 너무 분리해서는 안됩니다.어떻게 해야 할지 이해하지 못한 채 무엇을 할지 결정하려고 하면 문제가 발생하는 것입니다.그러나 해킹은 특정 사양을 구현하는 방법을 결정하는 것 이상일 수 있습니다.최선의 방법은 사양을 만드는 것입니다. 하지만 이를 수행하는 가장 좋은 방법은 사양을 구현하는 것입니다. 아마도 언젠가 "컴퓨터 과학"은 유고슬라비아처럼 구성 요소로 분리될 것입니다.그것은 좋은 일이 될 수 있습니다.특히 그것이 내 조국의 독립을 의미한다면 해킹입니다. 이러한 다양한 유형의 업무를 한 부서에 함께 묶는 것은 행정적으로는 편리할 수 있지만 지적으로는 혼란스럽습니다.이것이 내가 "컴퓨터 과학"이라는 이름을 좋아하지 않는 또 다른 이유입니다.아마도 중간에 있는 사람들은 실험적인 과학과 같은 일을 하고 있을 것입니다.그러나 양쪽 끝에 있는 사람들, 즉 해커와 수학자들은 실제로 과학을 하고 있는 것이 아닙니다. 수학자들은 이것에 신경 쓰지 않는 것 같습니다.그들은 수학과에 있는 다른 수학자들처럼 정리를 증명하는 일에 즐겁게 착수했고, 아마도 그들이 일하는 건물 외부에 "컴퓨터 과학"이라고 적혀 있다는 사실을 곧 알아차리지 못할 것입니다.그러나 해커들에게는 이 라벨이 문제가 됩니다.만약 그들이 하고 있는 일이 과학이라고 불린다면, 그것은 그들이 과학적으로 행동해야 한다고 느끼게 만듭니다.따라서 대학과 연구실의 해커들은 그들이 정말로 하고 싶은 일, 즉 아름다운 소프트웨어를 설계하는 대신 연구 논문을 작성해야 한다고 생각합니다. 가장 좋은 경우, 논문은 형식에 불과합니다.해커는 멋진 소프트웨어를 작성하고 이에 대한 논문을 작성하며, 이 논문은 소프트웨어가 나타내는 성과의 대용물이 됩니다.그러나 종종 이러한 불일치로 인해 문제가 발생합니다.아름다운 것을 만드는 것에서 더 많은 것을 만들어내는 추악한 것을 만드는 쪽으로 표류하기 쉽습니다.

연구 논문에 적합한 주제. 불행하게도 아름다운 것이 항상 논문 주제에 가장 적합한 것은 아닙니다.첫째, 연구는 독창적이어야 합니다. 박사 학위 논문을 쓴 사람이라면 누구나 알고 있듯이 처녀 영역을 탐험하고 있는지 확인하는 방법은 아무도 원하지 않는 땅을 확보하는 것입니다.둘째, 연구는 실질적이어야 합니다. 그리고 일을 완수하기 위해 극복해야 하는 장애물에 대해 쓸 수 있기 때문에 어색한 시스템은 더 좋은 논문을 만들어냅니다.잘못된 가정으로 시작하는 것만큼 심각한 문제는 발생하지 않습니다.대부분의 AI는 이 규칙의 예입니다.지식이 추상적 개념을 나타내는 인수를 갖는 술어 논리 표현식의 목록으로 표현될 수 있다고 가정하면 이 작업을 수행하는 방법에 대해 작성해야 할 많은 논문이 있을 것입니다.Ricky Ricardo가 "Lucy, 설명할 것이 너무 많아요."라고 말하곤 했습니다. 아름다운 것을 창조하는 방법은 종종 이미 존재하는 것을 미묘하게 수정하거나 기존 아이디어를 약간 새로운 방식으로 결합하는 것입니다.이런 작업은 연구논문으로 전달하기 힘든데 왜 대학이나 연구소에서는 계속해서 출판물로 해커를 판단하는 걸까요?'학업 적성'이 단순한 표준화 시험으로 측정되거나, 프로그래머의 생산성이 코드 라인으로 측정되는 것과 같은 이유입니다.이러한 테스트는 적용하기 쉽고, 작동하기 쉬운 테스트만큼 매력적인 것은 없습니다. 해커가 실제로 무엇을 하려고 하는지 측정하고 아름다운 소프트웨어를 설계하는 것은 훨씬 더 어려울 것입니다.좋은 디자인을 판단하려면 좋은 디자인 감각이 필요합니다.그리고 좋은 디자인을 인식하는 사람들의 능력과 그럴 수 있다는 자신감 사이에는 부정적인 상관관계를 제외하면 아무런 상관관계가 없습니다. 유일한 외부 테스트는 시간입니다.시간이 지남에 따라 아름다운 것은 번성하고, 추악한 것은 폐기되는 경향이 있습니다.불행히도, 관련된 시간은 인간의 수명보다 길 수 있습니다.사무엘 존슨은 작가의 명성이 수렴되는 데 100년이 걸린다고 말했습니다.작가의 영향력 있는 친구들이 죽을 때까지 기다려야 하고, 그 다음에는 그들의 추종자들도 모두 죽을 때까지 기다려야 합니다. 제 생각에는 해커들은 자신의 평판에 큰 무작위 요소가 있다는 사실을 체념해야 한다고 생각합니다.이 점에서는 다른 메이커와 다르지 않습니다.사실, 그들은 상대적으로 운이 좋았습니다.해킹에서는 회화만큼 패션의 영향력이 크지 않습니다. 사람들이 당신의 작품을 오해하는 것보다 더 나쁜 것이 있습니다.더 나쁜 위험은 당신이 당신의 일을 오해한다는 것입니다.관련 분야는 아이디어를 찾는 곳입니다.예를 들어, 컴퓨터 공학과에 근무하는 경우 해킹은 이론적 컴퓨터 과학의 이론을 응용한 것이라고 믿고 싶은 자연스러운 유혹이 있습니다.대학원에 다니는 내내 마음 한구석에는 이론을 더 많이 알아야 한다는 불편한 감정이 있었고, 기말고사를 치르고 3주 안에 그 모든 것을 잊어버린 것이 너무 아쉽다는 생각이 들었습니다. 이제야 제가 착각했다는 것을 깨달았습니다.화가가 페인트 화학을 이해하는 데 필요한 만큼 해커는 계산 이론을 이해해야 합니다.시간과 공간 복잡도를 계산하는 방법과 튜링 완전성에 대해 알아야 합니다.파서나 정규식 라이브러리를 작성해야 하는 경우를 대비하여 최소한 상태 기계의 개념을 기억하고 싶을 수도 있습니다.사실 화가들은 페인트 화학에 대해 그보다 훨씬 더 많은 것을 기억해야 합니다. 저는 아이디어의 가장 좋은 원천은 이름에 "컴퓨터"라는 단어가 있는 다른 분야가 아니라 제작자가 거주하는 다른 분야라는 것을 발견했습니다.그림은 계산 이론보다 훨씬 더 풍부한 아이디어의 원천이었습니다. 예를 들어, 저는 대학에서 컴퓨터 근처에 접근하기 전에 종이 위에서 프로그램을 완전히 알아내야 한다고 배웠습니다.나는 이런 식으로 프로그래밍하지 않았다는 것을 발견했습니다.나는 종이 한 장보다는 컴퓨터 앞에 앉아 프로그래밍하는 것을 좋아한다는 것을 깨달았다.더 나쁜 것은 p 대신

나는 완전한 프로그램을 천천히 작성하고 그것이 정확하다고 스스로 확신하면서 절망적으로 깨진 코드를 뱉어내고 점차적으로 두드려서 형태를 갖추는 경향이 있었습니다.디버깅은 오타와 실수를 잡아내는 일종의 최종 단계라고 배웠습니다.내가 일하는 방식은 마치 프로그래밍이 디버깅으로 이루어진 것처럼 보였습니다. 오랫동안 나는 이것에 대해 안타까움을 느꼈습니다. 한때 초등학교에서 가르쳐준 대로 연필을 잡지 않아서 안타까웠던 것처럼 말입니다.다른 제작자, 화가, 건축가 등을 살펴봤더라면 내가 하고 있는 일에도 이름이 있다는 것을 깨달았을 것이다. 바로 스케치다.내가 아는 한, 대학에서 나에게 프로그래밍을 가르친 방식은 모두 잘못된 것이었다.작가, 화가, 건축가처럼 프로그램을 작성하면서 프로그램을 파악해야 합니다. 이를 깨닫는 것은 소프트웨어 설계에 실질적인 영향을 미칩니다.이는 프로그래밍 언어가 무엇보다 유연해야 함을 의미합니다.프로그래밍 언어는 이미 생각한 프로그램을 표현하기 위한 것이 아니라 프로그램을 생각하기 위한 것입니다.펜이 아니라 연필이어야 합니다.사람들이 실제로 대학에서 나에게 가르친 방식으로 프로그램을 작성했다면 정적 타이핑은 좋은 아이디어가 될 것입니다.하지만 내가 아는 해커 중 누구도 그런 방식으로 프로그램을 작성하지 않습니다.우리에게는 찻잔을 무릎 위에 놓고 앉아서 엄격한 컴파일러의 아주머니와 예의바르게 대화를 나누는 언어가 아니라, 낙서하고, 더럽히고, 번지게 할 수 있는 언어가 필요합니다. 우리가 정적 타이핑에 관해 이야기하는 동안 제작자와 동일시하면 과학을 괴롭히는 또 다른 문제인 수학 부러움으로부터 우리를 구할 수 있습니다.과학 분야의 모든 사람들은 수학자들이 그들보다 더 똑똑하다고 비밀리에 믿습니다.나는 수학자들도 이것을 믿는다고 생각한다.어쨌든 결과적으로 과학자들은 자신의 작업을 가능한 한 수학적으로 보이게 만드는 경향이 있습니다.물리학과 같은 분야에서는 이것이 별로 해를 끼치지 않을 것입니다. 그러나 자연 과학에서 더 멀리 갈수록 문제는 더 커집니다. 공식 페이지는 정말 인상적입니다.(팁: 더욱 인상적인 효과를 얻으려면 그리스어 변수를 사용하십시오.) 따라서 중요한 문제보다는 공식적으로 처리할 수 있는 문제를 작업하고 싶은 큰 유혹이 있습니다. 해커가 작가나 화가와 같은 다른 제작자와 동일시한다면 그들은 이렇게 하고 싶은 유혹을 느끼지 않을 것입니다.작가와 화가는 수학에 대한 부러움을 느끼지 않습니다.그들은 전혀 관련이 없는 일을 하고 있는 것처럼 느낍니다.해커도 마찬가지라고 생각합니다. 대학과 연구실에서 해커가 원하는 작업을 수행하지 못하게 한다면 아마도 해커가 있을 곳은 회사일 것입니다.불행하게도 대부분의 회사는 해커가 원하는 것을 허용하지 않습니다.대학과 연구실에서는 해커에게 과학자를 강요하고, 기업에서는 엔지니어를 강요합니다. 저는 이것을 최근에서야 스스로 발견했습니다.Yahoo가 Viaweb을 인수했을 때 그들은 나에게 무엇을 하고 싶은지 물었습니다.나는 비즈니스 측면을 별로 좋아하지 않았으며 단지 해킹하고 싶었다고 말했습니다.Yahoo에 입사했을 때 해킹이 그들에게 의미하는 바는 소프트웨어를 설계하는 것이 아니라 소프트웨어를 구현하는 것임을 알게 되었습니다.프로그래머는 제품 관리자의 비전(말하자면)을 코드로 번역하는 기술자로 여겨졌습니다. 이것이 대기업의 기본 계획인 것 같습니다.결과의 표준편차가 감소하기 때문에 그렇게 합니다.실제로 소프트웨어를 설계할 수 있는 해커는 극히 일부에 불과하며, 회사를 운영하는 사람들이 이러한 소프트웨어를 선택하는 것은 어렵습니다.그래서 소프트웨어의 미래를 뛰어난 해커 한 명에게 맡기는 대신, 대부분의 회사에서는 위원회에서 설계하도록 설정하고 해커는 설계만 구현합니다. 언젠가 돈을 벌고 싶다면 이것을 기억하세요. 이것이 스타트업이 승리하는 이유 중 하나이기 때문입니다.대기업은 재난을 피하고 싶기 때문에 설계 결과의 표준 편차를 줄이고 싶어합니다.그러나 진동을 감쇠시키면 낮은 점뿐만 아니라 높은 점도 잃게 됩니다.대기업은 훌륭한 제품을 만들어서 승리할 수 없기 때문에 이는 문제가 되지 않습니다.비

IG 회사는 다른 대기업보다 덜 빨아먹는 방식으로 승리합니다. 따라서 제품 관리자가 소프트웨어를 설계할 정도로 큰 회사와 디자인 전쟁을 벌일 수 있는 방법을 찾아낸다면 그 회사는 결코 당신을 따라잡을 수 없을 것입니다.하지만 이러한 기회는 찾기가 쉽지 않습니다.성 안의 적과 백병전을 벌이는 것이 어려운 것처럼, 대기업과 디자인 전쟁을 벌이는 것도 어렵습니다.예를 들어, Microsoft Word보다 더 나은 워드 프로세서를 작성하는 것은 꽤 쉬울 것입니다. 그러나 운영 체제 독점이라는 성 안에 있는 Microsoft는 아마도 여러분이 그렇게 했는지조차 알아채지 못할 것입니다. 디자인 전쟁에 맞서 싸울 곳은 아직 아무도 요새를 구축하지 못한 새로운 시장입니다.디자인에 대한 대담한 접근 방식을 취하고 동일한 사람들이 제품을 디자인하고 구현하도록 함으로써 큰 ​​승리를 거둘 수 있는 곳입니다.Microsoft 자체도 처음에는 이 작업을 수행했습니다.애플도 마찬가지였다.그리고 휴렛팩커드.나는 거의 모든 성공적인 스타트업이 그랬다고 생각합니다. 따라서 훌륭한 소프트웨어를 구축하는 한 가지 방법은 자신만의 스타트업을 시작하는 것입니다.하지만 여기에는 두 가지 문제가 있습니다.하나는 스타트업에서는 소프트웨어를 작성하는 것 외에도 많은 일을 해야 한다는 것입니다.Viaweb에서 나는 4분의 1의 시간을 해킹할 수 있다면 운이 좋다고 생각했습니다.그리고 나머지 4분의 3 동안 내가 해야 할 일은 지루한 것부터 무서운 것까지 다양했습니다.나는 이것에 대한 벤치마크를 가지고 있습니다. 한번은 충치를 채우기 위해 이사회를 떠나야 했기 때문입니다.치과 의자에 편안히 앉아 훈련을 기다리며 마치 휴가 중인 것 같은 기분이 들었던 기억이 납니다. 스타트업의 또 다른 문제는 돈을 버는 소프트웨어와 작성하기에 흥미로운 소프트웨어 사이에 겹치는 부분이 많지 않다는 것입니다.프로그래밍 언어는 작성하기에 흥미롭고 실제로 Microsoft의 첫 번째 제품이 하나였지만 지금은 누구도 프로그래밍 언어에 비용을 지불하지 않을 것입니다.돈을 벌고 싶다면 누구라도 무료로 풀 수 없는 너무 고약한 문제를 억지로 해결해야 하는 경향이 있습니다. 메이커라면 누구나 이 문제에 직면해 있습니다.가격은 수요와 공급에 의해 결정되며, 개인 고객의 일상적인 문제를 해결하는 것만큼 즐겁게 일할 수 있는 것에 대한 수요는 많지 않습니다.오프 브로드웨이 연극에 출연하는 것은 무역 박람회 부스에서 고릴라 의상을 입은 것만큼 돈도 들지 않습니다.소설을 쓰는 것은 쓰레기 처리를 위한 광고 카피를 쓰는 것만큼 돈도 들지 않습니다.그리고 프로그래밍 언어를 해킹하는 것은 회사의 레거시 데이터베이스를 웹 서버에 연결하는 방법을 알아내는 것뿐만 아니라 비용도 들지 않습니다. 소프트웨어의 경우 이 문제에 대한 답은 거의 모든 제조업체가 알고 있는 개념인 일상 업무라고 생각합니다.이 표현은 밤에 연주하는 음악가들에게서 시작되었습니다.더 일반적으로 말하면, 돈을 위해 하는 일과 사랑을 위해 하는 일이 있다는 것을 의미합니다. 거의 모든 제작자는 경력 초기에 본업을 갖습니다.화가와 작가들은 그렇게 하는 것으로 악명이 높습니다.운이 좋다면 실제 업무와 밀접하게 관련된 본업을 구할 수 있습니다.음악가들은 종종 레코드 가게에서 일하는 것 같습니다.일부 프로그래밍 언어나 운영 체제를 사용하는 해커도 이를 사용하여 하루 일과를 얻을 수 있습니다.[1] 해커들이 본업을 갖고 부업으로 아름다운 소프트웨어를 작업하는 것이 답이라고 말할 때, 나는 이것을 새로운 아이디어로 제안하는 것이 아닙니다.오픈소스 해킹이 바로 이것이다.내가 말하고자 하는 것은 오픈 소스가 아마도 올바른 모델일 것이라는 것입니다. 왜냐하면 오픈 소스는 다른 모든 제작자에 의해 독립적으로 확인되었기 때문입니다. 어떤 고용주라도 해커가 오픈 소스 프로젝트에 참여하는 것을 꺼린다는 것은 놀라운 일인 것 같습니다.Viaweb에서는 그렇지 않은 사람을 채용하는 것을 꺼렸을 것입니다.프로그래머를 인터뷰할 때 우리가 가장 중요하게 생각한 것은 그들이 여가 시간에 어떤 종류의 소프트웨어를 작성하느냐였습니다.좋아하지 않는 한 어떤 일도 제대로 할 수 없으며, 해킹을 좋아한다면 필연적으로 자신만의 프로젝트를 진행하게 될 것입니다.[2]해커는 과학자가 아니라 제작자이기 때문에 은유를 찾아야 할 올바른 곳은 과학이 아니라 아몬이다.

g 다른 종류의 메이커.그림이 해킹에 관해 우리에게 또 무엇을 가르쳐 줄 수 있습니까? 그림의 예에서 우리가 배울 수 있거나 적어도 확인할 수 있는 한 가지는 해킹을 배우는 방법입니다.당신은 주로 그림을 그리는 법을 배웁니다.해킹에도 마찬가지입니다.대부분의 해커는 대학 프로그래밍 과정을 수강하여 해킹하는 방법을 배우지 않습니다.그들은 13세에 자신만의 프로그램을 작성하여 해킹하는 법을 배웁니다.대학 수업에서도 해킹을 주로 해킹으로 배운다.[3] 화가들은 작업의 흔적을 남기기 때문에 그들이 작업을 통해 배우는 모습을 지켜볼 수 있습니다.화가의 작품을 연대순으로 살펴보면, 각 그림은 이전 그림에서 배운 내용을 바탕으로 구성되어 있음을 알 수 있습니다.그림에 매우 잘 작동하는 것이 있으면 일반적으로 이전 그림에서 더 작은 형태의 버전 1을 찾을 수 있습니다. 대부분의 제작자가 이런 식으로 작업하는 것 같습니다.작가나 건축가도 마찬가지인 것 같다.아마도 해커가 한 프로젝트에서 수년간 계속 작업하고 이후의 모든 아이디어를 수정본으로 통합하려고 하는 대신 화가처럼 행동하고 정기적으로 처음부터 다시 시작하는 것이 좋을 것입니다. 해커가 해킹을 통해 해킹을 배운다는 사실은 해킹이 과학과 얼마나 다른지를 보여주는 또 다른 신호입니다.과학자들은 과학을 함으로써 배우는 것이 아니라 실험실과 문제 세트를 통해 배웁니다.과학자들은 다른 사람이 이미 수행한 작업을 재현하려고 한다는 의미에서 완벽한 작업을 시작합니다.결국 그들은 독창적인 작업을 할 수 있는 지점에 도달합니다.반면 해커는 처음부터 독창적인 작업을 수행합니다.정말 안 좋은 일이에요.따라서 해커는 독창적으로 시작하여 좋은 결과를 얻고, 과학자는 좋은 시작으로 독창적인 결과를 얻습니다.제작자가 배우는 또 다른 방법은 사례를 통해서입니다.화가에게 박물관은 기술의 참고 도서관입니다.수백 년 동안 위대한 거장의 작품을 모방하는 것은 화가들의 전통적인 교육의 일부였습니다. 왜냐하면 복사를 하면 그림이 만들어지는 방식을 면밀히 살펴보게 되기 때문입니다. 작가들도 이것을 합니다.벤저민 프랭클린은 애디슨과 스틸의 에세이에 있는 요점을 요약하고 이를 재현해 보면서 글쓰기를 배웠습니다.Raymond Chandler는 탐정 이야기에서도 같은 일을 했습니다. 마찬가지로 해커도 좋은 프로그램을 보고 프로그래밍하는 법을 배울 수 있습니다. 자신이 하는 일뿐만 아니라 소스 코드도 살펴보세요.오픈 소스 운동의 덜 알려진 이점 중 하나는 프로그래밍을 배우기가 더 쉬워졌다는 것입니다.제가 프로그래밍을 배울 때 우리는 주로 책에 나오는 예제에 의존해야 했습니다.당시 사용 가능한 큰 코드 덩어리는 Unix였지만 이것도 오픈 소스는 아니었습니다.출처를 읽는 대부분의 사람들은 John Lions의 책의 불법 복사본에서 그것을 읽었습니다. 이 책은 1977년에 작성되었지만 1996년까지 출판이 허용되지 않았습니다. 그림에서 볼 수 있는 또 다른 예는 그림이 점진적인 세련을 통해 만들어지는 방식입니다.그림은 대개 스케치로 시작됩니다.점차적으로 세부 사항이 채워집니다. 하지만 단순히 채워 넣는 과정만은 아닙니다. 때로는 원래 계획이 잘못된 것으로 판명되기도 합니다.셀 수 없이 많은 그림들을 엑스레이로 보면 팔다리가 움직이거나 얼굴 특징이 재조정된 것으로 밝혀집니다. 여기 우리가 그림을 통해 배울 수 있는 사례가 있습니다.해킹도 이런 식으로 진행되어야 한다고 생각합니다.프로그램의 사양이 완벽할 것이라고 기대하는 것은 비현실적입니다.이를 미리 인정하고 사양을 즉시 변경할 수 있는 방식으로 프로그램을 작성하는 것이 더 나을 것입니다.(대기업의 구조로 인해 이를 수행하기가 어렵기 때문에 스타트업이 이점을 누릴 수 있는 또 다른 곳이 있습니다.) 이제 누구나 성급한 최적화의 위험성에 대해 알고 있을 것입니다.나는 우리가 조기 설계에 대해 걱정해야 한다고 생각합니다. 프로그램이 무엇을 해야 할지 너무 일찍 결정하는 것입니다. 올바른 도구는 이러한 위험을 피하는 데 도움이 될 수 있습니다.좋은 프로그래밍 언어는 유화처럼 마음을 쉽게 바꿀 수 있어야 합니다.동적 타이핑은 특정 데이터 표현을 미리 약속할 필요가 없기 때문에 여기서 승리합니다.

하지만 유연성의 핵심은 언어를 매우 추상적으로 만드는 것이라고 생각합니다.변경하기 가장 쉬운 프로그램은 매우 짧은 프로그램입니다.이것은 역설처럼 들리지만 훌륭한 그림은 실제보다 더 좋아야 합니다.예를 들어, Leonardo가 국립 미술관에 Ginevra de Benci의 초상화를 그렸을 때, 그는 그녀의 머리 뒤에 노간주나무 덤불을 두었습니다.그 안에 그는 잎사귀 하나하나를 조심스럽게 그렸습니다.많은 화가들은 이것이 단지 그녀의 머리를 장식하기 위해 배경에 넣는 것일 뿐이라고 생각했을 것입니다.아무도 그것을 자세히 보지 않을 것입니다.레오나르도는 아닙니다.그가 그림의 일부를 얼마나 열심히 작업했는지는 누군가가 그림을 얼마나 자세히 보기를 기대하는지에 전혀 좌우되지 않았습니다.그는 마이클 조던과 같았습니다.Relentless.잔인함이 승리하는 이유는 전체적으로 볼 때 보이지 않는 세부 사항이 눈에 보이기 때문입니다.사람들이 지네브라 데 벤치(Ginevra de Benci)의 초상화 옆을 지나갈 때, 라벨을 보고 레오나르도 다빈치(Leonardo da Vinci)라고 적힌 것을 알아차리기 전에도 그들의 관심은 즉시 그 초상화에 사로잡힙니다.보이지 않는 모든 세부 사항이 결합되어 거의 들리지 않는 수천 개의 목소리가 모두 조화롭게 노래하는 것처럼 놀라운 것을 만들어냅니다. 마찬가지로 훌륭한 소프트웨어에는 아름다움에 대한 광적인 헌신이 필요합니다.좋은 소프트웨어의 내부를 들여다보면, 누구도 볼 수 없는 부분도 아름답다는 것을 알게 됩니다.제가 훌륭한 소프트웨어를 작성한다고 주장하는 것은 아니지만, 일상 생활에 같은 방식으로 접근한다면 코드에 관해서는 처방약을 받을 자격이 되는 방식으로 행동한다는 것을 알고 있습니다.들여쓰기가 잘못되었거나 보기 흉한 변수 이름을 사용하는 코드를 보면 미칠 것 같습니다. 해커가 사양을 코드로 바꾸는 단순한 구현자라면 그는 도랑을 파는 사람처럼 한쪽 끝에서 다른 쪽 끝까지 작업을 수행할 수 있습니다.하지만 해커가 창작자라면 영감을 고려해야 합니다. 해킹에서도 작업은 그림과 마찬가지로 순환적으로 이루어집니다.때때로 당신은 어떤 새로운 프로젝트에 흥미를 갖고 하루에 16시간씩 그 일을 하고 싶을 때가 있습니다.어떤 때는 아무 것도 흥미롭지 않을 때도 있습니다. 좋은 일을 하려면 이러한 주기를 고려해야 합니다. 왜냐하면 주기는 여러분이 반응하는 방식에 따라 영향을 받기 때문입니다.언덕에서 수동 변속기를 장착한 자동차를 운전할 때 가끔은 실속을 피하기 위해 클러치에서 물러나야 합니다.물러서면 야망이 중단되는 것을 방지할 수도 있습니다.페인팅과 해킹에는 엄청나게 야심 찬 작업이 있고 편안하게 일상적인 작업도 있습니다.다른 방법으로는 작업이 중단될 수 있는 순간을 위해 몇 가지 쉬운 작업을 저장해 두는 것이 좋습니다. 해킹에서 이는 문자 그대로 버그를 저장하는 것을 의미할 수 있습니다.저는 디버깅을 좋아합니다. 해킹이 사람들이 생각하는 것만큼 간단했던 때가 바로 이때였습니다.당신은 완전히 제한된 문제를 가지고 있고, 당신이 해야 할 일은 그것을 해결하는 것뿐입니다.귀하의 프로그램은 x를 수행해야 합니다.대신 y를 수행합니다.어디가 잘못됐나요?당신은 결국 승리할 것이라는 것을 알고 있습니다.그것은 벽에 그림을 그리는 것처럼 마음을 편안하게 해줍니다. 그림의 예는 우리에게 자신의 작업을 관리하는 방법뿐만 아니라 함께 일하는 방법도 가르쳐 줍니다.과거의 위대한 예술품 중 상당수는 여러 사람의 손이 만든 작품입니다. 하지만 박물관 옆 벽에는 이름이 하나만 걸려 있을 수도 있습니다.Leonardo는 Verrocchio 작업장의 견습생이었으며 그리스도의 세례에서 천사 중 한 명을 그렸습니다.이런 종류의 일은 예외가 아닌 규칙이었습니다.미켈란젤로는 특히 시스티나 성당 천장의 모든 인물을 직접 그리겠다고 고집한 사람으로 여겨졌습니다. 제가 아는 한, 화가들이 함께 그림을 그릴 때 그들은 결코 같은 부분을 작업하지 않았습니다.주인이 주요 인물을 그리고 보조자가 나머지 인물과 배경을 그리는 것이 일반적이었습니다.하지만 한 사람이 다른 사람의 작업 위에 그림을 그리는 일은 한 번도 없었습니다. 저는 이것이 소프트웨어 협업에도 적합한 모델이라고 생각합니다.너무 멀리 밀지 마십시오.코드 조각이 3~4명의 다른 사람들에 의해 해킹당할 때, 실제로 그 코드를 소유한 사람은 아무도 없으며 결국 휴게실처럼 될 것입니다.황량하고 버림받은 듯한 느낌이 들며, 잔해가 쌓이는 경향이 있습니다.제가 생각하는 올바른 협업 방식은

프로젝트를 명확하게 정의된 모듈로 나누고 각 모듈에는 명확한 소유자가 있으며 세심하게 설계되고 가능하면 프로그래밍 언어처럼 표현된 모듈 간의 인터페이스가 있습니다. 페인팅과 마찬가지로 대부분의 소프트웨어는 인간 청중을 대상으로 합니다.따라서 화가와 마찬가지로 해커도 정말 훌륭한 작업을 수행하려면 공감 능력이 있어야 합니다.사용자의 관점에서 사물을 볼 수 있어야 합니다. 어렸을 때 나는 항상 다른 사람의 관점에서 사물을 보라는 말을 들었습니다.이것이 실제로 실제로 의미하는 바는 내가 원하는 것이 아니라 다른 사람이 원하는 것을 하는 것이었습니다.물론 이것은 공감에 나쁜 이름을 주었고 나는 그것을 기르지 않기로 결정했습니다. 아, 내가 틀렸어요.다른 사람의 관점에서 사물을 바라보는 것이 사실상 성공의 비결인 것으로 밝혀졌습니다.반드시 자기 희생을 의미하는 것은 아닙니다.그것과는 거리가 멀다.다른 사람이 사물을 어떻게 보는지 이해한다고 해서 당신이 그 사람의 이익을 위해 행동한다는 의미는 아닙니다.어떤 상황에서는(예를 들어 전쟁에서) 정반대의 작업을 수행하고 싶을 수도 있습니다.[4]대부분의 제작자는 인간 청중을 위해 제품을 만듭니다.그리고 청중의 관심을 끌기 위해서는 그들이 필요로 하는 것이 무엇인지 이해해야 합니다.예를 들어, 거의 모든 가장 위대한 그림은 사람을 그린 그림입니다. 왜냐하면 사람들이 관심을 갖는 것은 사람이기 때문입니다. 공감은 아마도 훌륭한 해커와 위대한 해커 사이의 가장 중요한 차이점일 것입니다.일부 해커는 매우 똑똑하지만 공감에 관한 한 사실상 유아론자입니다.그러한 사람들이 훌륭한 소프트웨어를 설계하는 것은 어렵습니다. 왜냐하면 그들은 사용자의 관점에서 사물을 볼 수 없기 때문입니다. 사람들이 얼마나 공감 능력이 좋은지 알 수 있는 한 가지 방법은 그들이 기술적인 배경이 없는 사람에게 기술적인 질문을 설명하는 것을 지켜보는 것입니다.아마도 우리 모두는 똑똑하기는 하지만 이 일에는 우스꽝스러울 정도로 서투른 사람들을 알고 있을 것입니다.누군가 저녁 파티에서 그들에게 프로그래밍 언어가 무엇인지 묻는다면, 그들은 "아, 고급 언어는 컴파일러가 목적 코드를 생성하기 위해 입력으로 사용하는 언어입니다." 고급 언어요?컴파일러?객체 코드?프로그래밍 언어가 무엇인지 모르는 사람은 분명히 이러한 것들이 무엇인지도 모릅니다. 소프트웨어가 해야 할 일 중 하나는 그 자체를 설명하는 것입니다.따라서 좋은 소프트웨어를 작성하려면 사용자가 얼마나 적은지 이해해야 합니다.그들은 아무런 준비 없이 소프트웨어를 향해 걸어갈 것이고, 매뉴얼을 읽지 않을 것이기 때문에 그들이 예상하는 대로 하는 것이 더 나을 것입니다.이 점에서 내가 본 최고의 시스템은 1985년의 오리지널 Macintosh였습니다. Macintosh는 소프트웨어가 거의 하지 못했던 일을 해냈습니다. 바로 작동했습니다.[6] 소스 코드도 그 자체를 설명해야 합니다.사람들에게 프로그래밍에 관한 인용문 하나만 기억하게 할 수 있다면 그것은 컴퓨터 프로그램의 구조와 해석의 시작 부분에 나오는 인용문일 것입니다.프로그램은 사람들이 읽을 수 있도록 작성되어야 하며, 기계가 실행할 수 있도록 부수적으로만 작성되어야 합니다.사용자뿐만 아니라 독자에게도 공감이 필요합니다.당신이 그들 중 하나가 될 것이기 때문에 그것은 당신의 관심사입니다.많은 해커가 프로그램을 작성했지만 6개월 후에 다시 그 프로그램이 어떻게 작동하는지 전혀 알지 못한다는 사실을 발견했습니다.나는 그런 경험을 한 후에 Perl을 그만두기로 한 몇몇 사람들을 알고 있습니다.[7] 공감의 부족은 지능과 관련이 있으며, 일부 지역에서는 이를 유행시키는 경향이 있습니다.하지만 저는 상관관계가 없다고 생각합니다.수학과 자연과학은 공감을 배우지 않고도 잘할 수 있고, 이 분야에 종사하는 사람들은 똑똑한 경향이 있기 때문에 두 가지 특성이 연관되게 되었습니다.하지만 공감 능력이 부족한 멍청한 사람들도 많이 있습니다.토크쇼에서 질문을 가지고 전화하는 사람들의 말을 들어보세요.그들은 질문하는 것이 무엇이든 질문을 진행자가 종종 질문을 바꾸어 주어야 할 정도로 우회적인 방식으로 질문합니다. 해킹이 그림 그리기나 글쓰기처럼 작동한다면 그렇게 멋진가요?결국, 당신은 단 한번의 생명만을 얻습니다.뭔가 훌륭한 일을 하는 데 시간을 투자하는 것이 나을 수도 있습니다. 안타깝게도 그 질문에 대답하기는 어렵습니다.항상 큰 시간이 있어

g 명성에.그것은 먼 별에서 오는 빛과 같습니다.회화는 오늘날 사람들이 500년 전에 이룩한 위대한 작품 때문에 명성을 얻었습니다.당시에는 누구도 이 그림이 오늘날 우리만큼 중요하다고 생각하지 않았습니다.우르비노 공작 페데리코 다 몬테펠트로가 언젠가 피에로 델라 프란체스카의 그림에 나오는 이상한 코를 가진 남자로 주로 알려지게 된다면 그 당시 사람들에게는 매우 이상하게 보였을 것입니다. 그래서 해킹이 지금은 그림만큼 멋있어 보이지 않는다는 것을 인정하지만, 우리는 그림 자체가 전성기 시절에는 지금처럼 멋져 보이지 않았다는 것을 기억해야 합니다. 우리가 어느 정도 자신있게 말할 수 있는 것은 지금이 해킹의 전성기라는 것입니다.대부분의 분야에서 훌륭한 작업은 초기에 완료됩니다.1430년에서 1500년 사이에 그려진 그림은 여전히 ​​타의 추종을 불허합니다.셰익스피어는 전문 연극이 탄생하던 시기에 등장했고, 이후 모든 극작가가 그의 그림자 속에서 살아야 할 정도로 매체를 밀어붙였습니다.Albrecht Durer는 판화 작업에 동일한 작업을 수행했고 Jane Austen은 소설 작업에 동일한 작업을 수행했습니다. 계속해서 동일한 패턴을 볼 수 있습니다.새로운 매체가 등장하고 사람들은 그것에 대해 매우 열광하여 처음 몇 세대 동안 그 가능성의 대부분을 탐구합니다.해킹은 현재 이 단계에 있는 것 같습니다. 레오나르도 시대의 회화는 그의 작품이 작품을 만드는 데 도움이 된 것만큼 멋지지 않았습니다.해킹이 얼마나 멋진지는 우리가 이 새로운 매체로 무엇을 할 수 있는지에 달려 있습니다.참고[1] 사진이 회화에 끼친 가장 큰 피해는 아마도 최고의 직업을 죽였다는 사실일 것입니다.역사상 가장 위대한 화가들은 대부분 초상화를 그리며 생계를 유지했습니다.[2] Microsoft는 직원들이 여가 시간에도 오픈 소스 프로젝트에 기여하는 것을 권장하지 않는다고 들었습니다.그러나 현재 수많은 최고의 해커들이 오픈 소스 프로젝트에 참여하고 있기 때문에 이 정책의 주요 효과는 이들이 일류 프로그래머를 고용하지 못하도록 하는 것일 수도 있습니다.[3]대학에서 프로그래밍에 대해 배우는 것은 책, 옷, 데이트에 대해 배우는 것과 매우 유사합니다. 즉, 고등학교 때 가졌던 나쁜 취향이었습니다.[4]다음은 적용된 공감의 예입니다.Viaweb에서 두 가지 대안 중 하나를 선택할 수 없다면 경쟁업체가 가장 싫어하는 것이 무엇인지 묻습니다.한때 경쟁업체는 기본적으로 쓸모없는 기능을 소프트웨어에 추가했지만 우리는 갖고 있지 않은 몇 안 되는 기능 중 하나였기 때문에 업계 언론에서 이 기능을 많이 사용했습니다.우리는 이 기능이 쓸모없다고 설명하려고 노력할 수도 있었지만, 우리가 직접 구현하면 경쟁업체를 더 짜증나게 할 것이라고 판단하여 그날 오후에 우리 자신의 버전을 함께 해킹했습니다.[5]텍스트 편집기와 컴파일러는 제외됩니다.해커는 이러한 기능을 설계하는 데 공감이 필요하지 않습니다. 왜냐하면 그들 자신이 일반적인 사용자이기 때문입니다.[6]글쎄, 거의.사용 가능한 RAM이 다소 초과되어 디스크 교체가 매우 불편해졌지만 이는 추가 디스크 드라이브를 구입하면 몇 달 내에 해결될 수 있습니다.[7]프로그램을 읽기 쉽게 만드는 방법은 주석으로 채우는 것이 아닙니다.나는 Abelson과 Sussman의 인용을 한 단계 더 발전시키고 싶습니다.프로그래밍 언어는 알고리즘을 표현하고 부수적으로 컴퓨터에 알고리즘 실행 방법을 알려주도록 설계되어야 합니다.좋은 프로그래밍 언어는 영어보다 소프트웨어를 설명하는 데 더 좋습니다.마치 도로에서 예상치 못하게 급커브가 있는 부분에 화살표만 있는 것과 마찬가지로 독자들에게 경고해야 할 어떤 종류의 문제가 있는 경우에만 설명이 필요합니다.초안을 읽어주신 Trevor Blackwell, Robert Morris, Dan Giffin, Lisa Randall에게 감사드리며, 강연에 초대해 주신 Henry Leitner와 Larry Finkelstein에게 감사드립니다. 일본어 번역스페인어 번역독일어 번역포르투갈어 번역체코어 번역왜 좋은 디자인이 나쁜 디자인에서 나오는가Knuth: Computer Program as an Art 이 에세이와 기타 14개의 에세이는 Hackers & Painters에서 찾을 수 있습니다.

---

## 원문 (Original Essay)

May 2003(This essay is derived from a guest lecture at Harvard, which incorporated an earlier talk at Northeastern.)When I finished grad school in computer science I went to art school to study painting. A lot of people seemed surprised that someone interested in computers would also be interested in painting. They seemed to think that hacking and painting were very different kinds of work-- that hacking was cold, precise, and methodical, and that painting was the frenzied expression of some primal urge.Both of these images are wrong. Hacking and painting have a lot in common. In fact, of all the different types of people I've known, hackers and painters are among the most alike.What hackers and painters have in common is that they're both makers. Along with composers, architects, and writers, what hackers and painters are trying to do is make good things. They're not doing research per se, though if in the course of trying to make good things they discover some new technique, so much the better.I've never liked the term "computer science." The main reason I don't like it is that there's no such thing. Computer science is a grab bag of tenuously related areas thrown together by an accident of history, like Yugoslavia. At one end you have people who are really mathematicians, but call what they're doing computer science so they can get DARPA grants. In the middle you have people working on something like the natural history of computers-- studying the behavior of algorithms for routing data through networks, for example. And then at the other extreme you have the hackers, who are trying to write interesting software, and for whom computers are just a medium of expression, as concrete is for architects or paint for painters. It's as if mathematicians, physicists, and architects all had to be in the same department.Sometimes what the hackers do is called "software engineering," but this term is just as misleading. Good software designers are no more engineers than architects are. The border between architecture and engineering is not sharply defined, but it's there. It falls between what and how: architects decide what to do, and engineers figure out how to do it.What and how should not be kept too separate. You're asking for trouble if you try to decide what to do without understanding how to do it. But hacking can certainly be more than just deciding how to implement some spec. At its best, it's creating the spec-- though it turns out the best way to do that is to implement it.Perhaps one day "computer science" will, like Yugoslavia, get broken up into its component parts. That might be a good thing. Especially if it meant independence for my native land, hacking.Bundling all these different types of work together in one department may be convenient administratively, but it's confusing intellectually. That's the other reason I don't like the name "computer science." Arguably the people in the middle are doing something like an experimental science. But the people at either end, the hackers and the mathematicians, are not actually doing science.The mathematicians don't seem bothered by this. They happily set to work proving theorems like the other mathematicians over in the math department, and probably soon stop noticing that the building they work in says ``computer science'' on the outside. But for the hackers this label is a problem. If what they're doing is called science, it makes them feel they ought to be acting scientific. So instead of doing what they really want to do, which is to design beautiful software, hackers in universities and research labs feel they ought to be writing research papers.In the best case, the papers are just a formality. Hackers write cool software, and then write a paper about it, and the paper becomes a proxy for the achievement represented by the software. But often this mismatch causes problems. It's easy to drift away from building beautiful things toward building ugly things that make more suitable subjects for research papers.Unfortunately, beautiful things don't always make the best subjects for papers. Number one, research must be original-- and as anyone who has written a PhD dissertation knows, the way to be sure that you're exploring virgin territory is to stake out a piece of ground that no one wants. Number two, research must be substantial-- and awkward systems yield meatier papers, because you can write about the obstacles you have to overcome in order to get things done. Nothing yields meaty problems like starting with the wrong assumptions. Most of AI is an example of this rule; if you assume that knowledge can be represented as a list of predicate logic expressions whose arguments represent abstract concepts, you'll have a lot of papers to write about how to make this work. As Ricky Ricardo used to say, "Lucy, you got a lot of explaining to do."The way to create something beautiful is often to make subtle tweaks to something that already exists, or to combine existing ideas in a slightly new way. This kind of work is hard to convey in a research paper.So why do universities and research labs continue to judge hackers by publications? For the same reason that "scholastic aptitude" gets measured by simple-minded standardized tests, or the productivity of programmers gets measured in lines of code. These tests are easy to apply, and there is nothing so tempting as an easy test that kind of works.Measuring what hackers are actually trying to do, designing beautiful software, would be much more difficult. You need a good sense of design to judge good design. And there is no correlation, except possibly a negative one, between people's ability to recognize good design and their confidence that they can.The only external test is time. Over time, beautiful things tend to thrive, and ugly things tend to get discarded. Unfortunately, the amounts of time involved can be longer than human lifetimes. Samuel Johnson said it took a hundred years for a writer's reputation to converge. You have to wait for the writer's influential friends to die, and then for all their followers to die.I think hackers just have to resign themselves to having a large random component in their reputations. In this they are no different from other makers. In fact, they're lucky by comparison. The influence of fashion is not nearly so great in hacking as it is in painting.There are worse things than having people misunderstand your work. A worse danger is that you will yourself misunderstand your work. Related fields are where you go looking for ideas. If you find yourself in the computer science department, there is a natural temptation to believe, for example, that hacking is the applied version of what theoretical computer science is the theory of. All the time I was in graduate school I had an uncomfortable feeling in the back of my mind that I ought to know more theory, and that it was very remiss of me to have forgotten all that stuff within three weeks of the final exam.Now I realize I was mistaken. Hackers need to understand the theory of computation about as much as painters need to understand paint chemistry. You need to know how to calculate time and space complexity and about Turing completeness. You might also want to remember at least the concept of a state machine, in case you have to write a parser or a regular expression library. Painters in fact have to remember a good deal more about paint chemistry than that.I've found that the best sources of ideas are not the other fields that have the word "computer" in their names, but the other fields inhabited by makers. Painting has been a much richer source of ideas than the theory of computation.For example, I was taught in college that one ought to figure out a program completely on paper before even going near a computer. I found that I did not program this way. I found that I liked to program sitting in front of a computer, not a piece of paper. Worse still, instead of patiently writing out a complete program and assuring myself it was correct, I tended to just spew out code that was hopelessly broken, and gradually beat it into shape. Debugging, I was taught, was a kind of final pass where you caught typos and oversights. The way I worked, it seemed like programming consisted of debugging.For a long time I felt bad about this, just as I once felt bad that I didn't hold my pencil the way they taught me to in elementary school. If I had only looked over at the other makers, the painters or the architects, I would have realized that there was a name for what I was doing: sketching. As far as I can tell, the way they taught me to program in college was all wrong. You should figure out programs as you're writing them, just as writers and painters and architects do.Realizing this has real implications for software design. It means that a programming language should, above all, be malleable. A programming language is for thinking of programs, not for expressing programs you've already thought of. It should be a pencil, not a pen. Static typing would be a fine idea if people actually did write programs the way they taught me to in college. But that's not how any of the hackers I know write programs. We need a language that lets us scribble and smudge and smear, not a language where you have to sit with a teacup of types balanced on your knee and make polite conversation with a strict old aunt of a compiler.While we're on the subject of static typing, identifying with the makers will save us from another problem that afflicts the sciences: math envy. Everyone in the sciences secretly believes that mathematicians are smarter than they are. I think mathematicians also believe this. At any rate, the result is that scientists tend to make their work look as mathematical as possible. In a field like physics this probably doesn't do much harm, but the further you get from the natural sciences, the more of a problem it becomes.A page of formulas just looks so impressive. (Tip: for extra impressiveness, use Greek variables.) And so there is a great temptation to work on problems you can treat formally, rather than problems that are, say, important.If hackers identified with other makers, like writers and painters, they wouldn't feel tempted to do this. Writers and painters don't suffer from math envy. They feel as if they're doing something completely unrelated. So are hackers, I think.If universities and research labs keep hackers from doing the kind of work they want to do, perhaps the place for them is in companies. Unfortunately, most companies won't let hackers do what they want either. Universities and research labs force hackers to be scientists, and companies force them to be engineers.I only discovered this myself quite recently. When Yahoo bought Viaweb, they asked me what I wanted to do. I had never liked the business side very much, and said that I just wanted to hack. When I got to Yahoo, I found that what hacking meant to them was implementing software, not designing it. Programmers were seen as technicians who translated the visions (if that is the word) of product managers into code.This seems to be the default plan in big companies. They do it because it decreases the standard deviation of the outcome. Only a small percentage of hackers can actually design software, and it's hard for the people running a company to pick these out. So instead of entrusting the future of the software to one brilliant hacker, most companies set things up so that it is designed by committee, and the hackers merely implement the design.If you want to make money at some point, remember this, because this is one of the reasons startups win. Big companies want to decrease the standard deviation of design outcomes because they want to avoid disasters. But when you damp oscillations, you lose the high points as well as the low. This is not a problem for big companies, because they don't win by making great products. Big companies win by sucking less than other big companies.So if you can figure out a way to get in a design war with a company big enough that its software is designed by product managers, they'll never be able to keep up with you. These opportunities are not easy to find, though. It's hard to engage a big company in a design war, just as it's hard to engage an opponent inside a castle in hand to hand combat. It would be pretty easy to write a better word processor than Microsoft Word, for example, but Microsoft, within the castle of their operating system monopoly, probably wouldn't even notice if you did.The place to fight design wars is in new markets, where no one has yet managed to establish any fortifications. That's where you can win big by taking the bold approach to design, and having the same people both design and implement the product. Microsoft themselves did this at the start. So did Apple. And Hewlett-Packard. I suspect almost every successful startup has.So one way to build great software is to start your own startup. There are two problems with this, though. One is that in a startup you have to do so much besides write software. At Viaweb I considered myself lucky if I got to hack a quarter of the time. And the things I had to do the other three quarters of the time ranged from tedious to terrifying. I have a benchmark for this, because I once had to leave a board meeting to have some cavities filled. I remember sitting back in the dentist's chair, waiting for the drill, and feeling like I was on vacation.The other problem with startups is that there is not much overlap between the kind of software that makes money and the kind that's interesting to write. Programming languages are interesting to write, and Microsoft's first product was one, in fact, but no one will pay for programming languages now. If you want to make money, you tend to be forced to work on problems that are too nasty for anyone to solve for free.All makers face this problem. Prices are determined by supply and demand, and there is just not as much demand for things that are fun to work on as there is for things that solve the mundane problems of individual customers. Acting in off-Broadway plays just doesn't pay as well as wearing a gorilla suit in someone's booth at a trade show. Writing novels doesn't pay as well as writing ad copy for garbage disposals. And hacking programming languages doesn't pay as well as figuring out how to connect some company's legacy database to their Web server.I think the answer to this problem, in the case of software, is a concept known to nearly all makers: the day job. This phrase began with musicians, who perform at night. More generally, it means that you have one kind of work you do for money, and another for love.Nearly all makers have day jobs early in their careers. Painters and writers notoriously do. If you're lucky you can get a day job that's closely related to your real work. Musicians often seem to work in record stores. A hacker working on some programming language or operating system might likewise be able to get a day job using it. [1]When I say that the answer is for hackers to have day jobs, and work on beautiful software on the side, I'm not proposing this as a new idea. This is what open-source hacking is all about. What I'm saying is that open-source is probably the right model, because it has been independently confirmed by all the other makers.It seems surprising to me that any employer would be reluctant to let hackers work on open-source projects. At Viaweb, we would have been reluctant to hire anyone who didn't. When we interviewed programmers, the main thing we cared about was what kind of software they wrote in their spare time. You can't do anything really well unless you love it, and if you love to hack you'll inevitably be working on projects of your own. [2]Because hackers are makers rather than scientists, the right place to look for metaphors is not in the sciences, but among other kinds of makers. What else can painting teach us about hacking?One thing we can learn, or at least confirm, from the example of painting is how to learn to hack. You learn to paint mostly by doing it. Ditto for hacking. Most hackers don't learn to hack by taking college courses in programming. They learn to hack by writing programs of their own at age thirteen. Even in college classes, you learn to hack mostly by hacking. [3]Because painters leave a trail of work behind them, you can watch them learn by doing. If you look at the work of a painter in chronological order, you'll find that each painting builds on things that have been learned in previous ones. When there's something in a painting that works very well, you can usually find version 1 of it in a smaller form in some earlier painting.I think most makers work this way. Writers and architects seem to as well. Maybe it would be good for hackers to act more like painters, and regularly start over from scratch, instead of continuing to work for years on one project, and trying to incorporate all their later ideas as revisions.The fact that hackers learn to hack by doing it is another sign of how different hacking is from the sciences. Scientists don't learn science by doing it, but by doing labs and problem sets. Scientists start out doing work that's perfect, in the sense that they're just trying to reproduce work someone else has already done for them. Eventually, they get to the point where they can do original work. Whereas hackers, from the start, are doing original work; it's just very bad. So hackers start original, and get good, and scientists start good, and get original. The other way makers learn is from examples. For a painter, a museum is a reference library of techniques. For hundreds of years it has been part of the traditional education of painters to copy the works of the great masters, because copying forces you to look closely at the way a painting is made.Writers do this too. Benjamin Franklin learned to write by summarizing the points in the essays of Addison and Steele and then trying to reproduce them. Raymond Chandler did the same thing with detective stories.Hackers, likewise, can learn to program by looking at good programs-- not just at what they do, but the source code too. One of the less publicized benefits of the open-source movement is that it has made it easier to learn to program. When I learned to program, we had to rely mostly on examples in books. The one big chunk of code available then was Unix, but even this was not open source. Most of the people who read the source read it in illicit photocopies of John Lions' book, which though written in 1977 was not allowed to be published until 1996.Another example we can take from painting is the way that paintings are created by gradual refinement. Paintings usually begin with a sketch. Gradually the details get filled in. But it is not merely a process of filling in. Sometimes the original plans turn out to be mistaken. Countless paintings, when you look at them in xrays, turn out to have limbs that have been moved or facial features that have been readjusted.Here's a case where we can learn from painting. I think hacking should work this way too. It's unrealistic to expect that the specifications for a program will be perfect. You're better off if you admit this up front, and write programs in a way that allows specifications to change on the fly.(The structure of large companies makes this hard for them to do, so here is another place where startups have an advantage.)Everyone by now presumably knows about the danger of premature optimization. I think we should be just as worried about premature design-- deciding too early what a program should do.The right tools can help us avoid this danger. A good programming language should, like oil paint, make it easy to change your mind. Dynamic typing is a win here because you don't have to commit to specific data representations up front. But the key to flexibility, I think, is to make the language very abstract. The easiest program to change is one that's very short. This sounds like a paradox, but a great painting has to be better than it has to be. For example, when Leonardo painted the portrait of Ginevra de Benci in the National Gallery, he put a juniper bush behind her head. In it he carefully painted each individual leaf. Many painters might have thought, this is just something to put in the background to frame her head. No one will look that closely at it.Not Leonardo. How hard he worked on part of a painting didn't depend at all on how closely he expected anyone to look at it. He was like Michael Jordan. Relentless.Relentlessness wins because, in the aggregate, unseen details become visible. When people walk by the portrait of Ginevra de Benci, their attention is often immediately arrested by it, even before they look at the label and notice that it says Leonardo da Vinci. All those unseen details combine to produce something that's just stunning, like a thousand barely audible voices all singing in tune.Great software, likewise, requires a fanatical devotion to beauty. If you look inside good software, you find that parts no one is ever supposed to see are beautiful too. I'm not claiming I write great software, but I know that when it comes to code I behave in a way that would make me eligible for prescription drugs if I approached everyday life the same way. It drives me crazy to see code that's badly indented, or that uses ugly variable names.If a hacker were a mere implementor, turning a spec into code, then he could just work his way through it from one end to the other like someone digging a ditch. But if the hacker is a creator, we have to take inspiration into account.In hacking, like painting, work comes in cycles. Sometimes you get excited about some new project and you want to work sixteen hours a day on it. Other times nothing seems interesting.To do good work you have to take these cycles into account, because they're affected by how you react to them. When you're driving a car with a manual transmission on a hill, you have to back off the clutch sometimes to avoid stalling. Backing off can likewise prevent ambition from stalling. In both painting and hacking there are some tasks that are terrifyingly ambitious, and others that are comfortingly routine. It's a good idea to save some easy tasks for moments when you would otherwise stall.In hacking, this can literally mean saving up bugs. I like debugging: it's the one time that hacking is as straightforward as people think it is. You have a totally constrained problem, and all you have to do is solve it. Your program is supposed to do x. Instead it does y. Where does it go wrong? You know you're going to win in the end. It's as relaxing as painting a wall.The example of painting can teach us not only how to manage our own work, but how to work together. A lot of the great art of the past is the work of multiple hands, though there may only be one name on the wall next to it in the museum. Leonardo was an apprentice in the workshop of Verrocchio and painted one of the angels in his Baptism of Christ. This sort of thing was the rule, not the exception. Michelangelo was considered especially dedicated for insisting on painting all the figures on the ceiling of the Sistine Chapel himself.As far as I know, when painters worked together on a painting, they never worked on the same parts. It was common for the master to paint the principal figures and for assistants to paint the others and the background. But you never had one guy painting over the work of another.I think this is the right model for collaboration in software too. Don't push it too far. When a piece of code is being hacked by three or four different people, no one of whom really owns it, it will end up being like a common-room. It will tend to feel bleak and abandoned, and accumulate cruft. The right way to collaborate, I think, is to divide projects into sharply defined modules, each with a definite owner, and with interfaces between them that are as carefully designed and, if possible, as articulated as programming languages.Like painting, most software is intended for a human audience. And so hackers, like painters, must have empathy to do really great work. You have to be able to see things from the user's point of view.When I was a kid I was always being told to look at things from someone else's point of view. What this always meant in practice was to do what someone else wanted, instead of what I wanted. This of course gave empathy a bad name, and I made a point of not cultivating it.Boy, was I wrong. It turns out that looking at things from other people's point of view is practically the secret of success. It doesn't necessarily mean being self-sacrificing. Far from it. Understanding how someone else sees things doesn't imply that you'll act in his interest; in some situations-- in war, for example-- you want to do exactly the opposite. [4]Most makers make things for a human audience. And to engage an audience you have to understand what they need. Nearly all the greatest paintings are paintings of people, for example, because people are what people are interested in.Empathy is probably the single most important difference between a good hacker and a great one. Some hackers are quite smart, but when it comes to empathy are practically solipsists. It's hard for such people to design great software [5], because they can't see things from the user's point of view.One way to tell how good people are at empathy is to watch them explain a technical question to someone without a technical background. We probably all know people who, though otherwise smart, are just comically bad at this. If someone asks them at a dinner party what a programming language is, they'll say something like ``Oh, a high-level language is what the compiler uses as input to generate object code.'' High-level language? Compiler? Object code? Someone who doesn't know what a programming language is obviously doesn't know what these things are, either.Part of what software has to do is explain itself. So to write good software you have to understand how little users understand. They're going to walk up to the software with no preparation, and it had better do what they guess it will, because they're not going to read the manual. The best system I've ever seen in this respect was the original Macintosh, in 1985. It did what software almost never does: it just worked. [6]Source code, too, should explain itself. If I could get people to remember just one quote about programming, it would be the one at the beginning of Structure and Interpretation of Computer Programs. Programs should be written for people to read, and only incidentally for machines to execute. You need to have empathy not just for your users, but for your readers. It's in your interest, because you'll be one of them. Many a hacker has written a program only to find on returning to it six months later that he has no idea how it works. I know several people who've sworn off Perl after such experiences. [7]Lack of empathy is associated with intelligence, to the point that there is even something of a fashion for it in some places. But I don't think there's any correlation. You can do well in math and the natural sciences without having to learn empathy, and people in these fields tend to be smart, so the two qualities have come to be associated. But there are plenty of dumb people who are bad at empathy too. Just listen to the people who call in with questions on talk shows. They ask whatever it is they're asking in such a roundabout way that the hosts often have to rephrase the question for them.So, if hacking works like painting and writing, is it as cool? After all, you only get one life. You might as well spend it working on something great.Unfortunately, the question is hard to answer. There is always a big time lag in prestige. It's like light from a distant star. Painting has prestige now because of great work people did five hundred years ago. At the time, no one thought these paintings were as important as we do today. It would have seemed very odd to people at the time that Federico da Montefeltro, the Duke of Urbino, would one day be known mostly as the guy with the strange nose in a painting by Piero della Francesca.So while I admit that hacking doesn't seem as cool as painting now, we should remember that painting itself didn't seem as cool in its glory days as it does now.What we can say with some confidence is that these are the glory days of hacking. In most fields the great work is done early on. The paintings made between 1430 and 1500 are still unsurpassed. Shakespeare appeared just as professional theater was being born, and pushed the medium so far that every playwright since has had to live in his shadow. Albrecht Durer did the same thing with engraving, and Jane Austen with the novel.Over and over we see the same pattern. A new medium appears, and people are so excited about it that they explore most of its possibilities in the first couple generations. Hacking seems to be in this phase now.Painting was not, in Leonardo's time, as cool as his work helped make it. How cool hacking turns out to be will depend on what we can do with this new medium. Notes[1] The greatest damage that photography has done to painting may be the fact that it killed the best day job. Most of the great painters in history supported themselves by painting portraits. [2] I've been told that Microsoft discourages employees from contributing to open-source projects, even in their spare time. But so many of the best hackers work on open-source projects now that the main effect of this policy may be to ensure that they won't be able to hire any first-rate programmers.[3] What you learn about programming in college is much like what you learn about books or clothes or dating: what bad taste you had in high school.[4] Here's an example of applied empathy. At Viaweb, if we couldn't decide between two alternatives, we'd ask, what would our competitors hate most? At one point a competitor added a feature to their software that was basically useless, but since it was one of few they had that we didn't, they made much of it in the trade press. We could have tried to explain that the feature was useless, but we decided it would annoy our competitor more if we just implemented it ourselves, so we hacked together our own version that afternoon.[5] Except text editors and compilers. Hackers don't need empathy to design these, because they are themselves typical users.[6] Well, almost. They overshot the available RAM somewhat, causing much inconvenient disk swapping, but this could be fixed within a few months by buying an additional disk drive.[7] The way to make programs easy to read is not to stuff them with comments. I would take Abelson and Sussman's quote a step further. Programming languages should be designed to express algorithms, and only incidentally to tell computers how to execute them. A good programming language ought to be better for explaining software than English. You should only need comments when there is some kind of kludge you need to warn readers about, just as on a road there are only arrows on parts with unexpectedly sharp curves. Thanks to Trevor Blackwell, Robert Morris, Dan Giffin, and Lisa Randall for reading drafts of this, and to Henry Leitner and Larry Finkelstein for inviting me to speak.Japanese TranslationSpanish TranslationGerman TranslationPortuguese TranslationCzech TranslationWhy Good Design Comes from Bad DesignKnuth: Computer Programming as an Art You'll find this essay and 14 others in Hackers & Painters.

---

_분석일: 2025. 11. 29._
_수집일: 2025. 11. 28._
